<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TPreventKVC的使用和实现]]></title>
    <url>%2F2018%2F04%2F04%2FiOS%2F18040401.TPreventKVC%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%2Findex%2F</url>
    <content type="text"><![CDATA[TPreventKVC 项目的 GitHub 地址： https://github.com/tobedefined/TPreventKVC 实现方式使用+load方法替换NSObject的 -setValue:forUndefinedKey: / valueForUndefinedKey: / setNilValueForKey: 这几个方法，防止产生 NSUnknownKeyException 和 NSInvalidArgumentException 异常，引发崩溃。 具体实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@implementation NSObject (PreventKVC)#pragma mark - HandleKVCErrorBlock+ (void)setHandleKVCErrorBlock:(HandleKVCErrorBlock)handleBlock &#123; objc_setAssociatedObject(self, @selector(handleKVCErrorBlock), handleBlock, OBJC_ASSOCIATION_RETAIN);&#125;+ (HandleKVCErrorBlock)handleKVCErrorBlock &#123; return objc_getAssociatedObject(self, _cmd);&#125;+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; method_exchangeImplementations(class_getInstanceMethod(self, @selector(setValue:forUndefinedKey:)), class_getInstanceMethod(self, @selector(__t_setValue:forUndefinedKey:))); method_exchangeImplementations(class_getInstanceMethod(self, @selector(valueForUndefinedKey:)), class_getInstanceMethod(self, @selector(__t_valueForUndefinedKey:))); method_exchangeImplementations(class_getInstanceMethod(self, @selector(setNilValueForKey:)), class_getInstanceMethod(self, @selector(__t_setNilValueForKey:))); &#125;);&#125;- (void)__t_setValue:(nullable id)value forUndefinedKey:(NSString *)key &#123; HandleKVCErrorBlock handleBlock = [NSObject handleKVCErrorBlock]; if (handleBlock != nil) &#123; NSArray &lt;NSString *&gt;*callStackSymbols = @[@"The system version is too low."]; if (@available(iOS 4.0, tvOS 9.0, macOS 10.6, watchOS 2.0, *)) &#123; callStackSymbols = [NSThread callStackSymbols]; &#125; handleBlock([self class], key, KVCErrorTypeSetValueForUndefinedKey, callStackSymbols); &#125;&#125;- (nullable id)__t_valueForUndefinedKey:(NSString *)key &#123; HandleKVCErrorBlock handleBlock = [NSObject handleKVCErrorBlock]; if (handleBlock != nil) &#123; NSArray &lt;NSString *&gt;*callStackSymbols = @[@"The system version is too low."]; if (@available(iOS 4.0, tvOS 9.0, macOS 10.6, watchOS 2.0, *)) &#123; callStackSymbols = [NSThread callStackSymbols]; &#125; handleBlock([self class], key, KVCErrorTypeValueForUndefinedKey, callStackSymbols); &#125; return nil;&#125;- (void)__t_setNilValueForKey:(NSString *)key &#123; HandleKVCErrorBlock handleBlock = [NSObject handleKVCErrorBlock]; if (handleBlock != nil) &#123; NSArray &lt;NSString *&gt;*callStackSymbols = @[@"The system version is too low."]; if (@available(iOS 4.0, tvOS 9.0, macOS 10.6, watchOS 2.0, *)) &#123; callStackSymbols = [NSThread callStackSymbols]; &#125; handleBlock([self class], key, KVCErrorTypeSetNilValueForKey, callStackSymbols); &#125; [self setValue:nil forKey:key];&#125;@end 特点使用runtime动态替换方法防止在使用KVC的方法时候产生 NSUnknownKeyException &amp; NSInvalidArgumentException 错误引发崩溃。 -valueForKey: setValue:forKey: -setValue:forKeyPath: -valueForKeyPath:等等 如何导入源文件将TPreventKVC文件夹内部的所有文件拖入项目中即可 CocoaPodsCocoaPods是一个Cocoa项目管理器。你可以使用以下命令去安装CocoaPods: 1$ gem install cocoapods 要使用CocoaPods将TPreventKVC集成到您的Xcode项目中，请在Podfile中加入： 1pod 'TPreventKVC' 然后运行一下命令: 1$ pod install CarthageCarthage是一个去中心化的依赖管理器，它构建并提供所使用的库的framework。 你可以使用 Homebrew并运行下面的命令安装Carthage 12$ brew update$ brew install carthage 要将TPreventKVC集成到使用Carthage的Xcode项目中，请在Cartfile中加入： 1github "tobedefined/TPreventKVC" 运行carthage update构建framework，并将编译的对应平台的TPreventKVC.framework拖入Xcode项目中。 使用方法简单使用导入项目之后即可。 运行错误信息获取在APP的 main.m文件的main()函数中 或者 在APP的didFinishLaunching方法中 加入以下代码可以获得缺失方法的具体信息： 1234[NSObject setHandleKVCErrorBlock:^(__unsafe_unretained Class cls, NSString *key, KVCErrorType errorType) &#123; // 在这里写你要做的事情 // 比如上传到服务器或者打印log等&#125;]; Some Definitions在NSObject+PreventKVC.h中有以下定义 1234567typedef NS_ENUM(NSUInteger, KVCErrorType) &#123; KVCErrorTypeSetValueForUndefinedKey = 1, KVCErrorTypeValueForUndefinedKey = 2, KVCErrorTypeSetNilValueForKey = 3,&#125;;typedef void (^ __nullable HandleKVCErrorBlock)(Class cls, NSString *key, KVCErrorType errorType); cls: Class类型；为产生错误的类或对象的Class，可使用NSStringFromClass(cls)返回类名字符串 key: NSString *类型；为产生错误的Key errorType: KVCErrorType类型；为产生错误的类型 callStackSymbols: NSArray&lt;NSString *&gt; *类型；为调用栈信息]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TPreventUnrecognizedSEL实现思路以及原理]]></title>
    <url>%2F2017%2F11%2F26%2FiOS%2F17112601.TPreventUnrecognizedSEL%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86%2Findex%2F</url>
    <content type="text"><![CDATA[TPreventUnrecognizedSEL 项目的 GitHub 地址： https://github.com/tobedefined/TPreventUnrecognizedSELTPreventUnrecognizedSEL 的使用方法： LINK 关于方法的调用，ObjC对象以及类的结构，和unrecognized selector异常的产生流程的博文很多，这里只讲解和这个项目实现有关的重要部分，详细了解可以参考文末的参考文档。 objc_msgSend(id, SEL, ...)在谈论这个之前，先写一段测试代码，如下： 123456789101112131415161718192021// main.m#import &lt;Foundation/Foundation.h&gt;#pragma mark - OBJ@interface TestOBJ: NSObject- (void)instanceMethod;+ (void)classMethod;@end@implementation TestOBJ- (void)instanceMethod &#123;&#125;+ (void)classMethod &#123;&#125;@end#pragma mark - Mainint main(int argc, const char * argv[]) &#123; TestOBJ *obj = [[TestOBJ alloc] init]; [obj instanceMethod]; [TestOBJ classMethod]; return 0;&#125; 在命令行中运行clang -rewrite-objc main.m，在文件夹下生成main.cpp的C++文件，打开main.cpp找到C++的main函数（我的在第96634行），可以看到如下代码 123456int main(int argc, const char * argv[]) &#123; TestOBJ *obj = ((TestOBJ *(*)(id, SEL))(void *)objc_msgSend)((id)((TestOBJ *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass("TestOBJ"), sel_registerName("alloc")), sel_registerName("init")); ((void (*)(id, SEL))(void *)objc_msgSend)((id)obj, sel_registerName("instanceMethod")); ((void (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass("TestOBJ"), sel_registerName("classMethod")); return 0;&#125; 这段代码中包含了很多的类型转换，现在将类型转换去掉，转变后的代码更容易阅读，如下： 123456789int main(int argc, const char * argv[]) &#123; // 1 TestOBJ *obj = objc_msgSend(objc_msgSend(objc_getClass("TestOBJ"), sel_registerName("alloc")), sel_registerName("init")); // 2 objc_msgSend(obj, sel_registerName("instanceMethod")); // 3 objc_msgSend(objc_getClass("TestOBJ"), sel_registerName("classMethod")); return 0;&#125; 首先看第二行代码objc_msgSend(obj, sel_registerName(&quot;instanceMethod&quot;));，这段代码将[obj instanceMethod]; rewrite 成了这种方式，也就是说ObjC中中括号调用方法实际上是调用了OBJC_EXPORT id _Nullable objc_msgSend(id _Nullable self, SEL _Nonnull op, ...)的方法，第一个参数传的是调用方法的对象，第二个参数传的是方法选择器。 然后看第三行代码objc_msgSend(objc_getClass(&quot;TestOBJ&quot;), sel_registerName(&quot;classMethod&quot;));，与上面类似，只是第一个含参数传的是调用方法的Class（他也就是调用类方法的对象）。 那么回头看第一行代码，就很容易理解了，TestOBJ *obj = objc_msgSend(objc_msgSend(objc_getClass(&quot;TestOBJ&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));可以拆分成两个部分，如下，就不在讨论了 12id obj_alloc = objc_msgSend(objc_getClass("TestOBJ"), sel_registerName("alloc"))TestOBJ *obj = objc_msgSend(obj_alloc, sel_registerName("init")) 类是什么？网上很多的博文都写到了，类也是一个对象，关于这块有很多资料。可以从runtime源码中看到类就是一个对象。 runtime可运行修改版GitHub地址 git@github.com:RetVal/objc-runtime.git, 下面代码摘自这个版本的runtime源码。 打开/Project Headers/objc-private.h文件可以看到objc_object的实现，我们用的oc对象其实就是一个objc_object 12345678910111213struct objc_object &#123;private: isa_t isa;public: // ISA() assumes this is NOT a tagged pointer object Class ISA(); // getIsa() allows this to be a tagged pointer object Class getIsa();......&#125; 打开/Project Headers/objc-runtime-new.h文件可以看到objc_class的实现，oc中的类就是objc_class 1234567891011121314struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() &#123; return bits.data(); &#125; void setData(class_rw_t *newData) &#123; bits.setData(newData); &#125;......&#125; 可以看到objc_class是继承自objc_object的，所以objc_class也是一个对象是没错的。 这里我们关注下面这部分：(下面的代码进行了改写，比较容易理解混合了OBJC和OBJC2的代码，实际情况远比这复杂的多，详细了解参考文末的资料) 123456789101112131415161718192021222324252627282930// 上述的runtime源码// File: "/Project Headers/objc-private.h"// Line: 48struct objc_class;struct objc_object;typedef struct objc_class *Class;typedef struct objc_object *id;// 上述的runtime源码// File: "/Project Headers/objc-private.h"// Line: 168struct objc_object &#123; isa_t isa;&#125;;// macOS 的runtime.h头文件和上述的runtime源码// File: "/Project Headers/objc-runtime-new.h"// Line: 1064struct objc_class : objc_object &#123; Class superclass; struct objc_method_list **methodLists;&#125;;// 上述的runtime源码// File: "/Project Headers/objc-private.h"// Line: 68union isa_t &#123; Class cls;&#125; 可以看到以下重要的几点内容： id 是一个指向 objc_object 的指针 Class 是一个指向 objc_class 的指针 objc_object 中包含 isa_t isa; isa 中包含 Class cls;，cls 指向对应的Class objc_class 继承自 objc_object，所以也属于 objc_object，同样也包含 isa，也指向一个 Class ，这个 Class 我们称之为元类，即 meta class meta class 也是 Class，同样也包含 isa，它指向 NSObject 的 meta class，另外，NSObject meta class 的 isa 指向自身 这里有一张经典的图： 方法的调用过程关于 objc_class 中的 methodLists ，很明显， methodLists 就是函数列表，他存储着这个类的所有对象方法，没错， objc_class 中 methodLists 存储的是对象方法；而类方法则是存储在 meta class 的 methodLists 中。通俗的说，就是我们写的 - 号开头的方法(对象方法)，则加入 Class 的 methodLists 之中；+ 写的方法(类方法)，加入 meta class 的 methodLists 之中。 对象方法和类方法的调用运行走的是同一套流程。 对象方法 转换成 objc_msgSend(obj, sel, ...) 形式 对象调用方法时，首先通过 isa 找到所属的类，然后获取 methodLists 中对应的 sel 的函数的地址 运行函数 类方法 转换成 objc_msgSend(cls, sel, ...) 形式 类调用类方法时，首先通过该类的 isa 找到所属的元类，然后获取 methodLists 中对应的 sel 的函数的地址 运行函数 Unrecognized Selector 错误 对象方法：*** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;-[TestClass losted:instance:method:]: unrecognized selector sent to instance 0x102c....&#39; 类方法：*** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;+[TestClass losted:class:method:]: unrecognized selector sent to class 0x10000....&#39; 众所周知，产生 Unrecognized Selector 错误之前，系统会给出多次机会让用户进行添加方法或转发，一般分为两个步骤（Method Resolution、 Forwarding）或三个步骤（Method Resolution、 Fast Forwarding 和 Normal Forwarding） Method Resolution ObjC运行时会调用 + (BOOL)resolveInstanceMethod:(SEL)sel 或者 + (BOOL)resolveClassMethod:(SEL)sel，让你有机会提供一个函数实现添加为对象方法或类方法。添加了函数之后，返回YES，系统就会重新启动一次消息发送的过程，如果返回NO，系统就会开始进行消息转发的过程。 Fast Forwarding 快速转发过程，- (id)forwardingTargetForSelector:(SEL)aSelector，系统会调用这个方法对对象方法的调用进行转发，如果返回一个newObject，则相当于转发后运行 [newObject performSelector:aSelector]。如果返回的是nil，则进入默认转发的过程。 Normal Forwarding 这一步是runtime的最后一次转发过程。在这一个过程中，首先调用- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector获取SEL的函数签名，这个时候你应该返回一个存在的已经函数签名，如果返回的是nil，此时runtime就会发出- (void)doesNotRecognizeSelector:(SEL)aSelector消息，这个时候，程序就会crash崩溃掉了。如果返回了一个函数签名，就会根据这个函数签名创建一个NSInvocation的对象并发送- (void)forwardInvocation:(NSInvocation *)anInvocation消息给目标对象。 我们主要通过Forwarding的两步操作进行防止产生 Unrecognized Selector 错误（Method Resolution过程在runtime中经常会进行主动去掉用，如果使用Resolution，可能产生死循环）。但是可以发现，-forwardingTargetForSelector:、 -methodSignatureForSelector:、 -forwardInvocation: 都只存在对象方法，而不存在类方法。这时候改如何解决？ 回到前面，类其实也是一个对象，是元类(meta class)的对象，而元类(meta class)的结构是和Class的结构是相同的，都是objc_class，而类方法的调用和对象方法的调用走的是同一个流程，则我们添加这几个方法到元类(meta class)中，就可以解决类方法不存在的流程；即将-forwardingTargetForSelector:、 -methodSignatureForSelector:、 -forwardInvocation: 写作 +forwardingTargetForSelector:、 +methodSignatureForSelector:、 +forwardInvocation: 既可以添加到元类(meta class)的 methodLists之中 关于一些runtime的函数以及作用class_getName12OBJC_EXPORT const char * _Nonnullclass_getName(Class _Nullable cls); class_getName方法是获取Class的 C String，相当于C语言版本的 NSString *NSStringFromClass(Class aClass) objc_getClass12OBJC_EXPORT Class _Nullableobjc_getClass(const char * _Nonnull name); objc_getClass方法是获取根据 C String 获取一个 Class，相当于C语言版本的 Class _Nullable NSClassFromString(NSString *aClassName) objc_getMetaClass12OBJC_EXPORT Class _Nullableobjc_getMetaClass(const char * _Nonnull name); objc_getMetaClass方法是获取根据 C string 获取这个 String 所表示的 Class 的 MetaClass比如以下代码: 123char myClassName[] = "MyClass";Class myClass = objc_getClass(myClassName);Class myMetaClass = objc_getMetaClass(myClassName); 其中 myClass 是 MyClass 这个类，myMetaClass 是 MyClass 这个类的元类所以获取当前类的元类可以使用objc_getMetaClass(class_getName(self)) 或者 objc_getMetaClass(class_getName([self class])) class_getInstanceMethod12OBJC_EXPORT Method _Nullableclass_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name); 返回Class的对象方法SEL的函数指针 class_getClassMethod12OBJC_EXPORT Method _Nullableclass_getClassMethod(Class _Nullable cls, SEL _Nonnull name); 返回Class的类方法SEL的函数指针，等同于class_getInstanceMethod(objc_getMetaClass(class_getName(self)), name) method_exchangeImplementations12OBJC_EXPORT voidmethod_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2); 用于替换两个函数的实现。 比如以下代码中 1234567891011121314@implementation MyOBJ+ (void)load &#123; method_exchangeImplementations(class_getInstanceMethod(self, @selector(instanceMethodOne)), class_getInstanceMethod(self, @selector(instanceMethodTwo)));&#125;- (void)instanceMethodOne &#123; // 函数体1&#125;- (void)instanceMethodTwo &#123; // 函数体2&#125;@end -instanceMethodOne将与-instanceMethodTwo将会指向对方的函数体，也就是说[obj instanceMethodOne]其实是调用的函数体2，[obj instanceMethodTwo]其实是调用的函数体1。 class_addMethod123OBJC_EXPORT BOOLclass_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types); 对 Class cls 添加名为 name 的 selector，指向的函数实现为 imp, 函数的 Type Encoding 为 types Type Encoding 可以参考：Type Encoding 关于+loadload方法的调用规则： 调用顺序 父类 &gt; 子类 &gt; 分类 调用+load之前先调用父类的+load，这个过程自动实现，不需要手动添加[super load]; 如果一个类没有实现+load方法，不会沿用父类的实现 一个+load函数只会执行一次 类和分类都执行中的+load都会执行 调用时机：类被添加到 runtime 时(对于动态库和静态库中的class和category都有效) 实现HandleUnrecognizedSELErrorBlock12345678910111213141516171819202122// NSObject+TPUSELFastForwarding.h 或 NSObject+TPUSELNormalForwarding.htypedef NS_ENUM(NSUInteger, UnrecognizedMethodType) &#123; UnrecognizedMethodTypeClassMethod = 1, UnrecognizedMethodTypeInstanceMethod = 2,&#125;;typedef void (^ __nullable HandleUnrecognizedSELErrorBlock)(Class cls, SEL selector, UnrecognizedMethodType methodType);// NSObject+TPUSELFastForwarding.m 或 NSObject+TPUSELNormalForwarding.m@implementation NSObject (ADD)+ (void)setHandleUnrecognizedSELErrorBlock:(HandleUnrecognizedSELErrorBlock)handleBlock &#123; objc_setAssociatedObject(self, @selector(handleUnrecognizedSELErrorBlock), handleBlock, OBJC_ASSOCIATION_RETAIN);&#125;+ (HandleUnrecognizedSELErrorBlock)handleUnrecognizedSELErrorBlock &#123; return objc_getAssociatedObject(self, @selector(handleUnrecognizedSELErrorBlock));&#125;@end 用于向外部传出所丢失函数的具体错误信息，向 NSObject 的 Class对象添加关联block，并在在适当的时候调用，具体参数的信息如下 cls: Class类型；为缺失方法的类或对象的Class，可使用NSStringFromClass(cls)返回类名字符串 selector: SEL类型；为所缺失的方法名，可使用NSStringFromSelector(selector)返回方法名的字符串 methodType: UnrecognizedMethodType类型；为所缺失的方法类型（类方法or对象方法） TPUSELFastForwarding核心代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130// NSObject+TPUSELFastForwarding.mvoid __c_t_resolveLostedMethod(id self, SEL _cmd, ...) &#123;&#125;@implementation NSObject (TPUSELFastForwarding)#pragma mark - HandleUnrecognizedSELErrorBlock+ (void)setJustForwardClassArray:(NSArray *)forwardClassArray handleUnrecognizedSELErrorBlock:(HandleUnrecognizedSELErrorBlock)handleBlock &#123; objc_setAssociatedObject(self, @selector(handleUnrecognizedSELErrorBlock), handleBlock, OBJC_ASSOCIATION_RETAIN); objc_setAssociatedObject(self, @selector(justForwardClassArray), forwardClassArray, OBJC_ASSOCIATION_RETAIN);&#125;+ (HandleUnrecognizedSELErrorBlock)handleUnrecognizedSELErrorBlock &#123; return objc_getAssociatedObject(self, _cmd);&#125;+ (NSArray *)justForwardClassArray &#123; return (NSArray *)objc_getAssociatedObject(self, _cmd);&#125;+ (BOOL)isCanFowardingFor:(Class)cls &#123; // is setting justForwardClassArray, will just forward the class(and subclass) inside of the justForwardClassArray for (NSObject *element in [NSObject justForwardClassArray]) &#123; Class justForwardCls; if ([element isKindOfClass:[NSString class]]) &#123; justForwardCls = NSClassFromString((NSString *)element); &#125; else &#123; justForwardCls = (Class)element; &#125; if ([cls isSubclassOfClass:justForwardCls]) &#123; return YES; &#125; &#125; return NO;&#125;+ (Class)getProtectorClass &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class protectorCls = objc_allocateClassPair([NSObject class], "__TProtectorClass", 0); objc_registerClassPair(protectorCls); &#125;); Class protectorCls = NSClassFromString(@"__TProtectorClass"); return protectorCls;&#125;+ (instancetype)getProtectorInstance &#123; static id __t_protector_instance; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; __t_protector_instance = [[[self getProtectorClass] alloc] init]; &#125;); return __t_protector_instance;&#125;#pragma mark - FastForwarding+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; method_exchangeImplementations(class_getInstanceMethod(self, @selector(forwardingTargetForSelector:)), class_getInstanceMethod(self, @selector(__t_forwardingTargetForSelector:))); method_exchangeImplementations(class_getClassMethod(self, @selector(forwardingTargetForSelector:)), class_getClassMethod(self, @selector(__t_forwardingTargetForSelector:))); &#125;);&#125;- (id)__t_forwardingTargetForSelector:(SEL)aSelector &#123; if ([self respondsToSelector:aSelector]) &#123; return [self __t_forwardingTargetForSelector:aSelector]; &#125; if ([NSObject isCanFowardingFor:[self class]]) &#123; class_addMethod([NSObject getProtectorClass], aSelector, (IMP)__c_t_resolveLostedMethod, "v@:"); HandleUnrecognizedSELErrorBlock handleBlock = [NSObject handleUnrecognizedSELErrorBlock]; if (handleBlock != nil) &#123; NSArray &lt;NSString *&gt;*callStackSymbols = @[@"The system version is too low."]; if (@available(iOS 4.0, tvOS 9.0, macOS 10.6, watchOS 2.0, *)) &#123; callStackSymbols = [NSThread callStackSymbols]; &#125; handleBlock([self class], aSelector, UnrecognizedMethodTypeInstanceMethod, callStackSymbols); &#125; return [NSObject getProtectorInstance]; &#125; return [self __t_forwardingTargetForSelector:aSelector];&#125;+ (id)__t_forwardingTargetForSelector:(SEL)aSelector &#123; if ([self respondsToSelector:aSelector]) &#123; return [self __t_forwardingTargetForSelector:aSelector]; &#125; if ([NSObject isCanFowardingFor:self]) &#123; class_addMethod(objc_getMetaClass(class_getName([NSObject getProtectorClass])), aSelector, (IMP)__c_t_resolveLostedMethod, "v@:"); HandleUnrecognizedSELErrorBlock handleBlock = [NSObject handleUnrecognizedSELErrorBlock]; if (handleBlock != nil) &#123; NSArray &lt;NSString *&gt;*callStackSymbols = @[@"The system version is too low."]; if (@available(iOS 4.0, tvOS 9.0, macOS 10.6, watchOS 2.0, *)) &#123; callStackSymbols = [NSThread callStackSymbols]; &#125; handleBlock([self class], aSelector, UnrecognizedMethodTypeClassMethod, callStackSymbols); &#125; return [NSObject getProtectorClass]; &#125; return [self __t_forwardingTargetForSelector:aSelector];&#125;@end 思路： 在+load中替换forwardingTargetForSelector:方法（类中和元类中都进行替换） [NSObject getProtectorClass] 和 [NSObject getProtectorInstance] 获得一个承载添加方法的类和对象，用于添加缺失的方法和方法调用 在__t_forwardingTargetForSelector:中： 判断本类是否包含aSelector，如果包含，返回自身；若不包含走下一步。 判断是否允许处理该类型的类，如果不允许，不进行处理，调用__t_forwardingTargetForSelector去执行原函数；如果允许，走下一步 使用 class_addMethod 对 [NSObject getProtectorClass] 添加方法的实现（解决对象方法缺失问题）或对 [NSObject getProtectorClass] 的元类添加方法的实现（解决类方法缺失问题）； 获取 handleBlock，调用block将具体信息传出去。 返回 [NSObject getProtectorInstance] （解决对象方法缺失问题）或者 [NSObject getProtectorClass] （Class对象， 解决类方法缺失问题） TPUSELNormalForwarding123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175// NSObject+TPUSELNormalForwarding.m@implementation NSObject (TPUSELNormalForwarding)#pragma mark - HandleUnrecognizedSELErrorBlock+ (void)setHandleUnrecognizedSELErrorBlock:(HandleUnrecognizedSELErrorBlock)handleBlock &#123; objc_setAssociatedObject(self, @selector(handleUnrecognizedSELErrorBlock), handleBlock, OBJC_ASSOCIATION_RETAIN);&#125;+ (HandleUnrecognizedSELErrorBlock)handleUnrecognizedSELErrorBlock &#123; return objc_getAssociatedObject(self, _cmd);&#125;+ (void)setJustForwardClassArray:(NSArray&lt;NSString *&gt; *)forwardClassArray; &#123; objc_setAssociatedObject(self, @selector(justForwardClassArray), forwardClassArray, OBJC_ASSOCIATION_RETAIN);&#125;+ (NSArray *)justForwardClassArray &#123; return (NSArray&lt;NSString *&gt; *)objc_getAssociatedObject(self, _cmd);&#125;+ (void)setIgnoreForwardNSNullClass:(BOOL)ignoreNSNull &#123; objc_setAssociatedObject(self, @selector(ignoreForwardNSNullClass), [NSNumber numberWithBool:ignoreNSNull], OBJC_ASSOCIATION_RETAIN);&#125;+ (BOOL)ignoreForwardNSNullClass &#123; return [(NSNumber *)objc_getAssociatedObject(self, _cmd) boolValue];&#125;+ (void)setIgnoreForwardClassArray:(NSArray&lt;NSString *&gt; *)ignoreClassArray &#123; objc_setAssociatedObject(self, @selector(ignoreForwardClassArray), ignoreClassArray, OBJC_ASSOCIATION_RETAIN);&#125;+ (NSArray *)ignoreForwardClassArray &#123; return (NSArray *)objc_getAssociatedObject(self, _cmd);&#125;+ (BOOL)isCanFowardingFor:(Class)cls &#123; if ([NSObject ignoreForwardNSNullClass] &amp;&amp; [cls isSubclassOfClass:[NSNull class]]) &#123; return NO; &#125; for (NSObject *element in [NSObject ignoreForwardClassArray]) &#123; Class ignoreCls; if ([element isKindOfClass:[NSString class]]) &#123; ignoreCls = NSClassFromString((NSString *)element); &#125; else &#123; ignoreCls = (Class)element; &#125; if ([cls isSubclassOfClass:ignoreCls]) &#123; return NO; &#125; &#125; // is setting justForwardClassArray, will just forward the class(and subclass) inside of the justForwardClassArray NSArray *justForwardClassArray = [NSObject justForwardClassArray]; if (justForwardClassArray.count &gt; 0) &#123; for (NSObject *element in justForwardClassArray) &#123; Class justForwardCls; if ([element isKindOfClass:[NSString class]]) &#123; justForwardCls = NSClassFromString((NSString *)element); &#125; else &#123; justForwardCls = (Class)element; &#125; if ([cls isSubclassOfClass:justForwardCls]) &#123; return YES; &#125; &#125; return NO; &#125; return YES;&#125;#pragma mark - ForwardInvocation+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; method_exchangeImplementations(class_getInstanceMethod(self, @selector(methodSignatureForSelector:)), class_getInstanceMethod(self, @selector(__t_methodSignatureForSelector:))); method_exchangeImplementations(class_getInstanceMethod(self, @selector(forwardInvocation:)), class_getInstanceMethod(self, @selector(__t_forwardInvocation:))); method_exchangeImplementations(class_getClassMethod(self, @selector(methodSignatureForSelector:)), class_getClassMethod(self, @selector(__t_methodSignatureForSelector:))); method_exchangeImplementations(class_getClassMethod(self, @selector(forwardInvocation:)), class_getClassMethod(self, @selector(__t_forwardInvocation:))); &#125;);&#125;- (NSMethodSignature *)__t_methodSignatureForSelector:(SEL)aSelector &#123; NSMethodSignature *signature = [self __t_methodSignatureForSelector:aSelector]; if (signature || [self respondsToSelector:aSelector]) &#123; return signature; &#125; if (![NSObject isCanFowardingFor:[self class]]) &#123; return signature; &#125; HandleUnrecognizedSELErrorBlock handleBlock = [NSObject handleUnrecognizedSELErrorBlock]; if (handleBlock != nil) &#123; NSArray &lt;NSString *&gt;*callStackSymbols = @[@"The system version is too low."]; if (@available(iOS 4.0, tvOS 9.0, macOS 10.6, watchOS 2.0, *)) &#123; callStackSymbols = [NSThread callStackSymbols]; &#125; handleBlock([self class], aSelector, UnrecognizedMethodTypeInstanceMethod, callStackSymbols); &#125; return [NSMethodSignature signatureWithObjCTypes:"v@:"];&#125;- (void)__t_forwardInvocation:(NSInvocation *)anInvocation &#123; if (![NSObject isCanFowardingFor:[self class]]) &#123; return [self __t_forwardInvocation:anInvocation]; &#125; SEL selector = [anInvocation selector]; if ([self respondsToSelector:selector]) &#123; [anInvocation invokeWithTarget:self]; &#125;&#125;+ (NSMethodSignature *)__t_methodSignatureForSelector:(SEL)aSelector &#123; NSMethodSignature *signature = [self __t_methodSignatureForSelector:aSelector]; if (signature || [self respondsToSelector:aSelector]) &#123; return signature; &#125; if (![NSObject isCanFowardingFor:self]) &#123; return signature; &#125; HandleUnrecognizedSELErrorBlock handleBlock = [NSObject handleUnrecognizedSELErrorBlock]; if (handleBlock != nil) &#123; NSArray &lt;NSString *&gt;*callStackSymbols = @[@"The system version is too low."]; if (@available(iOS 4.0, tvOS 9.0, macOS 10.6, watchOS 2.0, *)) &#123; callStackSymbols = [NSThread callStackSymbols]; &#125; handleBlock([self class], aSelector, UnrecognizedMethodTypeClassMethod, callStackSymbols); &#125; return [NSMethodSignature signatureWithObjCTypes:"v@:"];&#125;+ (void)__t_forwardInvocation:(NSInvocation *)anInvocation &#123; if (![NSObject isCanFowardingFor:self]) &#123; return [self __t_forwardInvocation:anInvocation]; &#125; SEL selector = [anInvocation selector]; if ([self respondsToSelector:selector]) &#123; [anInvocation invokeWithTarget:self]; &#125;&#125;@end 思路： 在+load中替换methodSignatureForSelector:、forwardInvocation:方法（类中和元类中都进行替换） 在__t_methodSignatureForSelector:中： 判断本类是否包含aSelector，如果包含，不进行处理，调用__t_methodSignatureForSelector去执行原函数；如果不包含，走下一步 判断是否允许处理该类型的类，如果不允许，不进行处理，调用__t_methodSignatureForSelector去执行原函数；如果允许，走下一步 获取 handleBlock，调用block将具体信息传出去。 创建 NSMethodSignature 并返回 在__t_forwardInvocation:中 判断是否允许处理该类型的类，如果不允许，不进行处理，调用__t_forwardInvocation去执行原函数；如果允许，走下一步 如果现在自己包含了对应的selector，则执行[anInvocation invokeWithTarget:self];；如果不包含不进行anInvocation的执行 具体详见GitHub代码参考资料： runtime可运行修改版GitHub地址 从 NSObject 的初始化了解 isa NSObject 的 isa 和 Class(ObjC 1.0 和 ObjC 2.0) 深入解析 ObjC 中方法的结构 从源代码看 ObjC 中消息的发送 Type Encoding Apple Doc: load Objective-C +load vs +initialize Objective-C Runtime]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TPreventUnrecognizedSEL使用方法]]></title>
    <url>%2F2017%2F11%2F25%2FiOS%2F17112501.TPreventUnrecognizedSEL%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2Findex%2F</url>
    <content type="text"><![CDATA[TPreventUnrecognizedSEL 项目的 GitHub 地址： https://github.com/tobedefined/TPreventUnrecognizedSELTPreventUnrecognizedSEL 实现思路以及原理：LINK 特点 使用runtime动态添加方法防止产生Unrecognized Selector错误，可以防止因为对象方法和类方法缺失所产生的APP崩溃。 对象方法：*** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;-[TestClass losted:instance:method:]: unrecognized selector sent to instance 0x102c....&#39; 类方法：*** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;+[TestClass losted:class:method:]: unrecognized selector sent to class 0x10000....&#39; 可以获取缺失方法的具体信息，包括： 缺失类方法或对象方法的类名； 所缺失的方法名； 缺失的是对象方法还是类方法。 如何导入源文件源文件中包含两个模块目录： TPUSELNormalForwarding 和 TPUSELFastForwarding；将对应模块目录中的Sources文件夹内部的所有文件拖入项目中即可 ⚠️注意：你只可以使用其中一个模块进行使用，将对应模块目录中的Sources文件内部的所有文件拖入项目中即可，推荐使用TPUSELNormalForwarding，因为系统的某些方法使用了快速转发FastForwarding技术 CocoaPodsCocoaPods是一个Cocoa项目管理器。你可以使用以下命令去安装CocoaPods: 1$ gem install cocoapods 要使用CocoaPods将TPreventUnrecognizedSEL集成到您的Xcode项目中，请在Podfile中加入： 12# pod 'TPreventUnrecognizedSEL' 默认是使用 pod 'TPreventUnrecognizedSEL/NormalForwarding'pod 'TPreventUnrecognizedSEL/NormalForwarding' 或者加入 1pod 'TPreventUnrecognizedSEL/FastForwarding' 然后运行一下命令: 1$ pod install ⚠️注意：你只可以使用其中一个subspec，NormalForwarding 和 FastForwarding 二者只能选其一 ⚠️使用pod &#39;TPreventUnrecognizedSEL&#39;默认是pod &#39;TPreventUnrecognizedSEL/NormalForwarding&#39; CarthageCarthage是一个去中心化的依赖管理器，它构建并提供所使用的库的framework。 你可以使用 Homebrew并运行下面的命令安装Carthage 12$ brew update$ brew install carthage 要将TPreventUnrecognizedSEL集成到使用Carthage的Xcode项目中，请在Cartfile中加入： 1github "tobedefined/TPreventUnrecognizedSEL" 运行carthage update构建framework，并将编译的对应平台的TPUSELNormalForwarding.framework或者TPUSELFastForwarding.framework拖入Xcode项目中。 ⚠️注意：你只可以使用其中一个framework，TPUSELNormalForwarding.framework 和 TPUSELFastForwarding.framework二者选一 使用方法简单使用导入项目之后简单设置对哪些Class进行forwarding即可。 运行错误信息获取导入头文件 模块和语言 \ 导入模块方式 源文件 CocoaPods Carthage TPUSELNormalForwarding &amp; ObjC #import “TPUSELNormalForwarding.h” #import &lt;TPreventUnrecognizedSEL/TPUSELNormalForwarding.h&gt; #import &lt;TPUSELNormalForwarding/TPUSELNormalForwarding.h&gt; TPUSELNormalForwarding &amp; Swift add ⤴ in Bridging-Header import TPreventUnrecognizedSEL import TPUSELNormalForwarding TPUSELFastForwarding &amp; ObjC #import “TPUSELFastForwarding.h” #import &lt;TPreventUnrecognizedSEL/TPUSELFastForwarding.h&gt; #import &lt;TPUSELFastForwarding/TPUSELFastForwarding.h&gt; TPUSELFastForwarding &amp; Swift add ⤴ in Bridging-Header import TPreventUnrecognizedSEL import TPUSELFastForwarding 设置forwarding以及Block在APP的 main.m文件的main()函数中 或者 在APP的didFinishLaunching方法中 加入以下代码可以获得缺失方法的具体信息： TPUSELNormalForwarding1234567891011// 设置不对NSNull及其子类进行处理，默认为NO[NSObject setIgnoreForwardNSNullClass:YES];// 设置不对数组中的类及其子类进行处理（数组中的类名可以为Class类型也可以为NSString类型），默认不忽略任何类[NSObject setIgnoreForwardClassArray:@[@"SomeIgnoreClass1", [SomeIgnoreClass2 Class]]];// 设置仅处理数组中的类及其子类（数组中的类名可以为Class类型也可以为NSString类型），默认处理所有类[NSObject setJustForwardClassArray:@[@"SomeClass1", [SomeClass2 Class]]];// 设置处理之后的回调操作[NSObject setHandleUnrecognizedSELErrorBlock:^(Class _Nonnull __unsafe_unretained cls, SEL _Nonnull selector, UnrecognizedMethodType methodType, NSArray&lt;NSString *&gt; * _Nonnull callStackSymbols) &#123; // 在这里写你要做的事情 // 比如上传到服务器或者打印log等&#125;]; TPUSELFastForwarding1234567// 设置仅处理数组中的类及其子类（数组中的类名可以为Class类型也可以为NSString类型），默认不处理任何类// 设置处理之后的回调操作[NSObject setJustForwardClassArray:@[@"SomeClass1", [SomeClass2 Class]] handleUnrecognizedSELErrorBlock:^(Class _Nonnull __unsafe_unretained cls, SEL _Nonnull selector, UnrecognizedMethodType methodType, NSArray&lt;NSString *&gt; * _Nonnull callStackSymbols) &#123; // 在这里写你要做的事情 // 比如上传到服务器或者打印log等 &#125;]; 一些定义在NSObject+TPUSELFastForwarding.h或者NSObject+TPUSELNormalForwarding.h中有以下定义和方法 123456789typedef NS_ENUM(NSUInteger, UnrecognizedMethodType) &#123; UnrecognizedMethodTypeClassMethod = 1, UnrecognizedMethodTypeInstanceMethod = 2,&#125;;typedef void (^ __nullable HandleUnrecognizedSELErrorBlock)(Class cls, SEL selector, UnrecognizedMethodType methodType, NSArray&lt;NSString *&gt; *callStackSymbols); cls: Class类型；为缺失方法的类或对象的Class，可使用NSStringFromClass(cls)返回类名字符串 selector: SEL类型；为所缺失的方法名，可使用NSStringFromSelector(selector)返回方法名的字符串 methodType: UnrecognizedMethodType类型；为所缺失的方法类型（类方法or对象方法） callStackSymbols: NSArray&lt;NSString *&gt; *类型；为调用栈信息]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 11 适配注意点]]></title>
    <url>%2F2017%2F09%2F27%2FiOS%2F17092701.iOS%2011%20%E9%80%82%E9%85%8D%E6%B3%A8%E6%84%8F%E7%82%B9%2Findex%2F</url>
    <content type="text"><![CDATA[UITableViewsectionHeaderView/sectionFooterView以前直接使用 func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat { } 和 func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -&gt; CGFloat { } 可以直接设置 sectionHeaderView 的 header 高度和 sectionFooterView 高度。 在iOS11中，只写出这两个返回高度的方法不会进行执行，因为这是不规范的写法，只写出了header/footer的高度而没有实现header/footer的view，此时会直接使用预估高度。 解决方法有两种： 添加返回section的headerView/footerView，返回nil 1234567func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat &#123; return someFloat&#125;func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -&gt; UIView? &#123; return nil&#125; 1234567func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -&gt; CGFloat &#123; return someFloat&#125;func tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -&gt; UIView? &#123; return nil&#125; 关闭header/footer预估高度，此时也会执行对应的高度方法 12tableView.estimatedSectionHeaderHeight = 0tableView.estimatedSectionFooterHeight = 0 UIBarButtonItem距离和边界调整UIBarButtonSystemItem.fixedSpace首先UIBarButtonItem设置宽度必须大于0，否则失效。也就是说之前那种使用UIBarButtonSystemItem.fixedSpace类型的item来设置负数宽度，调整距离的方法失效了，不可以在使用负值。如果再需要调整边界，建议使用customView创建item，去调整customView的内部布局 planText类型的Item1234UIBarButtonItem.init(title: &lt;#T##String?#&gt;, style: &lt;#T##UIBarButtonItemStyle#&gt;, target: &lt;#T##Any?#&gt;, action: &lt;#T##Selector?#&gt;) 这种直接使用字符串创建的UIBarButtonItem，在iOS11上点击的效果不再与之前相同（明显的点击变大） 解决方式： 可以将其改成使用customView item.setTitleTextAttributes(attributes, for: UIControlState.highlighted) navgation自定义的titleView自定义的titleView高度不可以超过navigationBar的高度，现在将会被强制截取navigationBar范围内的像素进行显示（类似于设置了layer.masksToBounds） 解决方法，建议将高度超过navigationBar高度的view添加到navigationController的view上进行显示，不设置为titleView UISearchController官方不建议在 iOS11 中直接 present SearchController，建议使用navigationItem的searchController 的方式。 123456if #available(iOS 11, *) &#123; self.navigationItem.searchController = self.searchVC self.searchVC.isActive = false&#125; else &#123; tableView.tableHeaderView = searchVC.searchBar&#125; LargeTitle1234// 设置是否使用大标题self.navigationController?.navigationBar.prefersLargeTitles = true// 设置当前控制器大标题显示样式self.navigationItem.largeTitleDisplayMode = .automatic UIToolbarUIToolBar不可以直接使用addSubview像其内部添加button这种方式了。 以前可以直接添加button而不必需使用UIBarButtonItem。现在直接添加subview会出现无法点击，因为现在toolbar会有一个contentview在顶层，使得下层view事件无法触发。而item也在iOS11中被添加到contentview之中。 解决方法，使用系统的api:bar.setItems([item1, item2,...], animated: true) ViewController和ScrollViewautomaticallyAdjustsScrollViewInsets在iOS11废弃 12@property(nonatomic,assign) BOOL automaticallyAdjustsScrollViewInsets API_DEPRECATED_WITH_REPLACEMENT("Use UIScrollView's contentInsetAdjustmentBehavior instead", ios(7.0,11.0),tvos(7.0,11.0)); // Defaults to YES 在iOS 11中决定tableView的内容与边缘距离的是adjustedContentInset属性，不再是之前的contentInset。 safeAreaiOS11中，系统根据safeArea进行调整view的偏移，safeArea safeAreaInsets: UIView的属性，UIEdgeInsets类型，表示View距离safeArea的边界距离 func safeAreaInsetsDidChange(): UIView方法，会在安全区域被改变时调用。 additionalSafeAreaInsets: UIViewController的属性，UIEdgeInsets类型，扩展系统默认的safeArea （UIEdgeInsets.init(top: t, left: l, bottom: b, right: r)，向内部缩小t/l/b/r的距离） adjustedContentInsetreadonly, UIEdgeInsets adjustedContentInset 表示 contentView.frame.origin 偏移了 scrollview.frame.origin 多少；是系统计算得来的，计算方式由 contentInsetAdjustmentBehavior 决定。 contentInsetAdjustmentBehavior123456public enum UIScrollViewContentInsetAdjustmentBehavior : Int &#123; case automatic // Similar to .scrollableAxes, but for backward compatibility will also adjust the top &amp; bottom contentInset when the scroll view is owned by a view controller with automaticallyAdjustsScrollViewInsets = YES inside a navigation controller, regardless of whether the scroll view is scrollable case scrollableAxes // Edges for scrollable axes are adjusted (i.e., contentSize.width/height &gt; frame.size.width/height or alwaysBounceHorizontal/Vertical = YES) case never // contentInset is not adjusted case always // contentInset is always adjusted by the scroll view's safeAreaInsets&#125; 摘自腾讯bugly技术文档 automatic：如果scrollview在一个automaticallyAdjustsScrollViewInsets = true的controller上，并且这个controller包含在一个navigationController中，这种情况下会设置在top &amp; bottom上 adjustedContentInset = safeAreaInset + contentInset不管是否滚动。其他情况下与UIScrollViewContentInsetAdjustmentScrollableAxes相同 scrollableAxes: 在可滚动方向上adjustedContentInset = safeAreaInset + contentInset，在不可滚动方向上adjustedContentInset = contentInset；依赖于scrollEnabled和alwaysBounceHorizontal/Vertical = YES，scrollEnabled默认为true，所以大多数情况下，计算方式还是adjustedContentInset = safeAreaInset + contentInset never: adjustedContentInset = contentInset always: adjustedContentInset = safeAreaInset + contentInset 当contentInsetAdjustmentBehavior设置为never的时候，adjustedContentInset值不受safeAreaInset值的影响。 一些新的高度 \ 以前的iPhone iPhone X statusBar 20 44 navigationBar 44 44 tabBar 49 83 第三方库MJRefresh因为MJRefresh已经停止维护很久了。目前受影响的是使用automaticallyAdjustsScrollViewInsets的ViewController中的scrollView（tableView），可以使用下面方式解决。 1234567if #available(iOS 11.0, *) &#123; tableView.contentInsetAdjustmentBehavior = .never tableView.contentInset = UIEdgeInsets.init(top: 64, left: 0, bottom: 0, right: 0) tableView.scrollIndicatorInsets = tableView.contentInset&#125; else &#123; self.automaticallyAdjustsScrollViewInsets = true&#125; update 9.28 MJRefresh(Github Link)更新了新版本3.1.13，适配了iOS11和Xcode9，可不再使用上述方法。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS11</tag>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 4 的改变]]></title>
    <url>%2F2017%2F09%2F25%2FiOS%2F17092501.Swift%204%20%E7%9A%84%E6%94%B9%E5%8F%98%2Findex%2F</url>
    <content type="text"><![CDATA[测试均在playground中运行，playground文件下载地址：GitHub 基本语法方面的改变Extension 中可以访问 Class 或者 Struct 的 private 属性 测试代码 1234567891011121314151617181920212223242526272829303132struct PersonStruct &#123; enum Gender: Int &#123; case male case female &#125; var name: String? var gender: Gender? private var age: Int? init(name: String, gender: Gender, age: Int) &#123; self.name = name self.gender = gender self.age = age &#125;&#125;extension PersonStruct &#123; func getPersonAge() -&gt; Int? &#123; return age &#125; mutating func setPersonAge(_ age: Int?) &#123; self.age = age &#125;&#125;var p1 = PersonStruct.init(name: "周星驰", gender: .male, age: 60)p1.getPersonAge()p1.setPersonAge(55)p1.getPersonAge() Protocol 可以与 具体的类型 使用 &amp; 符号进行结合 在ObjC中，如果使用代理可以使用 id&lt;SomeProtocol&gt;类型，也可以使用 SomeClass&lt;SomeProtocol&gt; * 这种比较具体的类型，但是Swift3中没有对应的语法。 现在Swift4中可以使用 SomeClass &amp; SomeProtocol 进行连接成为一个类型。 需要这种语法的原因：一个变量需要是SomeClass 的子类，用以调用 SomeClass 的方法，同时要符合 SomeProtocol 协议，已提供对应的方法 测试代码 12345678910111213141516171819202122232425262728293031protocol SomeProtocol &#123; func shouldGiveMeThisFunc()&#125;class SomeClass &#123; func objectFunction() &#123; print("run object function") &#125;&#125;class SomeChildClass: SomeClass, SomeProtocol &#123; func shouldGiveMeThisFunc() &#123; print("realize protocol function") &#125;&#125;class TestClassAndProtocol &#123; // in swift3 var oldDelegate: SomeClass? var oldDelegate_P: SomeProtocol? &#123; if oldDelegate == nil &#123; return nil &#125; let delegate_P = oldDelegate as? SomeProtocol assert(delegate_P != nil, "oldDelegate must is nil or a SomeClass's object and conforming to SomeProtocol") return delegate_P &#125; // in swift4 var delegate: (SomeClass &amp; SomeProtocol)?&#125; KeyPath语法的改变Swift4 中语法形式 set: obj[keyPath: \Type.valueName] = someValue get: someValue = obj[keyPath: \Type.valueName] Swift 4 与 Swift 3 对比 无需再使用@objc, dynamic等关键字 支持struct和class 具备类型推断 测试代码：Swift 3 1234@objc class PersonClass: NSObject &#123; @objc var name: String? @objc var job: String?&#125; 测试代码：Swift 4 12345678910111213141516171819202122let steven = PersonClass()steven.setValue("Steven Jobs", forKey: #keyPath(PersonClass.name))steven.setValue("Artist, Engineer", forKey: #keyPath(PersonClass.job))let stevenName = steven.value(forKeyPath: #keyPath(PersonClass.name))type(of: stevenName)steven.namesteven.jobvar personStruct = PersonStruct.init(name: "", gender: .male, age: 28)personStruct[keyPath: \PersonStruct.name] = "Taylor Swift"personStruct[keyPath: \PersonStruct.gender] = PersonStruct.Gender.female// 不可以访问私有属性//personStruct[keyPath: \PersonStruct.age] = 19let personStructName = personStruct[keyPath: \PersonStruct.name]type(of: personStructName)personStruct.namepersonStruct.gender 关于字符串characters 之前String中需要使用characters属性调用的一些属性和函数，现在可以直接使用String直接调用，返回类型与以前相同，例如count 123456789let str = "Hello,world"// swift3let count3 = str.characters.counttype(of: count3)// swift4let count4 = str.counttype(of: count4) swift 4 中的 String.CharacterView.IndexDistance 1234567891011extension String : StringProtocol, RangeReplaceableCollection &#123; ........ public typealias IndexDistance = String.CharacterView.IndexDistance ........&#125;extension String.CharacterView : BidirectionalCollection &#123; ..... public typealias IndexDistance = Int .....&#125; Collection 方法 for in, reversed, map, filter, reduce 等可以直接使用 在 Swift 1 中，String 遵循了 CollectionType （Swift3+ 中的 Collection）协议，这意味着您可以对它们执行各种收集操作（比如 forEach()，filter() 等）。 您仍然可以在 Swift 2 ＆ 3 中进行此操作，通过访问 characters 属性，但这很快会导致阅读代码更难。 Swift 4 中字符串再次遵循了 Collection 协议，这意味着你可以简单地将它们视为字符集合。 12345str.forEach &#123; (c) in print(c)&#125;let reversedStr = String.init(str.reversed()) 子串和语法糖 ... 、 ..&lt; swift3 中取子串的方法在swift4中已经废弃（但是也可以用） 123str.substring(to: `String.Index`)str.substring(from: `String.Index`)str.substring(with: `Range&lt;String.Index&gt;`) swift4中截取子串的方法 12345678if let range = str.range(of: ",") &#123; let subString1 = str[..&lt;range.lowerBound] type(of: subString1) let subString2 = str[range.upperBound...]&#125;let index = String.Index.init(encodedOffset: 3)let substr = str[...index] 关于swift 4 中的 SubSequence 和 Substring , 部分定义如下 1234567891011121314151617181920212223extension String : StringProtocol, RangeReplaceableCollection &#123; ...... public typealias SubSequence = Substring ......&#125;public struct Substring : StringProtocol &#123; ..... public typealias SubSequence = Substring .....&#125;extension String.UnicodeScalarView &#123; ...... public typealias SubSequence = Substring.UnicodeScalarView ......&#125;extension Substring.UTF8View : BidirectionalCollection &#123; ..... public typealias SubSequence = Substring.UTF8View .....&#125; 多行字符串 类似于Python中的多行字符串一样。 内部也可以使用 \( someValue ) 调用变量 1234567891011121314151617181920212223let multiLineString ="""// Some Codeextension String : StringProtocol, RangeReplaceableCollection &#123; /// A type that represents the number of steps between two `String.Index` /// values, where one value is reachable from the other. /// /// In Swift, *reachability* refers to the ability to produce one value from /// the other through zero or more applications of `index(after:)`. public typealias IndexDistance = String.CharacterView.IndexDistance /// A sequence that represents a contiguous subrange of the collection's /// elements. public typealias SubSequence = Substring .....&#125;===========Get Value:\(str)==========="""print(multiLineString) Codable Codabel定义 1234567891011121314151617181920212223242526272829/// A type that can encode itself to an external representation.public protocol Encodable &#123; /// Encodes this value into the given encoder. /// /// If the value fails to encode anything, `encoder` will encode an empty /// keyed container in its place. /// /// This function throws an error if any values are invalid for the given /// encoder's format. /// /// - Parameter encoder: The encoder to write data to. public func encode(to encoder: Encoder) throws&#125;/// A type that can decode itself from an external representation.public protocol Decodable &#123; /// Creates a new instance by decoding from the given decoder. /// /// This initializer throws an error if reading from the decoder fails, or /// if the data read is corrupted or otherwise invalid. /// /// - Parameter decoder: The decoder to read data from. public init(from decoder: Decoder) throws&#125;/// A type that can convert itself into and out of an external representation.public typealias Codable = Decodable &amp; Encodable 下面测试代码的辅助函数 123456789101112131415161718enum JSONDataError: Error &#123; case pathError&#125;func getJSONData(forResource resource: String?, ofType type: String?) throws -&gt; Data &#123; guard let jsonFile = Bundle.main.path(forResource: resource, ofType: type) else &#123; throw JSONDataError.pathError &#125; let jsonURL = URL.init(fileURLWithPath: jsonFile) return try Data.init(contentsOf: jsonURL)&#125;let decoder = JSONDecoder()decoder.dateDecodingStrategy = .iso8601let encoder = JSONEncoder()encoder.outputFormatting = .prettyPrintedencoder.dateEncodingStrategy = .iso8601 辅助文件dog.json 123456789101112131415161718[ &#123; "name": "Dog_1", "age": 5, "gender": 0, "nikeName": "Nikee" &#125;, &#123; "name": "Dog_2", "age": 3, "gender": 1 &#125;, &#123; "name": "Dog_3", "age": 6, "gender": 2 &#125;] 辅助文件human.json 1234567891011121314151617181920212223&#123; "userName": "Steven Jobs", "userAge": 50, "birthday": "1967-06-21T15:29:32Z", "dogs": [ &#123; "name": "HDog_1", "age": 15, "gender": 0, "nikeName": "Nikee" &#125;, &#123; "name": "HDog_2", "age": 13, "gender": 1 &#125;, &#123; "name": "HDog_3", "age": 16, "gender": 2 &#125; ]&#125; 基本用法123456789101112131415161718192021222324252627282930313233343536373839struct Dog: Codable &#123; enum Gender: Int, Codable &#123; case unknow = 0 case male = 1 case female = 2 &#125; var name: String var age: Int var gender: Gender // 可能存在也可能不存在的值必须使用Optional var nikeName: String? = "default" // 解析json static func decodeDogArray(forResource resource: String) -&gt; [Dog]? &#123; guard let dogJsonData = try? getJSONData(forResource: resource, ofType: "json"), let dogArr = try? decoder.decode([Dog].self, from: dogJsonData) else &#123; print("Get JSON Data or Decoder Error") return nil &#125; return dogArr &#125; // 序列化为json static func encodeDogArray(_ dogArr: [Dog]) throws -&gt; Data &#123; return try encoder.encode(dogArr) &#125;&#125;// 示例if let dogArr = Dog.decodeDogArray(forResource: "dog") &#123; for dog in dogArr &#123; print("\(dog.name) \t \(dog.age) \t \(dog.gender) \t \(dog.nikeName ?? "nil")") &#125; if let data = try? Dog.encodeDogArray(dogArr) &#123; print(String(data: data, encoding: .utf8) ?? "Error") &#125;&#125; 嵌套的Codable和自定义Key123456789101112131415161718192021222324252627282930313233343536373839404142class Human: Codable &#123; var name: String var age: Int var dogs: [Dog] var birthday: Date enum CodingKeys: String, CodingKey &#123; case name = "userName" case age = "userAge" case dogs case birthday &#125; // 解析 json class func decode(forResource resource: String) -&gt; Human? &#123; guard let humanJsonData = try? getJSONData(forResource: resource, ofType: "json"), let human = try? decoder.decode(Human.self, from: humanJsonData) else &#123; print("Get JSON Data or Decoder Error") return nil &#125; return human &#125; // 序列化为json func encode() throws -&gt; Data &#123; return try encoder.encode(self) &#125;&#125;// 示例if let human = Human.decode(forResource: "human") &#123; print(human.name) print(human.age) print(human.birthday) for dog in (human.dogs) &#123; print("\(dog.name) \t \(dog.age) \t \(dog.gender) \t \(dog.nikeName ?? "nil")") &#125; if let data = try? human.encode() &#123; print(String(data: data, encoding: .utf8) ?? "Error") &#125;&#125; 特殊数据类型的处理 可以去配置encoder和decoder对应的属性用来解析这些数据类型，下面是对应的属性，皆为枚举类型，按自己需要进行配置 Date encoder.dateEncodingStrategy JSONEncoder.DateEncodingStrategy 12345678910/// The strategy to use for encoding `Date` values.public enum DateEncodingStrategy &#123; case deferredToDate /// Defer to `Date` for choosing an encoding. This is the default strategy. case secondsSince1970 /// Encode the `Date` as a UNIX timestamp (as a JSON number). case millisecondsSince1970 /// Encode the `Date` as UNIX millisecond timestamp (as a JSON number). case iso8601 /// Encode the `Date` as an ISO-8601-formatted string (in RFC 3339 format). case formatted(DateFormatter) /// Encode the `Date` as a string formatted by the given formatter. case custom((Date, Encoder) throws -&gt; Swift.Void) /// Encode the `Date` as a custom value encoded by the given closure. /// If the closure fails to encode a value into the given encoder, the encoder will encode an empty automatic container in its place.&#125; decoder.dateDecodingStrategy JSONDecoder.DateDecodingStrategy 123456789/// The strategy to use for decoding `Date` values.public enum DateDecodingStrategy &#123; case deferredToDate /// Defer to `Date` for decoding. This is the default strategy. case secondsSince1970 /// Decode the `Date` as a UNIX timestamp from a JSON number. case millisecondsSince1970 /// Decode the `Date` as UNIX millisecond timestamp from a JSON number. case iso8601 /// Decode the `Date` as an ISO-8601-formatted string (in RFC 3339 format). case formatted(DateFormatter) /// Decode the `Date` as a string parsed by the given formatter. case custom((Decoder) throws -&gt; Date) /// Decode the `Date` as a custom value decoded by the given closure.&#125; Data encoder.dataEncodingStrategy JSONEncoder.DataEncodingStrategy 1234567/// The strategy to use for encoding `Data` values.public enum DataEncodingStrategy &#123; case deferredToData /// Defer to `Data` for choosing an encoding. case base64 /// Encoded the `Data` as a Base64-encoded string. This is the default strategy. case custom((Data, Encoder) throws -&gt; Swift.Void) /// Encode the `Data` as a custom value encoded by the given closure. /// If the closure fails to encode a value into the given encoder, the encoder will encode an empty automatic container in its place.&#125; decoder.dataDecodingStrategy JSONDecoder.DataDecodingStrategy 123456/// The strategy to use for decoding `Data` values.public enum DataDecodingStrategy &#123; case deferredToData /// Defer to `Data` for decoding. case base64 /// Decode the `Data` from a Base64-encoded string. This is the default strategy. case custom((Decoder) throws -&gt; Data) /// Decode the `Data` as a custom value decoded by the given closure.&#125; Floatencoder.nonConformingFloatEncodingStrategy JSONEncoder.NonConformingFloatEncodingStrategy 1234567/// The strategy to use for non-JSON-conforming floating-point values (IEEE 754 infinity and NaN).public enum NonConformingFloatEncodingStrategy &#123; case `throw` /// Throw upon encountering non-conforming values. This is the default strategy. case convertToString(positiveInfinity: String, negativeInfinity: String, nan: String) /// Encode the values using the given representation strings.&#125; decoder.nonConformingFloatDecodingStrategy JSONDecoder.NonConformingFloatDecodingStrategy 1234567/// The strategy to use for non-JSON-conforming floating-point values (IEEE 754 infinity and NaN).public enum NonConformingFloatDecodingStrategy &#123; case `throw` /// Throw upon encountering non-conforming values. This is the default strategy. case convertFromString(positiveInfinity: String, negativeInfinity: String, nan: String) /// Decode the values from the given representation strings.&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD]]></title>
    <url>%2F2017%2F08%2F04%2FiOS%2F17080401.GCD%2Findex%2F</url>
    <content type="text"><![CDATA[基本的GCD使用 同步异步 \ 队列 全局并行队列 手动创建的串行队列 主队列 同步(sync) 没有开启新线程串行执行任务 没有开启新线程串行执行任务 死锁 异步(async) 有开启新线程并行执行任务 有开启新线程串行执行任务 没有开启新线程串行执行任务 串行队列创建串行队列 在使用GCD的时候先写dispatch 在C语言中，定义对象通常是以_t或者Ref结尾的 特点：依次顺序执行 在非ARC中需要释放队列：dispatch_release(q) DISPATCH_QUEUE_SERIAL 串行 （宏定义了：#define DISPATCH_QUEUE_SERIAL NULL） DISPATCH_QUEUE_CONCURRENT 并行 12dispatch_queue_t q = dispatch_queue_create("queueName", DISPATCH_QUEUE_SERIAL);// 等同于dispatch_queue_t q = dispatch_queue_create("queueName", NULL); 创建任务同步任务不会开启新的线程 dispatch_sync(dispatch_queue_t queue, DISPATCH_NOESCAPE dispatch_block_t block);串行队列中，同步任务在主线程工作，所有任务顺序执行 12345for (int i = 0; i &lt; 10; i++) &#123; dispatch_sync(q, ^&#123; NSLog(@"%zd %@",i , [NSThread currentThread]); &#125;);&#125; 异步任务只能开一条线程 dispatch_async(dispatch_queue_t queue, dispatch_block_t block); 串行队列中，异步任务最多只能开一条线程，所有任务顺序执行 串行队列，异步任务，在多线程中，是斯坦福大学最推荐的一种多线程方式 优点：将任务放在其他线程中工作，每个任务顺序执行 缺点：并发能力不强，最多只能使用一条线程 12345for (int i = 0; i &lt; 10; i++) &#123; dispatch_async(q, ^&#123; NSLog(@"%zd %@",i , [NSThread currentThread]); &#125;);&#125; 并行队列创建并行队列 dispatch_queue_t q = dispatch_queue_create(&quot;queueName&quot;, DISPATCH_QUEUE_CONCURRENT); 创建任务同步任务不会开启新的线程 dispatch_sync(dispatch_queue_t queue, DISPATCH_NOESCAPE dispatch_block_t block); 在实际开发中，同步任务可以保证执行完成之后，才让后续的异步任务开始执行，用于控制任务之间的先后顺序 123456NSLog(@"================2.1同步任务================");for (int i = 0; i &lt; 10; i++) &#123; dispatch_sync(q, ^&#123; NSLog(@"%zd %@",i , [NSThread currentThread]); &#125;);&#125; 异步任务会在多条线程上工作，具体开多少条线程，由系统决定 dispatch_async(dispatch_queue_t queue, dispatch_block_t block); 仍然是按照任务添加到队列中的顺序被调度，知识执行先后可能会有差异 能够将耗时的操作放到子线程中工作 与串行队列相比，开启多条线程（系统决定），并发性能更好，但是执行的先后顺序不固定 12345for (int i = 0; i &lt; 10; i++) &#123; dispatch_async(q, ^&#123; NSLog(@"%zd %@",i , [NSThread currentThread]); &#125;);&#125; 全局并行（并发）队列（使用的更为普遍）与自定义并行队列的区别就是名字不同，其他完全相同 获取全局队列与自定义并行队列的区别就是名字不同，其他相同 dispatch_queue_t q = dispatch_get_global_queue(long identifier, unsigned long flags); 关于dispatch_queue_priority_t 1234#define DISPATCH_QUEUE_PRIORITY_HIGH 2#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0#define DISPATCH_QUEUE_PRIORITY_LOW (-2)#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN 12dispatch_queue_t q = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);//等同于dispatch_queue_t q = dispatch_get_global_queue(0, 0); 创建任务同步任务12345for (int i = 0; i &lt; 10; i++) &#123; dispatch_sync(q, ^&#123; NSLog(@"%zd %@",i , [NSThread currentThread]); &#125;);&#125; 异步任务12345for (int i = 0; i &lt; 10; i++) &#123; dispatch_async(q, ^&#123; NSLog(@"%zd %@",i , [NSThread currentThread]); &#125;);&#125; 主队列专门在主线程上工作的队列，不能开线程 获取主线程1dispatch_queue_t q = dispatch_get_main_queue(); 创建任务同步任务注意：不要使用同步任务，会发生死锁 12345for (int i = 0; i &lt; 10; i++) &#123; dispatch_sync(q, ^&#123; NSLog(@"%zd %@",i , [NSThread currentThread]); &#125;);&#125; 异步任务,在主线程上依次顺序执行12345for (int i = 0; i &lt; 10; i++) &#123; dispatch_async(q, ^&#123; NSLog(@"%zd %@",i , [NSThread currentThread]); &#125;);&#125; GCD多线程同步等问题串行队列中可以将一个任务放到另一个任务完成之后继续，这里讨论并行队列同步问题。 dispatch_barrier_async dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block); dispatch_barrier_async必定在前面创建的任务运行完之后才会调用，并且其之后的任务必定在其运行完之后才会运行，与dispatch_barrier_async代码位置有关。 12345678910111213141516171819202122232425262728dispatch_queue_t concurrentQueue = dispatch_queue_create("tbd.tech", DISPATCH_QUEUE_CONCURRENT);dispatch_async(concurrentQueue, ^()&#123; NSLog(@"dispatch-1");&#125;);dispatch_async(concurrentQueue, ^()&#123; NSLog(@"dispatch-2");&#125;);dispatch_async(concurrentQueue, ^()&#123; NSLog(@"dispatch-3");&#125;);dispatch_async(concurrentQueue, ^()&#123; NSLog(@"dispatch-4");&#125;);dispatch_async(concurrentQueue, ^()&#123; NSLog(@"dispatch-5");&#125;);// dispatch_barrier_asyncdispatch_barrier_async(concurrentQueue, ^()&#123; NSLog(@"dispatch-barrier");&#125;);dispatch_async(concurrentQueue, ^()&#123; NSLog(@"dispatch-a");&#125;);dispatch_async(concurrentQueue, ^()&#123; NSLog(@"dispatch-b");&#125;); dispatch_group_async &amp; dispatch_group_notify1234567dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); dispatch_group_async是创建GCD的group操作。在dispatchGroup中所有任务运行完之后，才会调用dispatch_group_notify，与代码的顺序无关。 123456789101112131415161718192021222324252627dispatch_queue_t dispatchQueue = dispatch_queue_create("tbd.tech", DISPATCH_QUEUE_CONCURRENT);dispatch_group_t dispatchGroup = dispatch_group_create();dispatch_group_async(dispatchGroup, dispatchQueue, ^()&#123; NSLog(@"dispatch-1 : %@", [NSThread currentThread]);&#125;);dispatch_group_async(dispatchGroup, dispatchQueue, ^()&#123; NSLog(@"dispatch-2 : %@", [NSThread currentThread]);&#125;);// dispatch_group_notifydispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^()&#123; NSLog(@"Success : %@", [NSThread currentThread]);&#125;);dispatch_group_async(dispatchGroup, dispatchQueue, ^()&#123; NSLog(@"dispatch-3 : %@", [NSThread currentThread]);&#125;);dispatch_group_async(dispatchGroup, dispatchQueue, ^()&#123; NSLog(@"dispatch-4 : %@", [NSThread currentThread]);&#125;);dispatch_group_async(dispatchGroup, dispatchQueue, ^()&#123; NSLog(@"dispatch-5 : %@", [NSThread currentThread]);&#125;);dispatch_group_async(dispatchGroup, dispatchQueue, ^()&#123; NSLog(@"dispatch-6 : %@", [NSThread currentThread]);&#125;); dispatch_apply12dispatch_apply(size_t iterations, dispatch_queue_t queue, DISPATCH_NOESCAPE void (^block)(size_t)); dispathc_apply 是 dispatch_sync 和dispatch_group的关联API.它以指定的次数将指定的Block加入到指定的队列中。并等待队列中操作全部完成. 12345678910111213NSArray *array = @[@"1", @"2", @"3", @"4", @"5", @"6", @"7", @"8", @"9", @"10", @"11",@"12",@"13",@"14",@"15",@"16",@"17",@"18",@"19",@"20"];dispatch_queue_t queue = dispatch_get_global_queue(0, 0);dispatch_async(queue, ^&#123; dispatch_apply(array.count, queue, ^(size_t index)&#123; //字典转模型 NSLog(@"%@", array[index]); &#125;); dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@"处理完成，回到主线程。"); &#125;);&#125;); dispatch_semaphore &amp; @synchronized要防止对同一数据产生写冲突，就需要设置加锁(@synchronized)或者采用信号量(dispatch_semaphore)的方式。 dispatch_semaphore123456// 创建dispatch_semaphore_t dispatch_semaphore_create(long value);// wait (-1)long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);// signal (+1)long dispatch_semaphore_signal(dispatch_semaphore_t dsema); 12345678910111213141516NSMutableArray *array = [NSMutableArray array];dispatch_group_t group = dispatch_group_create();dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);NSDate *date = [[NSDate alloc] init];for (int index = 0; index &lt; 100000; ++index) &#123; dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); [array addObject:[NSNumber numberWithInt:index]]; dispatch_semaphore_signal(semaphore); &#125;);&#125;dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@"%lu", (unsigned long)array.count); double time = [date timeIntervalSinceNow]; NSLog(@"time %f", time);&#125;); @synchronized 试验了一下性能不如dispatch_semaphore 123456789101112131415NSMutableArray *array = [NSMutableArray array];dispatch_group_t group = dispatch_group_create();NSDate *date = [[NSDate alloc] init];for (int index = 0; index &lt; 100000; ++index) &#123; dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^&#123; @synchronized(array) &#123; [array addObject:[NSNumber numberWithInt:index]]; &#125; &#125;);&#125;dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@"%lu", (unsigned long)array.count); double time = [date timeIntervalSinceNow]; NSLog(@"time %f", time);&#125;);]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TWebKit]]></title>
    <url>%2F2017%2F07%2F30%2FiOS%2F17073001.TWebKit%2Findex%2F</url>
    <content type="text"><![CDATA[GitHub 地址： https://github.com/tobedefined/TWebKit 很久之前写的一个很简单的库，最近整理了一下发到github了 特点 兼容Objective-C和swift TWebView 支持自动根据系统版本选择使用UIWebView还是WKWebView加载网页 使用方法简单，与UIWebView的使用方法极其类似，简化WKWebView的使用 双代理模式，支持使用通用的代理commonDelegate（通用代理的类建议使用singleton单例模式），也支持同时设置普通的代理delegate 默认情况下普通代理delegate里实现的方法会优先于通用代理commonDelegate里实现的同名方法； 在普通代理delegate中实现某个方法的情况下不会去调用通用代理commonDelegate中的同名方法。（如果需要可以在普通代理delegate的该方法中使用[webView.commonDelegate someFunc..]主动调用通用代理commonDelegate的该方法） 支持显示ProgressView，UIWebView的Progress使用了NJKWebViewProgress中的部分代码进行模拟进度，支持配置ProgressView的颜色 支持配置是否允许滑动返回(canScrollBack) 支持配置是否可以放大缩小网页(canScrollChangeSize) 支持配置是否屏蔽长按链接显示ActionSheet和MenuController(blockTouchCallout) 支持配置是否屏蔽链接的3DTouch预览(block3DTouch) TWebViewController TWebViewController返回键为后退网页，后退到首个网页则popViewController TWebViewController点击返回键后退网页则会出现关闭controller的按钮 TWebViewController在Debug包中包含清空缓存和输入网址按钮(自动保存最后一次手动输入的网址)，在Release包中自动屏蔽。 TWebViewDelegate 全是@optional的代理方法，更容易使用 导入项目源文件如果你的项目支持iOS 7以及之前版本，请下载Source目录中的所有文件和TWebKit.bundle，之后将他们放入你的项目中，无须其他配置即可使用。 如果你的项目仅支持iOS 8+，建议使用CocoaPods或者Carthage方式。 CocoaPodsCocoaPods是一个Cocoa项目管理器。你可以使用以下命令去安装CocoaPods: 1$ gem install cocoapods 要使用CocoaPods将TWebKit集成到您的Xcode项目中，请在Podfile中加入： 1234567source 'https://github.com/CocoaPods/Specs.git'platform :ios, '6.0'use_frameworks!target '&lt;Your Target Name&gt;' do pod 'TWebKit'end 然后运行一下命令: 1$ pod install CarthageCarthage是一个去中心化的依赖管理器，它构建并提供所使用的库的framework。 你可以使用 Homebrew并运行下面的命令安装Carthage 12$ brew update$ brew install carthage 要将TWebKit集成到使用Carthage的Xcode项目中，请在Cartfile中加入： 1github "tobedefined/TWebKit" 运行carthage update构建framework，并将编译的TWebKit.framework拖入Xcode项目中。 使用方法 swift 在swift的&lt;Your Target Name&gt;-Bridging-Header.h中加入 1#import &lt;TWebKit/TWebKit.h&gt; Objective-C 1#import &lt;TWebKit/TWebKit.h&gt; 你可以在demo中看具体的使用方法，下面是具体的介绍 TWebView大部分参数和方法与UIWebView的参数相同，使用方式也相同，下面介绍一些不同的参数和方法。 property delegate：id &lt;TWebViewDelegate&gt;，代理，遵守TWebViewDelegate协议的任何对象，若设置，则其实现的方法优先级高于commonDelegate中的方法 commonDelegate：id &lt;TWebViewDelegate&gt;，通用代理，遵守TWebViewDelegate协议的任何对象，建议使用singleton的对象作为通用代理 contentWebView: UIView，如果 &lt; iOS 8.0，返回 TWebView 中的 UIWebView；如果 ≥ iOS 8.0，返回 TWebView 中的 WKWebView uiWebView: UIWebView，如果 &lt; iOS 8.0，返回 TWebView 中的 UIWebView；如果 ≥ iOS 8.0，返回 nil wkWebView: WKWebView，如果 &lt; iOS 8.0，返回 nil；如果 ≥ iOS 8.0，返回 TWebView 中的 WKWebView scrollView: UIScrollView，网页的 scrollView ， readonly ，返回UIWebView 或者 WKWebView 的 scrollView showProgress：BOOL，getter=isShowProgress，是否显示进度条 progressTintColor：UIColor，进度条颜色 progressViewHeight: CGFloat, 设置进度条的高度 canSelectContent：BOOL，设置是否可以长按选择网页中的内容 canScrollChangeSize：BOOL，是否可以拖动改变网页大小 blockTouchCallout：BOOL，是否屏蔽长按链接出现actionSheet和menuController canScrollBack：BOOL，iOS8+支持，是否可以滑动返回上一个网页 block3DTouch：BOOL，iOS9+支持，是否屏蔽3DTouch预览链接 confirmText：NSString，网页弹出框的确定按钮文字 cancelText：NSString，网页弹出框的取消按钮文字 loadingDefaultTitle：NSString，网页加载中默认返回的title文字 successDefaultTitle：NSString，网页加载成功默认返回的title文字 failedDefaultTitle：NSString，网页加载失败默认返回的title文字 function - (instancetype)init 创建一个默认的TWebViewConfig对象，并调用- (instancetype)initWithConfig:(TWebViewConfig *)config - (instancetype)initWithConfig:(TWebViewConfig *)config 使用config中的参数，进行初始化创建TWebView - (void)clearCache 清空cache和cookie - (void)resetCookieForceOverride:(BOOL)forceOverride 取出NSHTTPCookieStorage中的cookies设置TWebView的cookie，forceOverride参数控制是否强制使用NSHTTPCookieStorage中的cookie值重设TWebView之前存在的同名的cookie - (void)getDocumentTitle:(void (^)(NSString * _Nullable))completion 取出网页的title放入block completion，使用JavaScript获得网页HTML中的document.title + (nullable NSString *)getJavascriptStringWithFunctionName:(NSString *)function data:(id)data 类方法提供拼接JavaScript函数功能，function参数为要访问的JavaScript的方法名(不需要添加括号)，data参数可以为JSON Object或者为普通的NSString，会自动进行转换拼接；返回拼接后的函数调用字符串。 - (void)runJavascript:(NSString *)js completion:(void (^__nullable)(id obj, NSError *error))completion 运行JavaScript函数，与网页进行交互，js参数为运行的JavaScript代码，completion参数为回调。 TWebViewConfig为了将配置参数更加清晰，所以添加了这个类，参数与TWebView的各个配置参数对应，你可以使用TWebViewConfig创建配置，然后使用配置来创建TWebView；也可以直接创建TWebView，然后对创建的对象进行参数赋值。 TWebViewConfig参数 -&gt; TWebView参数 webViewCommonDelegate -&gt; commonDelegate webViewDelegate -&gt; delegate forceOverrideCookie -&gt; forceOverrideCookie showProgressView -&gt; showProgress progressTintColor -&gt; progressTintColor progressViewHeight -&gt; progressViewHeight canSelectContent -&gt; canSelectContent canScrollChangeSize -&gt; canScrollChangeSize blockTouchCallout -&gt; blockTouchCallout canScrollBack -&gt; canScrollBack block3DTouch -&gt; block3DTouch confirmText -&gt; confirmText cancelText -&gt; cancelText loadingDefaultTitle -&gt; loadingDefaultTitle successDefaultTitle -&gt; successDefaultTitle failedDefaultTitle -&gt; failedDefaultTitle TWebViewDelegate1234567891011121314151617181920212223242526272829303132333435363738394041424344typedef NS_ENUM(NSUInteger, TWebViewLoadStatus) &#123; TWebViewLoadStatusIsLoading = 1, TWebViewLoadStatusSuccess = 2, TWebViewLoadStatusFailed = 3,&#125;;@protocol TWebViewDelegate &lt;NSObject&gt;@optional// 是否可以加载网页- (BOOL)webView:(TWebView *)webView shouldStartLoadRequest:(NSURLRequest *)request;// 开始加载网页- (void)webView:(TWebView *)webView didStartLoadRequest:(NSURLRequest *)request;// 加载网页成功- (void)webView:(TWebView *)webView didFinishLoadRequest:(NSURLRequest *)request;// 加载网页失败- (void)webView:(TWebView *)webView didFailedLoadRequest:(NSURLRequest *)request withError:(NSError *)error;// 当前状态：status，当前默认使用的title，// 可以选择使用根据状态判断设定ViewController的title。或者可以将title字段设为ViewController的title。// TWebViewLoadStatusIsLoading =&gt; 返回TWebView的loadingDefaultTitle// TWebViewLoadStatusSuccess =&gt; 获取网页的title，如果不为空返回；为空返回TWebView的successDefaultTitle// TWebViewLoadStatusFailed =&gt; 返回TWebView的failedDefaultTitle- (void)webView:(TWebView *)webView loadStatus:(TWebViewLoadStatus)status title:(NSString *)title;#pragma mark - 3D Touch Peek &amp; Pop; iOS 10+ available// 设置是否允许url进行预览;// 如果返回NO，下面的两个方法将不会执行// 如果返回YES，下面的两个方法将会在用户用力按压时候执行- (BOOL)webView:(TWebView *)webView shouldPreviewURL:(nullable NSURL *)url API_AVAILABLE(ios(10.0));// 如果返回NO, 将会在Safari中预览链接// 如果你不想预览这个url, 请在 "- webView:shouldPreviewURL:" 方法中返回NO// 参数 "actions" 是iOS默认支持的actions- (nullable UIViewController *)webView:(TWebView *)webView previewingViewControllerForURL:(nullable NSURL *)url defaultActions:(NSArray&lt;id &lt;WKPreviewActionItem&gt;&gt; *)actions API_AVAILABLE(ios(10.0));// 打开预览的ViewController- (void)webView:(TWebView *)webView commitPreviewingURL:(nullable NSURL *)url controller:(UIViewController *)controller API_AVAILABLE(ios(10.0));@end TWebViewController 是否显示清除缓存和输入网址的按钮为自动控制（Debug显示，Release不显示），无需配置 property webView：TWebView，TWebViewController中的TWebView对象，你可以修改一些属性符合你的配置要求。 navTitle：NSString，默认的navTitle，如果设置，则覆盖- (void)webView:(TWebView *)webView loadStatus:(TWebViewLoadStatus)status title:(NSString *)title回调，始终显示navTitle。 backImage：UIImage，默认使用TWebKit.bundle中的back.png，可以自定义设置返回按钮。 function - (instancetype)initWithConfig:(TWebViewConfig *)config 根据TWebViewConfig配置来创建TWebViewController。 - (void)loadURLFromString:(NSString *)urlString 加载网址urlString - (void)loadURLAndAutoConversionFromString:(NSString *)urlString 加载网址urlString，会对urlString进行转码判断等操作，具体详见NSString *trueURLString(NSString *urlString) - (void)resetWebViewCookieForceOverride:(BOOL)forceOverride 调用TWebView的- (void)resetCookieForceOverride:(BOOL)forceOverride方法，重设cookie]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 中的 inout & UnsafeMutablePointer 指针]]></title>
    <url>%2F2017%2F07%2F21%2FiOS%2F17072101.Swift%20%E4%B8%AD%E7%9A%84%20inout%20%26%20UnsafeMutablePointer%20%E6%8C%87%E9%92%88%2Findex%2F</url>
    <content type="text"><![CDATA[问题的产生最近在做一个需求，其中有一个场景是一个对象从外部传入一个默认的 Array，对象根据一些其他的配置自动对 Array 进行一些处理，同时使默认的 Array 也作出增减操作。因为在ObjC中NSMutableArray是引用类型，所以这就很简单了，不需要做什么特殊处理。但是在Swift中Array是值类型（struct），定义如下：1234public struct Array&lt;Element&gt; : RandomAccessCollection, MutableCollection &#123; ...... ......&#125; 这时候如果使用 ObjC 的思路去做必定出错，因为 Struct 值类型的传递是复制值的操作，而不是传递地址。 解决方法inout很简单的第一时间想到的是函数的传递参数使用inout标记（相信很多人也会这么做）就像这样： 123456789101112131415var inoutColors: [UIColor] = [UIColor.red]class TestInout &#123; var colors: [UIColor]? func addElement(colors: inout [UIColor]) &#123; let element = UIColor.orange colors.append(element) self.colors = colors &#125;&#125;let tio = TestInout()tio.addElement(colors: &amp;inoutColors) 测试一下： 这时候感觉已经完美解决了？ 但是此时如果我们再另外一个函数中再去操作对象中的数组colors，并不会引起原数组inoutColors的改变。 输出如下图： - inout 是在函数参数传递的时候复制了一份值传进来- 在函数内部做出改变的时候，原数据并不会改变- 在函数运行的时候会将函数内部改变之后的值复制出去将传入的参数原数据进行替换 inout 参数在函数调用的时候传递的是该值的地址, 但是在函数体内使用的时候, 使用的是对应的真实值, 无法获取传递的地址, 将其赋值给别的变量也是一份对应值类型的拷贝. 在上面的例子中的tio.colors是改变之后的colors的一份复制，直接改变tio.colors并不会引起原数据inoutColors的改变。 可以测试一下，如下图： 可以发现inout的局限性，他只能在inout的函数作用范围内改变传入的参数才可以改变原来的数据； 一旦超出inout的函数的范围，你将无法改变传入的数据； 除非你直接更改原数据并且使用原数据，但是如果你写的是一个框架，并不知道原数据从哪里来到哪里去怎么办？ 或许可以取一个折中的办法：在一个函数中对传入的Array做完初始化处理，之后就只进行读（使用）而不再进行写。 但是如果如何彻底的解决这种问题呢？ UnsafeMutablePointer&lt;Pointee&gt;如何像ObjC中那样在Swift中使用Array？ 首先重新描述下具体的原因： 主要的原因还是因为 Swift 中的值类型与引用类型在内存方式不同, 不能用 ObjC 中对 NSArray 的看法去看 Swift 中的 Array ObjC 中的 NSMutableArray 是对象，传递参数是传递对应 array 的地址（指针），对指针进行操作，会使所有的使用该内存的数据都发生改变 Swift 中的 Array 是值类型，传递的参数是一份拷贝（类似于ObjC中的Copy, 但是原理不同），传递后的内存空间与原来数据的内存空间并不是一块内存，之后的改变与原来的数据都没有任何关系。 那么我们可不可以在Swift中传递一个指针过去呢？很多人可能觉得Swift没有指针，毕竟都看不到*了… 但是Swift可以与C的的 API 进行无缝混合，这时候想到了UnsafeMutablePointer&lt;Pointee&gt; (Pointee是泛型)，定义如下: 1234public struct UnsafeMutablePointer&lt;Pointee&gt; : Strideable, Hashable &#123; ... ...&#125; 又是struct？不要怕，这个是存储Pointee对象的地址的struct，使用方法如下： 123456789101112131415161718var sourceColors: [UIColor] = [UIColor.red]class TestUnsafeMutablePointer &#123; var colorsPoint: UnsafeMutablePointer&lt;[UIColor]&gt;? init(colorsPoint: UnsafeMutablePointer&lt;[UIColor]&gt;?) &#123; self.colorsPoint = colorsPoint &#125; func addElement() &#123; self.colorsPoint?.pointee.append(UIColor.orange) &#125;&#125;let t = TestUnsafeMutablePointer.init(colorsPoint: &amp;sourceColors)t.addElement()t.colorsPoint?.pointee.append(UIColor.brown) 测试一下： 使用引用符号获取对应的变量的地址传给 UnsafeMutablePointer&lt;[UIColor]&gt;类型的变量然后进行使用，pointee有时候需要转换，&amp;后面如果很长需要加括号，如： UnsafeMutablePointer&lt;SomeType&gt;(&amp;(someObject.someAttribute)) 另外一些多线程操作也可以使用 UnsafeMutablePointer&lt;SomeType&gt; 这种方式会更加安全稳定。 具体的关于 swift 中指针的用法可以参考喵神的这篇文章：Swift 中的指针使用(喵神这篇文章应该是基于 swift 1，后续 swift 版本中有一些变化)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TSegmentedView]]></title>
    <url>%2F2017%2F07%2F18%2FiOS%2F17071801.TSegmentedView%2Findex%2F</url>
    <content type="text"><![CDATA[GitHub 地址： https://github.com/tobedefined/TSegmentedView 特点 完美兼容Objective-C和swift 支持用户滑动和点击tab 支持滑动返回(在任意的tab) 支持Frame和Autolayout自动布局，你可以使用Masonry/SnapKit/NSLayoutConstraint去布局view 支持放入普通的UIView（以及非滑动的UIView子类View），UIScrollView，UITableView 支持的UITableView添加tableHeaderView 支持UITableView添加 section header view，并且显示不会出现悬停位置不正确的情况 支持自定义 SegmentedControlView （tab点选）的样式，你可以自己设置动画、自己设置高度等等等 UIView支持 UIScrollView 支持 UITableView 支持添加 tableHeaderView UITableView 支持添加 section header 为什么做这个现在很多类似的框架，但是还是做了一个，主要是因为网上大多数框架写死了SegmentedControlView(就是tab的样式)，另外最重要的一点是我试验过很多框架发现UITableView的tableHeaderView会有问题，而且一旦设置section header view，悬停都有问题，所以我就自己写了一个…… 导入项目CocoaPodsCocoaPods是一个Cocoa项目管理器。你可以使用以下命令去安装CocoaPods: 1$ gem install cocoapods 要使用CocoaPods将TSegmentedView集成到您的Xcode项目中，请在Podfile中加入： 1234567source 'https://github.com/CocoaPods/Specs.git'platform :ios, '8.0'use_frameworks!target '&lt;Your Target Name&gt;' do pod 'TSegmentedView'end 然后运行一下命令: 1$ pod install CarthageCarthage是一个去中心化的依赖管理器，它构建并提供所使用的库的framework。 你可以使用 Homebrew并运行下面的命令安装Carthage 12$ brew update$ brew install carthage 要将TSegmentedView集成到使用Carthage的Xcode项目中，请在Cartfile中加入： 1github "tobedefined/TSegmentedView" ~&gt; 1.0.2 运行carthage update构建framework，并将编译的TSegmentedView.framework拖入Xcode项目中。 如何使用 swift 1import TSegmentedView Objective-C 1#import &lt;TSegmentedView/TSegmentedView-Swift.h&gt; 你可以在demo中看具体的使用方法，下面是具体的介绍 遵守协议： TSegmentedViewDelegate123func segmentedViewTitles(in segmentedView: TSegmentedView) -&gt; [String]func segmentedView(_ view: TSegmentedView, viewForIndex index: Int) -&gt; UIView 第一个函数是给TSegmentedView没一个tab的title赋值，array的count是tab的数量 第二个函数是给对应每个tab赋予所显示的view 可选的协议函数 12345678910111213141516171819202122232425// 1 @objc optional func segmentedView(_ view: TSegmentedView, didShow index: Int) -&gt; Void// 2@objc optional func segmentedViewSegmentedControlView(in segmentedView: TSegmentedView) -&gt; UIView// 3// default is 0@objc optional func segmentedViewFirstStartSelectIndex(in segmentedView: TSegmentedView) -&gt; Int// 4// default is nil@objc optional func segmentedViewHeaderView(in segmentedView: TSegmentedView) -&gt; UIView// 5// default is segmentedViewHeaderView height@objc optional func segmentedViewHeaderMaxHeight(in segmentedView: TSegmentedView) -&gt; CGFloat// 6// default is segmentedViewHeaderView height@objc optional func segmentedViewHeaderMinHeight(in segmentedView: TSegmentedView) -&gt; CGFloat// 7// when scroll top or bottom, change the titles view height , will run this method@objc optional func segmentedView(_ view: TSegmentedView, didChangeHeaderHeightTo height: CGFloat) -&gt; Void 可选函数解释 函数是在index对应的view显示时候会调用，每次都会调用 函数返回定义的SegmentedControlView（默认为TSegmentedControlView） 函数返回TSegmentedView创建时候选择哪一个tab（默认选择第一个tab–&gt; index = 0） 返回headerView（默认为nil） 设置header的最大高度（默认为header的frame的size.height） 设置header的最小高度（默认与最大高度相同） header高度发生变化时候会调用此函数，允许外面根据新的hight做一些动画等 关于 TSegmentedControlProtocol你可以看到在TSegmentedView.swift中看到这个协议的定义 12345@objc protocol TSegmentedControlProtocol: class &#123; func reloadData(with titles: [String]) -&gt; Void func userScrollExtent(_ extent: CGFloat) -&gt; Void func setAction(_ actionBlock: ((_ index: Int) -&gt; Void)?) -&gt; Void&#125; 作用： TSegmentedView允许用户自定义SegmentedControlView而不是必须使用TSegmentedControlView 如何自定义SegmentedControlView 首先创建的view必须是UIView的子类，然后符合TSegmentedControlProtocol协议，并实现这三个方法 func reloadData(with titles: [String]) -&gt; Void 这个方法在TSegmentedView reloadData的时候回去调用，这个方法中需要实现更新对应tab的view创建删除显示等操作，titles的值为TSegmentedControlView的代理方法返回的 array func userScrollExtent(_ extent: CGFloat) -&gt; Void 这个方法在TSegmentedView 滑动（用户手动滑动）的时候回去调用，这个方法中需要实现更新对应tab的view显示样式或自定义一些动画等,extent的值为当前滑动的占比。例如有3个tab，则范围为0.0 ~ 2.0 func reloadData(with titles: [String]) -&gt; Void 这个方法在TSegmentedView reloadData的时候回去调用，这个方法中需要实现更新对应tab的view创建删除显示等操作 func setAction(_ actionBlock: ((_ index: Int) -&gt; Void)?) -&gt; Void 这个方法需要你将actionBlock进行保存，并在点击tab时候进行调用actionBlock，这样才会滚动到对应tab的view的位置。（刚开始考虑是在协议中定义一个actionBlock的变量，为了兼容Objective-C，所以还是定义成函数。）]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoreML & TensorFlow For iOS]]></title>
    <url>%2F2017%2F07%2F14%2FiOS%2F17071401.CoreML%20%26%20TensorFlow%20For%20iOS%2Findex%2F</url>
    <content type="text"><![CDATA[TensorFlowForIOS DemoCoreML Tools官网下载网站文档123pip install -U coremltools# orpip install -U coremltools --upgrade --ignore-installed sixTensorFlow安装文档 环境 Python 2.7 Python 3.3+ 这里采用 Installing with native pip 检查pip版本 12pip -V # for Python 2.7pip3 -V # for Python 3.n 升级pip版本和six版本（建议pip版本&gt;=8.1） 12sudo easy_install --upgrade pipsudo easy_install --upgrade six pip安装TensorFlow 12pip3 install tensorflowpip install tensorflow 12345678910111213141516171819202122232425$ pip3 install tensorflowCollecting tensorflow Downloading tensorflow-1.2.1-cp35-cp35m-macosx_10_11_x86_64.whl (33.6MB) 100% |████████████████████████████████| 33.6MB 26kB/sCollecting werkzeug&gt;=0.11.10 (from tensorflow) Using cached Werkzeug-0.12.2-py2.py3-none-any.whlCollecting wheel&gt;=0.26 (from tensorflow) Downloading wheel-0.29.0-py2.py3-none-any.whl (66kB) 100% |████████████████████████████████| 71kB 65kB/sCollecting html5lib==0.9999999 (from tensorflow) Using cached html5lib-0.9999999.tar.gzRequirement already satisfied: numpy&gt;=1.11.0 in /Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages (from tensorflow)Collecting protobuf&gt;=3.2.0 (from tensorflow)Collecting backports.weakref==1.0rc1 (from tensorflow) Using cached backports.weakref-1.0rc1-py3-none-any.whlRequirement already satisfied: six&gt;=1.10.0 in /Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages (from tensorflow)Collecting bleach==1.5.0 (from tensorflow) Using cached bleach-1.5.0-py2.py3-none-any.whlCollecting markdown&gt;=2.6.8 (from tensorflow) Using cached Markdown-2.6.8.tar.gzRequirement already satisfied: setuptools in /Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages (from protobuf&gt;=3.2.0-&gt;tensorflow)Installing collected packages: werkzeug, wheel, html5lib, protobuf, backports.weakref, bleach, markdown, tensorflow Running setup.py install for html5lib ... done Running setup.py install for markdown ... doneSuccessfully installed backports.weakref-1.0rc1 bleach-1.5.0 html5lib-0.9999999 markdown-2.6.8 protobuf-3.3.0 tensorflow-1.2.1 werkzeug-0.12.2 wheel-0.29.0 (可选)如果pip安装TensorFlow失败尝试以下命令 12sudo pip install --upgrade tfBinaryURL # Python 2.7sudo pip3 install --upgrade tfBinaryURL # Python 3.n tfBinaryURL是指TensorFlow Python package的URL，查找合适的下载地址例如： 12sudo pip3 install --upgrade \https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-1.2.1-py2-none-any.whl 验证安装正确 123456$ Python or Python3&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; hello = tf.constant('Hello, TensorFlow!')&gt;&gt;&gt; sess = tf.Session()&gt;&gt;&gt; print(sess.run(hello)) Kerasgithub To install Keras, cd to the Keras folder and run the install command: 1sudo python setup.py install You can also install Keras from PyPI: 1sudo pip install keras 1234567891011121314151617181920212223242526$ sudo pip3 install kerasPassword:The directory '/Users/shaoweinan154/Library/Caches/pip/http' or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.The directory '/Users/shaoweinan154/Library/Caches/pip' or its parent directory is not owned by the current user and caching wheels has been disabled. check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.Collecting keras Downloading Keras-2.0.6.tar.gz (228kB) 100% |████████████████████████████████| 235kB 170kB/sCollecting theano (from keras) Downloading Theano-0.9.0.tar.gz (3.1MB) 100% |████████████████████████████████| 3.1MB 86kB/sCollecting pyyaml (from keras) Downloading PyYAML-3.12.tar.gz (253kB) 100% |████████████████████████████████| 256kB 70kB/sCollecting six (from keras) Downloading six-1.10.0-py2.py3-none-any.whlCollecting numpy&gt;=1.9.1 (from theano-&gt;keras) Downloading numpy-1.13.1-cp35-cp35m-macosx_10_6_intel.macosx_10_9_intel.macosx_10_9_x86_64.macosx_10_10_intel.macosx_10_10_x86_64.whl (4.5MB) 100% |████████████████████████████████| 4.5MB 59kB/sCollecting scipy&gt;=0.14 (from theano-&gt;keras) Downloading scipy-0.19.1-cp35-cp35m-macosx_10_6_intel.macosx_10_9_intel.macosx_10_9_x86_64.macosx_10_10_intel.macosx_10_10_x86_64.whl (16.1MB) 100% |████████████████████████████████| 16.1MB 30kB/sInstalling collected packages: numpy, scipy, six, theano, pyyaml, keras Running setup.py install for theano ... done Running setup.py install for pyyaml ... done Running setup.py install for keras ... doneSuccessfully installed keras-2.0.6 numpy-1.13.1 pyyaml-3.12 scipy-0.19.1 six-1.10.0 theano-0.9.0 编译TensorFlow For iOS 官方文档 Install XCode 7.3 or more recent. 下载TensorFlow到项目根目录并编译 在编译源文件之前, 要先进行修改TensorFlow Kernel的一些文件（版本 &lt;= 1.2.1） kernel path: tensorflow/tensorflow/core/kernels cwise_op_add_1.cc 源码: 1234567891011......#include "tensorflow/core/kernels/cwise_ops_common.h"namespace tensorflow &#123;REGISTER5(BinaryOp, CPU, "Add", functor::add, float, Eigen::half, double, int32, int64);#if TENSORFLOW_USE_SYCL...... 修改为: 1234567891011121314151617......#include "tensorflow/core/kernels/cwise_ops_common.h"namespace tensorflow &#123;REGISTER5(BinaryOp, CPU, "Add", functor::add, float, Eigen::half, double, int32, int64);// line 21 insert this code#if defined(__ANDROID_TYPES_SLIM__)REGISTER(BinaryOp, CPU, "Add", functor::add, int32);#endif // __ANDROID_TYPES_SLIM__// insert end#if TENSORFLOW_USE_SYCL...... cwise_op_less.cc 源码: 123456789101112......#include "tensorflow/core/kernels/cwise_ops_common.h"namespace tensorflow &#123;REGISTER8(BinaryOp, CPU, "Less", functor::less, float, Eigen::half, double, int32, int64, uint8, int8, int16);#if GOOGLE_CUDAREGISTER7(BinaryOp, GPU, "Less", functor::less, float, Eigen::half, double, int64, uint8, int8, int16);...... 修改为: 12345678910111213141516171819......#include "tensorflow/core/kernels/cwise_ops_common.h"namespace tensorflow &#123;REGISTER8(BinaryOp, CPU, "Less", functor::less, float, Eigen::half, double, int32, int64, uint8, int8, int16);// line 21 insert this code#if defined(__ANDROID_TYPES_SLIM__)REGISTER(BinaryOp, CPU, "Less", functor::less, int32);#endif // __ANDROID_TYPES_SLIM__// insert end#if GOOGLE_CUDAREGISTER7(BinaryOp, GPU, "Less", functor::less, float, Eigen::half, double, int64, uint8, int8, int16);...... install the command-line tools using xcode-select 1xcode-select --install install automake/libtool: 12brew install automakebrew install libtool Building all at once 1tensorflow/contrib/makefile/build_all_ios.sh 项目导入TensorFlow 下载TensorFlow到项目根目录并编译 libtensorflow-core.a Other Link Flags 中加入 $(SRCROOT)/tensorflow/tensorflow/contrib/makefile/gen/lib/libtensorflow-core.a Library Search Paths 中加入 $(SRCROOT)/tensorflow/tensorflow/contrib/makefile/gen/lib libprotobuf.a &amp; libprotobuf-lite.a Build Phases | Link Binary With Libraries 中加入 libprotobuf.a &amp; libprotobuf-lite.a (path: tensorflow/tensorflow/contrib/makefile/gen/protobuf_ios/lib/) Library Search Paths 中加入 $(SRCROOT)/tensorflow/tensorflow/contrib/makefile/gen/protobuf_ios/lib Header Search Paths中加入 $(SRCROOT)/tensorflow/ $(SRCROOT)/tensorflow/tensorflow/contrib/makefile/downloads/protobuf/src/ $(SRCROOT)/tensorflow/tensorflow/contrib/makefile/downloads $(SRCROOT)/tensorflow/tensorflow/contrib/makefile/downloads/eigen $(SRCROOT)/tensorflow/tensorflow/contrib/makefile/gen/proto Other Link Flags 中加入 -force_load Build Phases | Link Binary With Libraries 中加入 Accelerate.framework C++ Language Dialect 设置为 GNU++11 or GNU++14 C++ Standard Library 设置为 libc++ Enable Bitcode 设置为 No 删除所有使用的 -all_load ，替换为 -ObjC Remove any use of the -all_load flag in your project. The protocol buffers libraries (full and lite versions) contain duplicate symbols, and the -all_load flag will cause these duplicates to become link errors. If you were using -all_load to avoid issues with Objective-C categories in static libraries, you may be able to replace it with the -ObjC flag. 忽略TensorFlow编译的警告： 在Other C Flags &amp; Other C++ Flags中加入-isystem $(SRCROOT)/tensorflow 参考文档 编译TensorFlow： https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/makefile 修改Kernels错误： https://github.com/h4x3rotab/emoji-tf-ios/blob/master/README.md 项目中导入TensorFlow静态库： https://github.com/tensorflow/tensorflow/blob/master/tensorflow/examples/ios/README.md 忽略TensorFlow警告： https://clang.llvm.org/docs/UsersManual.html%23id27]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CoreML</tag>
        <tag>TensorFlow</tag>
        <tag>Keras</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在SDWebImage基础上添加UIImageView扩展使其可以缓存]]></title>
    <url>%2F2017%2F07%2F05%2FiOS%2F17070502.%E5%9C%A8SDWebImage%E5%9F%BA%E7%A1%80%E4%B8%8A%E6%B7%BB%E5%8A%A0UIImageView%E6%89%A9%E5%B1%95%E4%BD%BF%E5%85%B6%E5%8F%AF%E4%BB%A5%E7%BC%93%E5%AD%98%2Findex%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import SDWebImageextension UIImageView &#123; // 设置并缓存image func sd_setImageAndCached(with urlString: String, placeholderImage: UIImage? = nil) &#123; self.image = placeholderImage self.sd_cancelImageLoadOperation(withKey: "UIImageViewImageLoad") let operation = UIImage.getImageWithURLString( urlString, showLoadingView: false, completion: &#123; [weak self] (image) in let img = image ?? placeholderImage self?.image = img &#125; ) if operation != nil &#123; self.sd_setImageLoadOperation(operation, forKey: "UIImageViewImageLoad") &#125; &#125;&#125;extension UIImage &#123; // 使用URLString获取一张图片 @discardableResult class func getImageWithURLString(_ urlString: String, showLoadingView: Bool = false, completion: @escaping (_ image: UIImage?) -&gt; ()) -&gt; SDWebImageOperation? &#123; if let url = URL.init(string: urlString) &#123; if SDWebImageManager.shared().cachedImageExists(for: url) &#123; let key = SDWebImageManager.shared().cacheKey(for: url) let image = SDImageCache.shared().imageFromDiskCache(forKey:key) completion(image) return nil &#125; else if SDWebImageManager.shared().diskImageExists(for: url)&#123; let key = SDWebImageManager.shared().cacheKey(for: url) let image = SDImageCache.shared().imageFromDiskCache(forKey: key) completion(image) return nil &#125; else &#123; if showLoadingView &#123; PAMBManager.sharedInstance.showLoading(view: nil) &#125; let operation = SDWebImageManager.shared().downloadImage( with: url, options: SDWebImageOptions.init(rawValue: 0), progress: nil, completed: &#123; [showLoadingView, completion] (image, error, cacheType, finished, imageURL) in if showLoadingView &#123; PAMBManager.sharedInstance.hideAlert(view: nil) &#125; completion(image) &#125; ) return operation &#125; &#125; else &#123; completion(nil) return nil &#125; &#125;&#125;]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>随笔</tag>
        <tag>SDWebImage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS屏幕旋转知识点以及实现]]></title>
    <url>%2F2017%2F07%2F05%2FiOS%2F17070501.iOS%E5%B1%8F%E5%B9%95%E6%97%8B%E8%BD%AC%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%2Findex%2F</url>
    <content type="text"><![CDATA[iOS屏幕旋转 此文主要针对IOS应用, 是屏幕旋转相关问题的一个总结. 主要内容有: iOS4,5,6-9,10+不同版的适配. 强制旋转和自动旋转. 个别屏幕可以旋转，其他屏幕不能旋转 两种orientation 了解屏幕旋转首先需要区分两种orientation Device Orientation设备的物理方向，由类型UIDeviceOrientation表示，当前设备方向获取方式：[UIDevice currentDevice].orientation 该属性的值一般是与当前设备方向保持一致的，但须注意以下几点: 文档中对该属性的注释： 123// return current device orientation.// this will return UIDeviceOrientationUnknown unless device orientation notifications are being generated.@property(nonatomic,readonly) UIDeviceOrientation orientation; 所以更推荐下面这种用法： 123456if (![UIDevice currentDevice].generatesDeviceOrientationNotifications) &#123; [[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications]; &#125;NSLog(@"%d",[UIDevice currentDevice].orientation);[[UIDevice currentDevice] endGeneratingDeviceOrientationNotifications]; 系统横竖屏开关关闭时 如果关闭了系统的横竖屏切换开关，即系统层级只允许竖屏时，再通过上述方式获取到的设备方向将永远是UIDeviceOrientationUnknown。可以通过Core Motion中的CMMotionManager来获取当前设备方向。 Interface Orientation界面显示的方向，由类型UIInterfaceOrientation表示。当前界面显示方向有以下两种方式获取： 12NSLog(@"%d",[UIApplication sharedApplication].statusBarOrientation);NSLog(@"%d",viewController.interfaceOrientation); 即可以通过系统statusBar的方向或者viewController的方向来获取当前界面方向。 二者区别通过UIDevice获取到的设备方向在手机旋转时是实时的，通过UIApplication的statusBar或者viewController获取到的界面方向在下述方法： 12- (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration 调用以后才会被更改成最新的值。 相关枚举定义目前屏幕旋转相关的枚举变量定义主要包括以下三种： UIDeviceOrientation硬件设备屏幕方向 UIInterfaceOrientation程序界面旋转方向 UIInterfaceOrientationMask程序界面旋转方向集合。 相信有一部分人在开发过程中对三个枚举变量类型没有明确的区分概念，甚至混用。 UIDeviceOrientation123456789typedef NS_ENUM(NSInteger, UIDeviceOrientation) &#123; UIDeviceOrientationUnknown, UIDeviceOrientationPortrait, // Device oriented vertically, home button on the bottom UIDeviceOrientationPortraitUpsideDown, // Device oriented vertically, home button on the top UIDeviceOrientationLandscapeLeft, // Device oriented horizontally, home button on the right UIDeviceOrientationLandscapeRight, // Device oriented horizontally, home button on the left UIDeviceOrientationFaceUp, // Device oriented flat, face up UIDeviceOrientationFaceDown // Device oriented flat, face down&#125; __TVOS_PROHIBITED; iOS 6 之前用于控制屏幕方向的枚举UIInterfaceOrientation1234567typedef NS_ENUM(NSInteger, UIInterfaceOrientation) &#123; UIInterfaceOrientationUnknown = UIDeviceOrientationUnknown, UIInterfaceOrientationPortrait = UIDeviceOrientationPortrait, UIInterfaceOrientationPortraitUpsideDown = UIDeviceOrientationPortraitUpsideDown, UIInterfaceOrientationLandscapeLeft = UIDeviceOrientationLandscapeRight, UIInterfaceOrientationLandscapeRight = UIDeviceOrientationLandscapeLeft&#125; __TVOS_PROHIBITED; 从宏定义可知，UIDeviceOrientation方向比UIInterfaceOrientation多了两个定义：UIDeviceOrientationFaceUp和UIDeviceOrientationFaceDown，分别表示手机水平放置，屏幕向上和屏幕向下。 iOS 6 及之后版本用于控制屏幕方向的枚举UIInterfaceOrientationMask123456789typedef NS_OPTIONS(NSUInteger, UIInterfaceOrientationMask) &#123; UIInterfaceOrientationMaskPortrait = (1 &lt;&lt; UIInterfaceOrientationPortrait), UIInterfaceOrientationMaskLandscapeLeft = (1 &lt;&lt; UIInterfaceOrientationLandscapeLeft), UIInterfaceOrientationMaskLandscapeRight = (1 &lt;&lt; UIInterfaceOrientationLandscapeRight), UIInterfaceOrientationMaskPortraitUpsideDown = (1 &lt;&lt; UIInterfaceOrientationPortraitUpsideDown), UIInterfaceOrientationMaskLandscape = (UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight), UIInterfaceOrientationMaskAll = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight | UIInterfaceOrientationMaskPortraitUpsideDown), UIInterfaceOrientationMaskAllButUpsideDown = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),&#125; __TVOS_PROHIBITED; iOS 6 及之后版本使用的 UIInterfaceOrientationMask 类型来控制屏幕屏幕方向，该类型也新增加了几个枚举取值，可用一个枚举取值来代表多个屏幕方向。 四个基本屏幕方向（上、下、左、右）中，UIInterfaceOrientationMask = (1 &lt;&lt; UIInterfaceOrientation)，所以，如果你的应用中需要动态的将 UIInterfaceOrientation 类型转换成 UIInterfaceOrientationMask 类型的话，只需做一下上面的转换即可，不需要通过 switch 来判断再转换。 改变Orientation的三种途径 这里主要理清一下：到底有哪些设置可以改变屏幕旋转特性，这样的话 出现任何问题我们都可以从这几个途径中发现原因； 灵活应付产品经理的各种需求 首先我们得知道： 当手机的重力感应打开的时候，如果用户旋转手机，系统会抛发UIDeviceOrientationDidChangeNotification 事件； 您可以分别设置Application和UIViewcontroller支持的旋转方向；Application的设置会影响整个App，UIViewcontroller的设置仅仅会影响一个viewController(IOS5和IOS6有所不同，下面会详细解释)； 当UIKit收到UIDeviceOrientationDidChangeNotification事件的时候，会根据Application和UIViewcontroller的设置, 如果双方都支持此方向， 则会自动屏幕旋转到这个方向（会对两个设置求与运算得到可以支持的方向）；如果求与之后，没有任何可支持的方向，则会抛发UIApplicationInvalidInterfaceOrientationException异常. 如何决定Interface Orientation全局控制Info.plist文件中，有一个Supported Interface Orientations，可以配置整个应用的屏幕方向，此处为全局控制。 key xcode name Summary avilable value UIInterfaceOrientation initial interface orientation Specifies the initial orientation of the app’s user interface. UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight UISupportedInterfaceOrientations Supported interface orientations Specifies the orientations that the app supports. UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight 在Info.plist中设置之后,这个app里所有的viewController支持的自动旋转方向都只能是app支持的方向的子集. eg: 123456&lt;key&gt;UISupportedInterfaceOrientations&lt;/key&gt;&lt;array&gt; &lt;string&gt;UIInterfaceOrientationPortrait&lt;/string&gt; &lt;string&gt;UIInterfaceOrientationLandscapeLeft&lt;/string&gt; &lt;string&gt;UIInterfaceOrientationLandscapeRight&lt;/string&gt;&lt;/array&gt; 此配置其实跟工程中 Target 的 Summary 界面中的 Device Orientation 配置是一致的，修改任意一边，另一个边都会同步的修改。 eg: UIWindow的方向控制（iOS6及以上版本才有效）iOS6的UIApplicationDelegate提供了下述方法，能够指定 UIWindow 中的界面的屏幕方向： 1- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(nullable UIWindow *)window NS_AVAILABLE_IOS(6_0) __TVOS_PROHIBITED; 该方法默认值为Info.plist中配置的Supported Interface Orientations项的值。 iOS中通常只有一个window，所以此处的控制也可以视为全局控制。 UIViewController的方向控制iOS5中控制屏幕旋转的方法：在 iOS 6 之前，单个界面的屏幕方向控制，都使用 UIViewController 类中的这个方法： 12// Applications should use supportedInterfaceOrientations and/or shouldAutorotate..- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation NS_DEPRECATED_IOS(2_0, 6_0); 如果打算支持toInterfaceOrientation对应的方向就返回YES，否则返回NO。默认情况下，此方法只有参数为 UIInterfaceOrientationPortrait 时，返回值才为真，即默认只支持竖屏向上。下面的例子中，表示支持横屏向右及横屏向左两个方向。 eg: 123456// 是否支持旋转到某个屏幕方向- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation&#123; return ((toInterfaceOrientation == UIInterfaceOrientationLandscapeRight) | (toInterfaceOrientation == UIInterfaceOrientationLandscapeLeft));&#125; iOS6以及以后版本中控制屏幕旋转相关方法： 限制 当前controller是window的rootViewController 当前controller是modal模式的(present出来的) iOS10以及之前版本变化 iOS6~iOS9中modal的controller需要rootViewController做特殊处理调用旋转 iOS10+ model的controller可以独立处理 只有以上两种情况时候，以下的orientations相关方法才会起作用（才会被调用），当前controller及其所有的childViewController都在此作用范围内。 1234567891011121314// New Autorotation support.// 是否支持转屏// @property(nonatomic, readonly) BOOL shouldAutorotate NS_AVAILABLE_IOS(6_0) __TVOS_PROHIBITED;- (BOOL)shouldAutorotate NS_AVAILABLE_IOS(6_0) __TVOS_PROHIBITED;// 支持的屏幕方向，此处可直接返回 UIInterfaceOrientationMask 类型// 也可以返回多个 UIInterfaceOrientationMask 取或运算后的值- (UIInterfaceOrientationMask)supportedInterfaceOrientations NS_AVAILABLE_IOS(6_0) __TVOS_PROHIBITED;// Returns interface orientation masks.// 优先方向- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation NS_AVAILABLE_IOS(6_0) __TVOS_PROHIBITED; - shouldAutorotate 方法决定是否支持多方向旋转屏，如果返回NO则后面的两个方法都不会再被调用，而且只会支持默认的UIInterfaceOrientationMaskPortrait方向； - supportedInterfaceOrientations 直接返回支持的旋转方向，该方法在iPad上的默认返回值是UIInterfaceOrientationMaskAll，iPhone上的默认返回值是UIInterfaceOrientationMaskAllButUpsideDown，详情见官方Q&amp;A文档； - preferredInterfaceOrientationForPresentation 返回最优先显示的屏幕方向，比如同时支持Portrait和Landscape方向，但想优先显示Landscape方向，那软件启动的时候就会先显示Landscape，在手机切换旋转方向的时候仍然可以在Portrait和Landscape之间切换； attemptRotationToDeviceOrientation方法从iOS5开始有了这个新方法： 1234// call this method when your return value from shouldAutorotateToInterfaceOrientation: changes// if the current interface orientation does not match the current device orientation, // a rotation may occur provided all relevant view controllers now return YES from shouldAutorotateToInterfaceOrientation:+ (void)attemptRotationToDeviceOrientation NS_AVAILABLE_IOS(5_0); 该方法的使用场景是Interface Orientation和Device Orientation不一致，但希望通过重新指定Interface Orientation的值，立即实现二者一致；如果这时只是更改了支持的Interface Orientation的值，没有调用attemptRotationToDeviceOrientation，那么下次Device Orientation变化的时候才会实现二者一致，关键点在于能不能立即实现。 举个例子： 假设当前的Interface Orientation只支持Portrait，如果Device Orientation变成Landscape，那么Interface Orientation仍然显示Portrait； 如果这时我们希望Interface Orientation也变成和Device Orientation一致的Landscape，以iOS6为例，需要先将supportedInterfaceOrientations的返回值改成Landscape，然后调用attemptRotationToDeviceOrientation方法，系统会重新询问支持的Interface Orientation，已达到立即更改当前Interface Orientation的目的。 最终支持的屏幕方向 前面所述的3种控制规则的交集就是一个controller的最终支持的方向，就是说：一个界面最后支持的屏幕方向，是取 (全局控制 ∩ UIWindow 中的界面控制 ∩ 单个界面控制) 的交集，如果全局控制支持所有屏幕方向，UIWindow中的界面控制支持横屏，当个界面中只是支持横屏向右，那么最后界面只会以横屏向右显示，并且不支持旋转到其他的方向。 如果以上三种控制支持的屏幕方向最后的交集为空，iOS 5 跟 iOS 6 的处理有点不同，在 iOS 6 下，甚至会直接抛出 UIApplicationInvalidInterfaceOrientationException 的异常，然后直接崩溃，所以还是要保持这三个值的交集为非空。 强制屏幕旋转如果Interface和Device方向不一样，想强制将Interface旋转成Device的方向，可以通过attemptRotationToDeviceOrientation实现，但是如果想将Interface强制旋转成任一指定方向，该方式就无能为力了。 不过聪明的开发者们总能想到解决方式： 私有方法1[[UIDevice currentDevice] setOrientation:UIInterfaceOrientationPortrait]; 但是现在苹果已经将该方法私有化了，越狱开发的同学可以试试，或者自己想法子骗过苹果审核吧。 可能骗过审核的方法： objc: NSInvocation 123456789if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) &#123; SEL selector = NSSelectorFromString(@"setOrientation:"); NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]]; [invocation setSelector:selector]; [invocation setTarget:[UIDevice currentDevice]]; int val = UIInterfaceOrientationLandscapeRight; [invocation setArgument:&amp;val atIndex:2]; [invocation invoke];&#125; objc: performSelector: withObject: 1234if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) &#123; [[UIDevice currentDevice] performSelector:@selector(setOrientation:) withObject:(id)UIInterfaceOrientationLandscapeRight]; &#125; swift: setValue(_ , forKey: String) 1UIDevice.current.setValue(UIDeviceOrientation.portrait.rawValue, forKey: "orientation") 旋转view的transform也可以通过旋转view的transform属性达到强制旋转屏幕方向的目的，但个人感觉这不是靠谱的思路，可能会带来某些诡异的问题。 12345UIView.animate(withDuration: UIApplication.shared.statusBarOrientationAnimationDuration) &#123; self.view.transform = CGAffineTransform.identity self.view.transform = CGAffineTransform.init(rotationAngle: CGFloat(Double.pi / 2)) self.view.bounds = CGRect.init(x: 0, y: 0, width: UIScreen.main.bounds.height, height: UIScreen.main.bounds.width)&#125; 主动触发Orientation机制要是能主动触发系统的orientation机制，调用orientation相关方法，使新设置的orientation值起作用就好了。这样只要提前设置好想要支持的orientation，然后主动触发orientation机制，便能实现将interface orientation旋转至任意方向的目的。 万能的stackoverflow上提供了一种主动触发的方式： 在iOS4和iOS6以后： 1234UIViewController *vc = [[UIViewController alloc]init];[self presentModalViewController:vc animated:NO];[self dismissModalViewControllerAnimated:NO];[vc release]; iOS5中： 1234UIWindow *window = [[UIApplication sharedApplication] keyWindow];UIView *view = [window.subviews objectAtIndex:0];[view removeFromSuperview];[window addSubview:view]; 这种方式会触发UIKit重新调用Controller的Orientation相关方法，以达到在Device方向不变的情况下改变Interface方向的目的。 实现并兼容iOS6(8)以后所有版本 需求： 需要在iOS8-iOS10中支持个别屏幕可以自由旋转 项目主体是竖屏 思路 rootViewController去获得当前显示的ViewController是否允许旋转 所有controller继承基controller，基controller不允许旋转，特殊的controller特殊处理 swift实现，iOS8以后所有版本，iOS8之前objc实现即可 设置全局方向控制 项目勾选（全局）： AppDelegate实现代理（UIWindow）： 返回与勾选的类型一致的值，也可以不进行实现，默认一致 123func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -&gt; UIInterfaceOrientationMask &#123; return UIInterfaceOrientationMask.allButUpsideDown&#125; 定义协议OrientationProtocol并对UIViewController扩展实现 协议为了方便各个子viewcontroller自行控制自己的方向，只需要重写协议内的函数实现即可，无需在控制原有的几个orientation函数 1234567891011121314151617181920212223// MARK: OrientationProtocol viewcontroller旋转控制protocol OrientationProtocol &#123; // supportedInterfaceOrientations func orientations() -&gt; UIInterfaceOrientationMask // shouldAutorotate func autorotate() -&gt; Bool // preferredInterfaceOrientationForPresentation func preferredOrientation() -&gt; UIInterfaceOrientation&#125;extension UIViewController: OrientationProtocol &#123; func orientations() -&gt; UIInterfaceOrientationMask &#123; return UIInterfaceOrientationMask.portrait &#125; func autorotate() -&gt; Bool &#123; return true &#125; func preferredOrientation() -&gt; UIInterfaceOrientation &#123; return UIInterfaceOrientation.portrait &#125;&#125; 设置BaseViewController 为了使所有的controller默认竖屏而不需要每个controller都进行设置 所有的ViewController继承BaseViewController 所有的TableVIewController继承BaseTableViewController 所有的BaseController实现以下扩展 12345678910111213extension BaseViewController &#123; override var shouldAutorotate: Bool &#123; return true &#125; override var supportedInterfaceOrientations: UIInterfaceOrientationMask &#123; return UIInterfaceOrientationMask.portrait &#125; override var preferredInterfaceOrientationForPresentation: UIInterfaceOrientation &#123; return UIInterfaceOrientation.portrait &#125;&#125; 修改window所有的rootViewController AppDelegat.getCurrentViewController() 1234567891011121314151617181920212223242526272829303132333435363738class AppDelegate: UIResponder, UIApplicationDelegate &#123;................ // 获取当前屏幕显示的viewcontroller static func getCurrentViewController() -&gt; UIViewController? &#123; // 嵌套函数，寻找当前屏幕上显示的viewcontroller func findBestViewController(from viewController: UIViewController?) -&gt; UIViewController? &#123; if let presentedViewController = viewController?.presentedViewController &#123; // 返回presentedViewController return findBestViewController(from: presentedViewController) &#125; else if let navigationViewController = viewController as? UINavigationController &#123; // 返回最顶部的vc if navigationViewController.viewControllers.count &gt; 0 &#123; return findBestViewController(from: navigationViewController.topViewController) &#125; else &#123; return navigationViewController &#125; &#125; else if let tabBarController = viewController as? UITabBarController &#123; // 返回当前选择的vc if (tabBarController.viewControllers?.count ?? 0) &gt; 0 &#123; return findBestViewController(from: tabBarController.selectedViewController) &#125; else &#123; return tabBarController &#125; &#125; else &#123; // 普通vc返回自己 return viewController &#125; &#125; let rootViewController = UIApplication.shared.keyWindow?.rootViewController return findBestViewController(from: rootViewController) &#125; ................&#125; RootViewController设置获取当前显示的controller进行变换旋转值的设置 这里兼容了iOS10之前的modal的controller需要rootViewController设置方向的问题 1234567891011121314151617181920212223// MARK: 项目的RootViewController是MainTabBarControllerextension MainTabBarController &#123; override var supportedInterfaceOrientations: UIInterfaceOrientationMask &#123; if let vc = AppDelegate.getCurrentViewController() &#123; return vc.orientations() &#125; return UIInterfaceOrientationMask.portrait &#125; override var shouldAutorotate: Bool &#123; if let vc = AppDelegate.getCurrentViewController() &#123; return vc.autorotate() &#125; return true &#125; override var preferredInterfaceOrientationForPresentation: UIInterfaceOrientation &#123; if let vc = AppDelegate.getCurrentViewController() &#123; return vc.preferredOrientation() &#125; return UIInterfaceOrientation.portrait &#125;&#125; 设置个别的可以旋转方向的controller12345678910111213141516extension SomeSpecialViewController &#123; override func orientations() -&gt; UIInterfaceOrientationMask &#123; // 返回允许的方向 return UIInterfaceOrientationMask.allButUpsideDown &#125; override func autorotate() -&gt; Bool &#123; // 设置允许自动旋转 return true &#125; override func preferredOrientation() -&gt; UIInterfaceOrientation &#123; // 设置优先的方向 return UIInterfaceOrientation.portrait &#125;&#125; 遇到的问题在实现过程中发现，如果不设置BaseViewController中的方法，只进行UIViewController扩展，会出现一种情况： 从一个不可旋转的页面进入一个可旋转页面后，旋转到其他方向，返回上一个页面，这时候上一个页面也转动了…. 所以使用baseViewController的方式进行锁死不可旋转页面的方向，目前没发现其他的更好的处理方式。 参考资料： How to lock view controller in portrait orientation? iOS屏幕旋转学习笔记 iOS屏幕旋转二三事(Orientations) iOS 屏幕方向那点事儿 IOS Orientation, 想怎么转就怎么转~ How to force a UIViewController to Portrait orientation in iOS 6 Why won’t my UIViewController rotate with the device? iOS两个强制旋转屏幕的方法]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Orientation</tag>
        <tag>屏幕旋转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置NavigationBar隐藏和显示]]></title>
    <url>%2F2017%2F07%2F04%2FiOS%2F17070401.%E8%AE%BE%E7%BD%AENavigationBar%E9%9A%90%E8%97%8F%E5%92%8C%E6%98%BE%E7%A4%BA%2Findex%2F</url>
    <content type="text"><![CDATA[1234override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) self.navigationController?.setNavigationBarHidden(true, animated: true)&#125;1234override func viewWillDisappear(_ animated: Bool) &#123; super.viewWillDisappear(animated) self.navigationController?.setNavigationBarHidden(false, animated: true)&#125;]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS APP如何做才安全]]></title>
    <url>%2F2017%2F07%2F03%2FiOS%2F17070302.iOS%20APP%E5%A6%82%E4%BD%95%E5%81%9A%E6%89%8D%E5%AE%89%E5%85%A8%2Findex%2F</url>
    <content type="text"><![CDATA[本来 写了一篇《iOS 如何做才安全–逆向工程 - Reveal、IDA、Hopper、https抓包 等》，发现文章有点杂，并且“iOS 如何做才安全”这部分写的越来越多，觉得 分出来更清晰一点。所以拆成两部分。 同时也是为了大家能 共同讨论，毕竟不是专业搞安全的，如果文中有错误 欢迎指正，共同进步。 iOS应用的安全性 常常被大家忽视。 iOS 如何做才安全? 1、首先，我们可以通过iTunes 下载 AppStore的ipa文件(苹果 把开发者上传的ipa包 进行了加壳再放到AppStore中)，所以我们从AppStore下载的ipa都是加壳的，所以不能直接用来反编译。 得到ipa文件 可以分析APP 里包含的一些资源，如：图片、plist文件、静态wap页、.bundle 等。 所以不要 在plist文件、项目中的静态文件中 存储关键的信息，如果要保存，记得 对称加密（这样可以增加破解的难度）。 如果是越狱的手机，从 手机上的PP助手下载的ipa包 都是 脱壳之后的，可以直接用来反编译。 2、我们可以用软件 查看 APP的沙盒，查看里面存储的 文件:sqlite、plist（NSUserdefault会存到Library下的Preferences中 的 plist文件中）、图片等，NSUserdefault 中不要保存关键信息，如果要保存，还是加密吧。。sqlite也是这样子的。 iOS 8.3之前 不越狱的手机也可以 直接用MAC上的PP助手、iTool 来查看 任何APP的沙盒（系统APP除外）。iOS 8.3之后就不行了。 越狱手机 都可以查看任意APP的沙盒，包括系统APP的沙盒。还有iOS的系统目录等。 3、越狱手机 直接用PP助手下载的就是 脱壳的ipa，所以不用再脱了。对AppStore下载的ipa包 可以用工具对加壳的ipa 进行脱壳，再用IDA、Hopper 进行反编译，进行分析 ，可以得到 近乎易懂的 伪代码。但是反编译后的代码 要 一个方法一个方法的去分析，类似面向过程编程。。当然也有工具 去提取 项目中的所有.h文件。不过 反编译 终归是个 耐心的活，急躁的人容易砸电脑。 4、所有的APP都是可以反编译的，所以 很关键的数据 最好通过接口获取。 那么接口如何保证安全呢。首先用HTTPS，虽然HTTPS已经很安全了，但是数据也是有可能被破解的，这个后面会介绍。。所以 接口一定要自己加密。 非对称加密(RSA)现在 还是没有办法破解的，但是因为 非对称加密的效率低，所以很少有企业将所有的接口都用非对称加密。 接口如果用对称加密，密钥 放到代码里 是能被反编译出来的。如果你的 APP的安全性很高，就不要把密钥 写到代码里。 可以这样处理： 先通过非对称加密的接口 获取密钥，然后 再在 后面的 接口通信中 用这个密钥进行加密。这样做 就类似 HTTPS 的简化版实现了。安全性很高。目前应该 是不能破解的。 5、根据APP的安全性，也可以把 关键数据 写在代码里，可以保存的是加密后的数据。比如，我给一个变量赋值：U2FsdGVkX1+rN+sgpLmOYTqoVhRRerZj9oobZAIPzjo=，你不知道 我这个字符串解密后是 123456，我只是使用的时候才解密处理用。 这样也只是 增加了 黑客获取 关键数据的难度。 6、密钥要定期更换。比如 3个月 或半年换一次，如果密钥是从接口通过非对称加密 获取的，直接修改服务端就可以了。如果密钥是写在代码里的。就等APP升级新的版本的时候，新版本的APP和其对应的接口版本 都 修改为新的密钥 就可以了。 旧的接口版本和APP版本还用以前的密钥，等强制更新的时候才会失效。 如果一个APP 一个密钥用上几年都不变 ，是很危险的。离职的人员都可以直接用以前 的代码 来获取相关的数据。特别是 支付相关的，有的服务端甚至没有 去校验支付的金额或其他数据，导致 离职人员用1分钱 可以买到 任何价格的 线上产品（服务端这种在线上环境留后门的安全性问题，我是真的遇到有人这么搞）。。 7、最好能 进行 代码混淆，能增加反编译的难度，当然只是增加了难度，还是能破解的。但是 代码混淆 的 性价比是很高的，就是你这边付出了 一点时间，而黑客 就要多付出几十倍 的时间。。其实 接口 自己加密 的性价比也很高。 8、接口返回的数据 最好也进行 加密。比如，现在大家都连我的热点，或者代理服务器，我是有可能 直接 获取你的APP的 HTTPS 解密后的json数据（如何获取相见《逆向工程》）。当然，如果你觉得 你的APP返回的json数据都是 不重要的，也可以不对数据进行加密。 像微信、QQ、支付宝这种 安全性高的，通信两边的数据 收发 都 应该 进行加密的。 9、像HTTPS本身 是否有漏洞这种我们就不去说了。就 去年iOS的AFNetworking 漏洞事件，完全是 代码的问题。虽然不是HTTPS的安全机制的问题。但是 黑客还是能很容易拿到HTTPS解密后的数据。 去年iOS的AFNetworking曝SSL漏洞 就涉及2.5万个APP。 有的银行的APP，只用了HTTPS，通信都不加密，就很容易拿到明文数据了。有的APP里的各种数据都 采用复杂的加密算法，破解人员看到都烦，去破解这个APP的时间还不如去搞其他的几个APP。 HTTPS 本身是安全的。但是数据还是可能被破解。所以 不要觉得 我只用HTTPS 就安全了。理论上 说任何 的 协议、代码都是可能有漏洞的，只是有的现在 还没被发现或破解，并不代表一直不能被破解。。 10、黑客不会 去一个手机一个手机的 把沙盒数据 拿出来 来看每个用户的数据(黑客也不可能拿到你的手机)。但是如果黑客捡到 你的手机 ，都不用登陆微信 就可以 通过微信APP的沙盒 拿到你和小三的偷情聊天记录、能拿到你的银行卡号，你的手机号(很多APP都把手机号、银行卡号、聊天记录 明文保存在沙盒里)。。你是不是会觉得微信 怎么这么low。我们只是拿微信举个例子，微信还不会这么low。 11、黑客 最主要的还是通过网络来获取 他们想要的数据（网络的安全级别是最高的）。如果恰好 你的APP 加密密钥 明文 保存到了沙盒里 或者 你的 数据通信 还没有进行加密，恭喜你，你的数据和裸奔没啥区别。。 有人说：“我就做了个聊天的APP，没啥机密信息。再说 大家连的都是 公司的wifi、4G网络，不会有问题的，所以我的通信才不加密，麻烦。” 举个搞笑的栗子： 你现在在飞机场，连着免费wifi，正在和副总裁在微信里 谈着 价值100个亿的创意的时候，聊天记录已经被 黑客 抓包获取 ，然后卖给竞争对手了。。（只是举个例子，微信的加密是相当安全的，微信很多的通讯还是用的HTTP，但是就算你拿到他们数据，也是无法解密的。这里举例用微信，只是为了方便大家理解。免费wifi确实有可能是黑客设的坑，新闻上经常报道）。 所以不要让自己的数据裸奔。。。 12、代码方面： .1、在release环境下 NSLog 不要打印日志 否则iOS系统日志里都可以查看到，在.pch文件中加下面的几行代码就可以解决。很早大家都这么做了。 1234567#ifdef DEBUG#define NSLog(...) NSLog(__VA_ARGS__)#define debugMethod() NSLog(@"%s", __func__)#else#define NSLog(...)#define debugMethod()#endif 现在很多APP的部分页面开始使用 Swift，在Swift 文件中是允许用 NSLog 的语法来打印，但是 不要这么做，因为 这样 就会导致这段代码在 release环境 中也可以正常输出。通过 PP助手、iTools，可以直接 查看 iOS的系统日志。也可以直接 通过Xcode-Window-Devices - 点最下面的向上的小箭头，来看日志。 所以Swift中打印 还是用 print吧。 .2、AFNetworking 的 allowInvalidCertificates 属性 要设置成 false，validatesDomainName属性 设置成true。否则 HTTPS通信就可以被解密。这块涉及到AFnetworking 去年的通信漏洞 就不详述了。 但是一般开发的 测试环境 的HTTPS 不是CA颁发的，而是自签名证书，访问的也不是域名，而是IP。所以可以在测试环境 忽略证书和域名，代码如下： 1234#ifdef DEBUG manager.securityPolicy.allowInvalidCertificates = YES; manager.securityPolicy.validatesDomainName = NO;#endif 答疑： 像上文中提到的 接口模拟HTTPS 进行通信，基本上是破解不了的。非对称加密毕竟还是 很安全的。 黑客也是有时间成本的，有性价比的。文中多次 写到，可以增加破解的难度，不是这样做了 就一定 不会被破解。 有人会觉得 在 代码中 加密了 反正也 能被破解，那还加啥密，反正没啥卵用。（比如 关键数据 加密 后 存到代码里） 打个比方：我装个防盗门 反正也防不住贼，干脆 就别装门了，反正也没啥卵用。 再比如：有几个房间放着同样价值的东西（账户数据、聊天数据等）。但这几个房间，有的是全封闭防炸弹的，有的就只是一个木门，有的甚至门都是开着的，你会选择哪个。。这就像为什么现在 iOS 系统的越狱速度越来越慢，不是说越狱人员的水平变低了，而是现在越狱的用户越来越少，像盘古这种公司通过越狱获得的盈利也越来越少了，自然投入的精力就会变少。 关键数据 加密 后 存到代码里 这样总比 你直接把 明文保存 到代码中，更难破解，我们要做的是让黑客知道，你要来惹我，你就必须付出更多的时间和精力。 原文]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆向工程 - Reveal、IDA、Hopper、HTTPS抓包等]]></title>
    <url>%2F2017%2F07%2F03%2FiOS%2F17070301.%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%20-%20Reveal%E3%80%81IDA%E3%80%81Hopper%E3%80%81HTTPS%E6%8A%93%E5%8C%85%E7%AD%89%2Findex%2F</url>
    <content type="text"><![CDATA[iOS应用的安全性 常常被大家忽视。iOS 如何做才安全详见《iOS如何做才安全》ipa文件 AppStore里的ipa包 可以通过 iTunes 下载到电脑。iOS8.3以下系统的非越狱的手机上，可以用MAC上的PP助手等软件，直接把手机上的ipa文件(包含沙盒里的存储文件)拷贝到电脑。 如果是越狱手机，都可以用PP助手、itools直接把ipa导出到电脑，并且可以用PP助手、iExplorer、itools这些工具 查看 iOS的系统目录。 MAC上安装 iExplorer软件，用iExplorer 可以看到 手机（非越狱也可以） 在 iTunes上备份的内容。 如果你在帮测试美女的手机 调试问题的时候， 在 iTunes上设置 “连接次iPhone时自动同步”(或者点击 备份到本地电脑),默认该手机上的照片、短信等内容都会备份到你的电脑上，用 iExplorer 就可以看到 这位 美女的隐私。 曾经有次不小心看到同事的隐私信息，所以现在都比较注意这块，避免引发误会。 拿到ipa文件后，解压缩，得到.app文件，右键显示包内容，可以看到里面的app中的图片、js、plist、静态H5页 等资源。 比如 你要 用微信里的默认表情包，解压微信的ipa包就可以获取到。 iOS的系统目录和MAC上的都类似（类unix系统）。iOS系统的目录图： 沙盒 中的数据iPhone上 计算器的沙盒： .app文件:应用程序本身的数据，打包时候的一些资源文件（如：图片、plist等文件）、可执行文件。这个目录不会被iTunes同步。 Documents ：存储不可再生 的关键数据。不会被iTunes同步 Library：保存配置文件和其他一些文件。NSUserDefault 会存储到 Library下的Preferences中 的 plist文件中。可以直接打开，所以 也不要在 NSUserDefault 中存一些 关键数据，或者 存储的时候 进行 AES等方式的加密。 Library/Caches可以用来保存可再生的数据，比如网络请求，用户需要负责删除对应文件。 这个目录（除了Library/Caches外）会被iTunes同步 tmp：临时文件。不需要的时候，手动将其内文件删除。（当应用不再运行的时候，系统可能会将此目录清空。）这个目录不会被iTunes同步 存到沙盒的数据都是不安全的，关键数据一定 要做加密存储。 Reveal 工具：查看 任何APP 的UI结构 不越狱的手机 可以用 Reveal 来查看自己APP的UI结构。不能查看其他APP的UI结构。这里就不再描述了。 越狱手机 上可以查看 任何APP的UI结构。 在越狱的手机上，在 Cydia 搜索并安装 Reveal Loader，如果搜索不到。就 点下面的“软件源”，选择“BigBoss”,选择“全部软件包”，点右边R的字母，去一个个找到 Reveal Loader，放心吧，你一定能找到的，我用的iOS7.1的系统测试的，没问题。 安装完成后，打开“设置”页面，下拉到最底部，点击“Reveal” 点击 Enabled Applictions 。然后选中 你想分析的APP。 确保iOS和OSX在同一个IP网段内。打开想分析的 APP，如果该APP已经启动，则关闭后再次启动 打开MAC上的 Reveal，选中 左上方列表里的 APP，比如QQ： 如果 Reveal 左上方 一直显示：No Connection。说明iPhone上的 Reveal Loader 没安装成功，需要配置一下。 首先从MAC上 用PP助手或 iTools 查看“文件系统（系统）”–&gt; Library文件夹，看 Library文件夹下面有没有 RHRevealLoader 文件夹，如果没有，就 右键 新建文件夹，并修改名字为：RHRevealLoader。 在Mac 下打开已经安装的Reveal，选择标题栏Help下的Show Reveal Library in Finder 下的 iOS library 选项，将会显示如下界面： 将libReveal.dylib 文件通过PP助手拷贝到刚才创建的RHRevealLoader文件夹下，就可以了。 然后 从手机上打开APP， 再 打开 MAC上的 Reveal 软件，左上方 就会出来 相关APP的选项。 再发个 淘宝中的天猫模块吧： 反编译工具：IDA从AppStore下载的ipa都是加壳的(苹果 把开发者上传的ipa进行了加壳再放到AppStore中)，加壳的ipa要先去壳，可以用clutch、dumpdecrypted、使用gdb调试 等解密去壳工具，这个我们后面再说。 如果你有越狱手机，可以直接 从 PP助手上下载ipa包，这个就是 脱壳后的。。 现在 我们先反编译 自己的APP，通过Xcode打包的APP 都是没加壳的，可以直接用来反编译。 新建一个项目，在 ViewController 的 viewDidLoad 方法里 加 几句代码。 12345678- (void)viewDidLoad &#123; [super viewDidLoad]; UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(50, 70, 200, 100)]; label.text = @"CeShiLabel007"; label.backgroundColor = [UIColor redColor]; [self.view addSubview:label];&#125; 复制代码将项目 打包，生成 ipa文件，下面我们就用IDA分析一下 ipa。 将ipa文件 解压后 得到.app文件： 下载IDA，并打开： 点击“New”按钮，选择刚才 解压的 .app文件。一路 点击“OK”或者“YES” 就可以了。 打开界面后，双击左侧的 viewDidLoad： 可以看出：代码中的 “CeShiLabel007” 字符串 完全可以反编译出来。所以尽量不要在代码里放一些 关键 的数据。可以通过接口来获取。或者 把 数据进行加密。 从上面的界面中 ，按下键盘的F5，可以 把汇编转成C语言代码。可读性很高。。 你如果试了 就发现你的F5不管用啊，那是因为 F5是一个插件Hex-Rays.Decompiler 的快捷键，这个插件是收费的、收费的。 反编译工具：Hopper Disassembler下载 Hopper Disassembler软件。打开ipa解压的.app。 或者直接 把.app拖进去。 双击viewDidLoad： 可以看到 汇编代码， “CeShiLabel007” 字符串、setText方法 等。 点击右上角的 if(a) f(x)图标： 会弹出 类似源代码的 伪编码： 代码中可以清楚的看到 处理的逻辑。简单易懂，和看源代码没太大区别。。 下面 是我从越狱手机的PP助手上下载的 微信 的ipa 进行反编译,看下里面的 QQContactInfoViewController 页面 的 viewDidLoad方法里的代码 怎么写的， 截图： 如果 你把从 AppStore下载的 ipa包直接拖到 IDA或Hopper里，看到的就是乱码，刚才已经说过了。AppStore的ipa是加过壳的 。如图： 抓包-httpsCharles 老版本和 新版本 抓取https 的配置 不一样。。 HTTP抓包： 打开Charles程序 查看Mac电脑的IP地址，如192.168.1.7 打开iOS设置，进入当前wifi连接，设置HTTP代理Group，将服务器填为上一步中获得的IP，即192.168.1.7，端口填8888 iOS设备打开你要抓包的app进行网络操作 Charles弹出确认框，点击Allow按钮即可 HTTPS 老版本抓包： 下载Charles证书，解压后导入到iOS设备中（将crt文件作为邮件附件发给自己，再在iOS设备中点击附件即可安装；也可上传至dropbox之类的网盘，通过safari下载安装） 在Charles的工具栏上点击设置按钮，选择Proxy Settings… 切换到SSL选项卡，选中Enable SSL Proxying 这一步跟Fiddler不同，Fiddler安装证书后就可以抓HTTPS网址的包了，Charles 还 需要在上一步的SSL选项卡的Locations表单填写要抓包的域名和端口，点击Add按钮，在弹出的表单中Host填写域名，比如填api.instagram.com，Port填443 HTTPS 新版本抓包： Charles新版本 的 Proxy Settings 选项里是没有 SSL选项卡的。在左侧的域名上点右键：Enable SSL Proxying，就可以用了。 然后 点击APP，会看到HTTPS解密的json数据。如果接口返回的数据 本身进行了加密，那你看到的还是乱码。 六、https - iOS 的代码如何写 2015年4月末，网爆流行IOS网络通信库AFNetworking SSL漏洞，影响银联、中国银行、交通银行在内的2.5万个IOS应用，我来看下 各种网络写法对应的问题。 1、信任任何证书。在 AFNetworking 中 定义 allowInvalidCertificates 为true，表示 忽略所有证书。 123AFHTTPRequestOperationManager * manager = [AFHTTPRequestOperationManager manager];manager.securityPolicy.allowInvalidCertificates = YES; 这种情况下 用我们上面讲的方法，用Charles很容易 破解HTTPS加密的数据。 这种情况，一般是 因为 测试环境 用的不是 CA发的证书，需要忽略掉证书，所以把 allowInvalidCertificates 设为了 true。这个可以用 #ifdef DEBUG 来进行设置。 123#ifdef DEBUGmanager.securityPolicy.allowInvalidCertificates = YES;#endif 2、信任证书管理机构（CA）颁发的证书。 CA颁发的证书，据说这类的证书只需50美元就能买到。此类问题出在AFNetworking 2.5.2及之前的版本，是AF的漏洞（详见新闻）。如果某IOS APP使用了此版本的开源通信库，在不安全Wifi网络中的，黑客 只要使用CA颁发的证书就可以对该APP的HTTPS加密数据进行监听或者篡改。 这个需要升级到 AFNetworking 最新版本，正好最新版本也声明兼容IPv6。 3、信任合法的证书、服务器和客户端双向认证。 这两种也都有办法破解，详见：Bypassing OpenSSL Certificate Pinning in iOS Apps、http://drops.wooyun.org/tips/7838 要正确的使用HTTPS才不会出现上面的问题。接口也一定要用自己的方式进行加密 才真正的放心，把小命完全放到对方(HTTPS)手里，命运就只能靠别人来摆布。。 原文]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入解构iOS的Block闭包实现原理]]></title>
    <url>%2F2017%2F06%2F28%2FiOS%2F17062804.%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%84iOS%E7%9A%84Block%E9%97%AD%E5%8C%85%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2Findex%2F</url>
    <content type="text"><![CDATA[在iOS4出来后，苹果公司在OC中推出了block机制(也许更早就有了)。并且在后续的版本中大量的推广和使用了这项技术，比如对视图动画API的改版，比如GCD技术等等。block技术并不是什么新技术，他的本质就是闭包功能在iOS上的实现而已。而闭包功能在其他很多语言中都有实现，比如JAVA中接口的匿名实现。用闭包可以解决那些执行逻辑和上下文环境解耦的场景，如果从设计模式的角度来考虑的话闭包就是一种策略模式(Strategy)的实现。 本文并不探讨如何应用block，而是探讨OC的block机制是如何实现的。从代码的角度来说block的出现和我们平时基于函数和类方法的编程方式不太一致，有时候甚至不好去理解，因为他可以在我们的代码块中定义代码块，而且新定义的代码块又不会按函数内的指令顺序去执行。我们可以大胆的设想，如果是要你去实现一套block机制，你会怎么去做？这也是本文要探讨的东西，只有你知道了OC实现block的内幕，你才能够更好的利用他。 写这篇文章来分析原理时我隐去了一些细节，而且有些结构体的定义也和真实的有差异，但是总体是正确的，目的是为了更好的了解到本质的东西。我们先来看下面一段含有block的OC代码： 123456789101112131415161718192021//文件test.m#import void test()&#123; //下面分别定义各种类型的变量 int a = 10; //普通变量 __block int b = 20; //带__block修饰符的block普通变量 NSString *str = @"123"; __block NSString *blockStr = str; //带__block修饰符的block OC变量 NSString *strongStr = @"456"; //默认是__strong修饰的OC变量 __weak NSString *weakStr = @"789"; //带__weak修饰的OC变量 //定义一个block块并带一个参数 void (^testBlock)(int) = ^(int c)&#123; int d = a + b + c; NSLog(@"d=%d, strongStr=%@, blockStr=%@, weakStr=%@", d, strongStr, blockStr, weakStr); &#125;; a = 20; //修改值不会影响testBlock内的计算结果 b = 40; //修改值会影响testBlock内的计算结果。 testBlock(30); //执行block代码。&#125; 上面的代码片段中，我们分别定义了： 不带修饰符的基本类型变量a 带__block修饰符的block变量b和blockStr 默认带__strong修饰符的变量strongStr 带__weak修饰符的变量weakStr 这些修饰符关键字的使用会对block块内的代码在运行时产生不同的影响。就上面的代码片段而言当我们在编译时，编译器到底做了什么处理？如果能够了解到编译器的编译过程，那么对我们掌握其实现机制就非常有帮助。幸好我们可以借助命令来看到这个中间的过程，您可以打开终端控制台，并到test.m文件所在的路径下执行如下的命令： clang -rewrite-objc test.mclang这个命令会在相同目录下产生一个test.cpp的文件。这个文件是OC代码的C++实现版本，因为我们知道C++是不支持闭包技术的，因此您可以通过查看test.cpp这个文件来了解到OC中的闭包技术到底是如何用函数和结构体来实现的。(注意上面的命令执行时会报错，提示不支持__weak类型的定义，我目前没有找到解决方法，暂时是把__weak修饰符去掉)。我们可以先来看看test.cpp的部分实现: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109struct __Block_byref_b_0 &#123; void * __isa; __Block_byref_b_0 * __forwarding; int __flags; int __size; int b;&#125;;struct __Block_byref_blockStr_1 &#123; void * __isa; __Block_byref_blockStr_1 * __forwarding; int __flags; int __size; void( * __Block_byref_id_object_copy)(void * , void * ); void( * __Block_byref_id_object_dispose)(void * ); NSString * blockStr;&#125;;struct __test_block_impl_0 &#123; struct __block_impl impl; struct __test_block_desc_0 * Desc; int a; NSString * strongStr; NSString * weakStr; __Block_byref_b_0 * b; // by ref __Block_byref_blockStr_1 * blockStr; // by ref __test_block_impl_0(void * fp, struct __test_block_desc_0 * desc, int _a, NSString * _strongStr, NSString * _weakStr, __Block_byref_b_0 * _b, __Block_byref_blockStr_1 * _blockStr, int flags = 0): a(_a), strongStr(_strongStr), weakStr(_weakStr), b(_b - &gt; __forwarding), blockStr(_blockStr - &gt; __forwarding) &#123; impl.isa = &amp; _NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __test_block_func_0(struct __test_block_impl_0 * __cself, int c) &#123; __Block_byref_b_0 * b = __cself - &gt; b; // bound by ref __Block_byref_blockStr_1 * blockStr = __cself - &gt; blockStr; // bound by ref int a = __cself - &gt; a; // bound by copy NSString * strongStr = __cself - &gt; strongStr; // bound by copy NSString * weakStr = __cself - &gt; weakStr; // bound by copy int d = a + (b - &gt; __forwarding - &gt; b) + c; NSLog((NSString * ) &amp; __NSConstantStringImpl__var_folders_d6_rtk49g5s52g_m2sgrvm0b5q00000gn_T_main_5b81f9_mi_3, d, strongStr, (blockStr - &gt; __forwarding - &gt; blockStr), weakStr);&#125;static void __test_block_copy_0(struct __test_block_impl_0 * dst, struct __test_block_impl_0 * src) &#123; _Block_object_assign((void * ) &amp; dst - &gt; b, (void * ) src - &gt; b, 8 /*BLOCK_FIELD_IS_BYREF*/ ); _Block_object_assign((void * ) &amp; dst - &gt; strongStr, (void * ) src - &gt; strongStr, 3 /*BLOCK_FIELD_IS_OBJECT*/ ); _Block_object_assign((void * ) &amp; dst - &gt; blockStr, (void * ) src - &gt; blockStr, 8 /*BLOCK_FIELD_IS_BYREF*/ ); _Block_object_assign((void * ) &amp; dst - &gt; weakStr, (void * ) src - &gt; weakStr, 3 /*BLOCK_FIELD_IS_OBJECT*/ );&#125;static void __test_block_dispose_0(struct __test_block_impl_0 * src) &#123; _Block_object_dispose((void * ) src - &gt; b, 8 /*BLOCK_FIELD_IS_BYREF*/ ); _Block_object_dispose((void * ) src - &gt; strongStr, 3 /*BLOCK_FIELD_IS_OBJECT*/ ); _Block_object_dispose((void * ) src - &gt; blockStr, 8 /*BLOCK_FIELD_IS_BYREF*/ ); _Block_object_dispose((void * ) src - &gt; weakStr, 3 /*BLOCK_FIELD_IS_OBJECT*/ );&#125;static struct __test_block_desc_0 &#123; size_t reserved; size_t Block_size; void( * copy)(struct __test_block_impl_0 * , struct __test_block_impl_0 * ); void( * dispose)(struct __test_block_impl_0 * );&#125;__test_block_desc_0_DATA = &#123; 0, sizeof(struct __test_block_impl_0), __test_block_copy_0, __test_block_dispose_0&#125;;void test() &#123; int a = 10; __attribute__((__blocks__(byref))) __Block_byref_b_0 b = &#123; (void * ) 0, (__Block_byref_b_0 * ) &amp; b, 0, sizeof(__Block_byref_b_0), 20 &#125;; NSString * str = (NSString * ) &amp; __NSConstantStringImpl__var_folders_d6_rtk49g5s52g_m2sgrvm0b5q00000gn_T_main_5b81f9_mi_0; __attribute__((__blocks__(byref))) __Block_byref_blockStr_1 blockStr = &#123; (void * ) 0, (__Block_byref_blockStr_1 * ) &amp; blockStr, 33554432, sizeof(__Block_byref_blockStr_1), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, str &#125;; NSString * strongStr = (NSString * ) &amp; __NSConstantStringImpl__var_folders_d6_rtk49g5s52g_m2sgrvm0b5q00000gn_T_main_5b81f9_mi_1; NSString * weakStr = (NSString * ) &amp; __NSConstantStringImpl__var_folders_d6_rtk49g5s52g_m2sgrvm0b5q00000gn_T_main_5b81f9_mi_2; void( * testBlock)(int) = ((void( * )(int)) &amp; __test_block_impl_0((void * ) __test_block_func_0, &amp; __test_block_desc_0_DATA, a, strongStr, weakStr, (__Block_byref_b_0 * ) &amp; b, (__Block_byref_blockStr_1 * ) &amp; blockStr, 570425344)); a = 20; (b.__forwarding - &gt; b) = 40; ((void( * )(__block_impl * , int))((__block_impl * ) testBlock) - &gt; FuncPtr)((__block_impl * ) testBlock, 30);&#125;static struct IMAGE_INFO &#123; unsigned version; unsigned flag;&#125;_OBJC_IMAGE_INFO = &#123; 0, 2&#125;; 上面的代码对于某些同学来说也许太过晦涩了！ 不过没有关系， 我把上面的代码进行简化和处理， 并去掉了一些次要的东西， 然后简化为如下的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// 每个block变量都会生成一个和OC类内存结构兼容的结构体。下面是_block int b 的结构体定义：struct Block_b &#123; void * isa; //固定为NULL Block_b * forwarding; //指向真正的block对象变量。 int flags; int size; //结构体的size int b; //保存代码中定义的变量值。&#125;;//每个block变量都会生成一个和OC类内存结构兼容的结构体。下面是 __block NString *blockStr 的结构体定义：struct Block_blockStr &#123; void * isa; //固定为NULL Block_blockStr * forwarding; //指向真正的block对象变量 int flags; int size; //结构体的size NSString * blockStr; //保存代码中定义的变量值。&#125;;//每个block块都会生成一个和OC类内存结构兼容的结构体和一个描述这个block块信息描述的结构体struct Block_testBlock &#123; //所有block块的固定部分，这也是一个OC类的内存结构。 Class isa; //block的OC类型 int flags; int reserved; void * funcPtr; //block块函数的地址。 Block_testBlock_Desc * desc; //block的描述信息。 //所有在block代码块内引用的外部数据都会成为结构体内的数据成员。 int a; NSString * strongStr; NSString * __weak weakStr; Block_b * b; Block_blockStr * blockStr; //结构体的构造函数。 Block_testBlock(void * _funcPtr, Block_testBlock_Desc * _desc, int _a, NSString * _strongStr, NSString * _weakStr, struct Block_b * _b, Block_blockStr * _blockStr, int _flags) &#123; isa = &amp; _NSConcreteStackBlock; //根据具体的block类型赋值。 flags = _flags; reserved = 0; funcPtr = _funcPtr; desc = _desc; a = _a; strongStr = _strongStr; weakStr = _weakStr; b = _b - &gt; forwarding; //b保存真实的block变量的地址。 blockStr = _blockStr - &gt; forwarding; //blockStr保存真实的block变量的地址。 &#125;&#125;;//block块信息描述的结构体定义，主要有block对象的尺寸，以及block中函数的参数信息，也就是参数的签名信息。并生成一个全局的常量对象_testBlock_desc_DATAstruct Block_testBlock_Desc &#123; unsigned long reserved; unsigned long size; //块的尺寸 void * rest[1]; //块的参数签名信息&#125;_testBlock_desc_DATA = &#123; 0, sizeof(Block_testBlock), "v12@?0i8"&#125;;//这部分是block块函数体的定义部分，可以看出block的代码块都转化为了普通的函数，并且函数会默认增加一个隐藏的__cself参数，用来指向block对象本身。static void testBlockfn(Block_testBlock * __cself, int c) &#123; //还原函数体内引用外部的数据对象和变量。 Block_b * b = __cself - &gt; b; Block_blockStr * blockStr = __cself - &gt; blockStr; int a = __cself - &gt; a; NSString * __strong strongStr = __cself - &gt; strongStr; NSString * __weak weakStr = __cself - &gt; weakStr; //int d = a + b + c; int d = a + b - &gt; forwarding - &gt; b + c; //注意这里block变量使用方式。 //NSLog(@"d=%d, strongStr=%@, blockStr=%@, weakStr=%@", d, strongStr, blockStr, weakStr); NSLog(@ "d=%d, strongStr=%@, blockStr=%@, weakStr=%@", d, strongStr, blockStr - &gt; forwarding - &gt; blockStr, weakStr);&#125;void test() &#123; int a = 10; //__block int b = 20; Block_b b = &#123; nil, &amp; b, 0, sizeof(struct Block_b), 20 &#125;; // __block NSString *blockStr = @"123"; Block_blockStr blockStr = &#123; nil, &amp; blockStr, 33554432, sizeof(Block_blockStr), @ "123" &#125;; NSString * strongStr = @ "456"; __weak NSString * weakStr = @ "789"; //每个在代码中的block块都会生成对应的OC block对象，这里面用构造函数初始化这个block对象。 Block_testBlock testBlock( &amp; testBlockfn, &amp; _testBlock_desc_DATA, a, strongStr, weakStr, &amp; b, &amp; blockStr, 570425344); a = 20; //这个不会影响到block块内执行时a的值。 // b = 40; 这个赋值会影响到block块内执行时b的值。 b.forwarding - &gt; b = 40; //注意__block类型变量的值的更新方式。 //执行block块其实就是执行block对象里面的函数。 //testBlock(30); testBlock.funcPtr( &amp; testBlock, 30);&#125; 先看函数test内的实现部分，我们发现所有带 __block修饰符的变量的定义由： 12__block int b = 20;__block NSString *blockStr = @"123"; 变为了： 12Block_b b = &#123;nil, &amp;b, 0, sizeof(struct Block_b), 20&#125;;Block_blockStr blockStr = &#123;nil, &amp;blockStr, 33554432, sizeof(Block_blockStr), @"123"&#125;; 也就是说所有定义为__block类型的变量，在编译时都会变为一个个block对象变量。在编译时系统会为每个带__block修饰的变量生成一个和OC类内存结构兼容的结构体： 1234567891011121314151617// 每个block变量都会生成一个和OC类内存结构兼容的结构体。下面是__block int b 的结构体定义：struct Block_b &#123; void *isa; Block_b *forwarding; //指向真正的block对象变量。 int flags; int size; //结构体的size。 int b; //保存代码中定义的变量。&#125;; //每个block变量都会生成一个和OC类内存结构兼容的结构体。下面是 __block NString *blockStr 的结构体定义：struct Block_blockStr &#123; void *isa; Block_blockStr *forwarding; //指向真正的block对象变量。 int flags; int size; NSString * blockStr; //保存代码中定义的变量。&#125;; 上面的两个结构体都有固定的格式，而且也和OC类的内存结构匹配。也就是说当定义__block修饰的变量时，系统会把他转化为一个OC对象。 为什么要把__block定义的变量转变为OC对象呢？这个是和__block这个关键字所表达的意思是一致的，也就是定义为__block类型的变量是不会在block代码块内产生副本的，而是保持唯一性。每个block对象变量的isa都固定设置为nil； 而forwarding则是指向真正操作的block对象变量，如果某个block对象变量只是在一个栈block对象里面被使用则这时候forwarding是指向block对象变量自己，而如果这个block对象变量在一个堆block对象里面被使用则这时候forwarding则是指向一个堆block对象变量的地址。 再来看test函数中的block块的定义部分。从代码中可以发现原先在代码中定义的block块，被拆分为了block对象和全局函数两部分来实现。因此可以看出在iOS内所有定义的block代码块系统在编译时都会转化为个OC对象（NSBlock类是用来描述block代码块的OC类，系统一共支持栈block:NSStackBlock，堆block:NSMallocBlock,全局block:NSGlobalBlock三种类型的block。具体的细节和差异不在本文展开，请大家自行查找相关的资料）。因此在编译时我们会为每个block代码块都生成一个和OC类兼容的结构体，在我们的例子里面的结构体定义如下： 1234567891011121314151617181920212223242526272829303132333435363738//每个block块都会生成一个和OC类兼容的结构体。struct Block_testBlock &#123; //前面5个数据成员在所有block定义中都相同，并且和OC兼容。 Class isa; int flags; int reserved; void *funcPtr; //block块的全局函数的地址。 Block_testBlock_Desc* desc; //block的描述。 //所有在block代码块引用的外部数据都会成为结构体的同名数据成员。 int a; NSString * strongStr; NSString * __weak weakStr; Block_b *b; Block_blockStr *blockStr; //结构体的构造函数。 Block_testBlock(void *_funcPtr, Block_testBlock_Desc *_desc, int _a, NSString * _strongStr, NSString * _weakStr, struct Block_b *_b, Block_blockStr *_blockStr, int _flags) &#123; isa = &amp;_NSConcreteStackBlock; //根据具体的block类型赋值。 flags = _flags; reserved = 0; funcPtr = _funcPtr; desc = _desc; a = _a; strongStr = _strongStr; weakStr = _weakStr; b = _b-&gt;forwarding; //其实就是指向自己 blockStr = _blockStr-&gt;forwarding; &#125;&#125;;//每个block块的描述信息结构体，主要是保存block的尺寸，以及block中函数的参数信息。struct Block_testBlock_Desc &#123; unsigned long reserved; unsigned long size; //块的尺寸 void *rest[1]; //块的参数签名信息&#125;_testBlock_desc_DATA = &#123;0, sizeof(Block_testBlock), "v12@?0i8"&#125;; 可以看出我们定义的block代码块都会生成2个结构体： Block_testBlock用来保存block的信息以及block内部要用到的所有数据。所有block对象结构体的前5个数据成员都是一致的，也就是和OC类的内存结构是兼容的。其中的isa用来保存block的类信息，这里面的类信息会根据block所处的位置的不同而不同。而后面的5个数据成员就是在block代码块内使用外部对象的副本。正是因为每个block对象在编译时保存了代码块内使用代码块外的对象的副本，所以我们才能在后续代码执行时能够访问到这些信息。 Block_testBlock_Desc用来描述这个block的size以及block方法的参数的签名信息。 下面就是Block_testBlock 实例的构造方法： 12//每个在代码中的block块都会生成对应的OC block对象，这里面构造函数初始化这个block对象。Block_testBlock testBlock(&amp;testBlockfn, &amp;_testBlock_desc_DATA, a, strongStr, weakStr, &amp;b, &amp;blockStr, 570425344); 上面可以看出，一旦在代码中出现了block代码块，编译时就会建立一个block对象，然后将block对象关联的函数代码地址、以及使用的外面的数据作为block对象的构造函数的参数来创建这个block对象。 最后我们再来考察block代码的全局函数的实现： 123456789101112131415161718//这部分是block代码函数体的定义部分，可以看见函数默认增加一个隐藏的__cself参数。static void testBlockfn(Block_testBlock *__cself, int c) &#123; //还原函数体内引用外面的变量。 Block_b *b = __cself-&gt;b; Block_blockStr *blockStr = __cself-&gt;blockStr; int a = __cself-&gt;a; NSString *__strong strongStr = __cself-&gt;strongStr; NSString *__weak weakStr = __cself-&gt;weakStr; //int d = a + b + c; int d = a + (b-&gt;forwarding-&gt;b) + c; //NSLog(@"d=%d, strongStr=%@, blockStr=%@, weakStr=%@", d, strongStr, blockStr, weakStr); NSLog(@"d=%d, strongStr=%@, blockStr=%@, weakStr=%@", d, strongStr, blockStr-&gt;forwarding-&gt;blockStr, weakStr); &#125; 上面的代码片段中，可以看出block块全局函数除了定义的int类型参数外，还增加了一个隐藏的参数__cself用来指向block对象。然后在函数体的开始位置把使用的外部数据的副本还原到函数的栈内。这也是为什么我们能在block代码块内用到外面的数据的原因了。这里我们需要进一步考察这几个副本的意义： 对于基本类型a的副本来说就是完全的内存拷贝，因此在block代码块内更新这些数据是不会影响到外面，同时外面的更新也不会影响到里面了。 对于对象类型的strongStr和weakStr而言这个副本只是指针的拷贝而不是所指对象的拷贝，因此在block代码块内能够读取最新的属性和设置新的属性值。 对于__block类型的对象来说，你会发现他也是指针的拷贝，所以也不会产生多份内存副本，同时可以看出对__block类型数据的读取和设置我们都是间接来完成的，因此这里代码块内更新数据能影响外面，同时外面的更新也能影响里面。 好了，所有我要介绍的内容就到这里了，上面就是iOS的block的内部实现机制。我相信通过我上面的介绍能够让你了解到了block在编译时所做的事情，以及能够了解到__block, __weak, __strong各种修饰符的意义和差别。 原文链接]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深究Block的实现]]></title>
    <url>%2F2017%2F06%2F28%2FiOS%2F17062803.%E6%B7%B1%E7%A9%B6Block%E7%9A%84%E5%AE%9E%E7%8E%B0%2Findex%2F</url>
    <content type="text"><![CDATA[先看一下Block使用的语法声明一个block12返回值 （^名称）（参数列表） ＝ ^(参数列表)｛｝；1234int (^name)(int ,int) = ^(int a,int b)&#123; return （a+b）;&#125;;作为一个函数的参数：12345678- (void)testBlock:(NSString *(返回类型) (^)(int a))s（block名字） &#123; NSString *a = s(1);&#125; [self testBlock:^NSString *(int a) &#123; a = 5; return @"1";&#125;]; 然后通过底层代码分析一下block的实现 iOS中有三种block，下文会细说 NSConcreteGlobalBlock;//在全局中定义的 NSConcreteStackBlock; //在局部定义的 NSConcreteMallocBlock;//分配在堆中 先从最简单的看起 1234int main(int argc, char * argv[]) &#123;void (^block)(void) = ^&#123; NSLog(@"1");&#125;; 通过在终端找到这个.m文件，然后clang -rewrite-objc 代码文件名 就可以看到文件夹有个.cpp的文件，本来想变量ViewController的文件，里面用了UIKit库，编译的时候总是显示找不到，于是我编译的main.m文件 编译过来是 block源码 这里先来分析一下（便于理解）： 1234static void _main_block_func_0(struct _main_block_impl_0 *__cself) &#123; NSLog((NSString *)&amp;__NSConstantStringImpl__var_ folders_yq_s_hjnhd12x79wq1ldg1jdr_w0000gn_T_main_50d1d6_mi_0);&#125; 可以看到，这里对应我们代码中的block中的实现，所以可以知道，block使用的匿名函数，实际上被当作一个函数来处理。不过传入的是：一个_main_block_impl_0类型的结构体，里面有一个block_impl的结构体，和一个_main_block_desc_0的结构体。跟着是他们的构造函数。来简单看一下这个_main_block_impl_0结构体吧： isa指向这个block的类型。这里说明这个block是NSConcreteStackBlock类型的。 flag是标志，可以看到，默认构造为0； 还有一个FuncPtr，也就是指向函数地址的指针。 还有一个__main_block_desc_0的结构体， 在下面可以看到这个结构体的初始化 一个是reserverd默认为0， 一个是block_size。是这个impl的size。 所以，这个_main_block_impl_0，我们可以理解为就是一个block实例，里面的成员变量有要执行的函数的指针，和isa（和所有的oc对象一样），还有一个size。 现在看一下main函数里面的内容 1void (*name)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); 这里执行的操作就是：初始化一个block实例，交给我们这么name名字变量，也就是用name这个指针指向这个block实例，执行的时候，直接找到这个block中的指向函数地址的指针。 通过以上可以了解：block的实质，就是一个对象，包含了一个指向函数首地址的指针，和一些与自己相关的成员变量。 接着看一下block访问外部变量是怎么回事，这也是我们最关心的问题。 先来看一下局部变量： 123456int a = 10;int b = 20;void (^block)() = ^ &#123; NSLog(@"%d--%d",a,b);&#125;;block (); block访问局部变量 首先在_main_block_impl_0的定义中看到，block中用到的变量被作为成员变量追加到了结构体中， 123456_main_block_impl_0(void *fp, struct _main_block_desc_0 *desc, int _a, int _b, int flags=0) : a(_a), b(_b) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc;&#125; 在初始化的时候，也需要把a和b的值传入。 1void (**block)() = ((void (*)())&amp;_main_block_impl_0((void *)_main_block_func_0, &amp;_main_block_desc_0_DATA, a, b)); 这里看到，在初始化的时候，把a，b值传入来初始化一个_main_block_impl_0结构体。这里需要注意，传入的是a和b的值，所以我们要在结构体中改变a和b是无效的。并且编译会报错，如果要在block中改变里面的值。有以下几种方法 第一种方法是静态变量，全局变量 直接上代码吧 12345678910111213int global_val = 1;static int static_global_val = 2;int main(int argc, char * argv[]) &#123; static int static_val = 3; void (^block)() = ^ &#123; global_val = 10; static_global_val = 20; static_val = 30; &#125;; NSLog(@"%d-%d-%d", global_val, static_global_val, static_val); block(); NSLog(@"%d-%d-%d", global_val, static_global_val, static_val);&#125; 然后rewrite一下 访问全局变量 因为这个_main_block_func_0能直接访问静态变量，所以可以直接访问这个变量的值，也可以改变，不用担心在调用这个函数的时候，全局变量访问不到，导致错误。所以这里面在调用全局变量的时候，就是很普通的调用全局变量，没有什么不同。 局部静态变量则传的是一个指针进来。因为不用担心它在函数结束时或者其他什么地方被释放，所以可以放心的访问这个值。 123global_val = 10;static_global_val = 20;(*static_val) = 30; 改变的是这个指针指向的值 1void (*block)() = ((void (*)())&amp;__main_block_impl_0((void *)_main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_val)); 可以看到，这里传的是指针。 _main_block_func_0的作用域在main函数之外，要访问这个变量，就只能传指针。 第二种方法是给参数加__block属性 12345678910int main(int argc, char * argv[]) &#123; __block int block_val = 3; void (^block)() = ^ &#123; block_val = 30; &#125;; NSLog(@"%d",block_val); block (); NSLog(@"%d",block_val); NSLog(@"%@",block);&#125; __block参数 可以看到里面比其他多了一个这样的结构体_Block_byref_block_val_0 里面有： __isa初始化为0， __forwarding;//持有该实例自身的的指针 int __flags;为0 int __size; int block_val;//存放这个变量的值 原来是把一个局部变量，封装成了一个结构体 赋值的时候直接给这个结构体中的这个值赋值 (block_val-&gt;__forwarding-&gt;block_val) = 30; 所以，在访问这个变量的时候，其实在访问这个结构体的这个变量。 关于__forwarding的作用请不要着急。 Block有三种类型： NSConcreteGlobalBlock;//在全局中定义的 NSConcreteStackBlock; //在局部定义的 NSConcreteMallocBlock;//分配在堆中 设置在栈上的block，当“name这个名字变量”作用域结束时，block变量也会废弃。 所以，iOS提供了将block结构体和_block变量，复制到堆上的方法。即使block的name变量结束，那么堆上的block还可以继续访问。 而此时，_block变量结构体中的__forwarding变量可以实现，无论在堆上还是在栈上。都可以正确访问_block变量。可以理解，当把_block变量复制到堆上的时候，__forwarding就指向堆里中的自己。所以无论是访问栈中自己，还是堆中的自己，最终访问都是堆中的这个值。 一个Block对_block的内存管理方式与 ARC机制完全相同。而_main_block_desc 中的copy和dispose就是这个 __block的retain和release操作。 那什么block在时候会复制到堆呢？ 调用block的copy方法。 block作为函数返回值返回时。 block调用外面的_strong的id的类时，或用_block时。 方法中，用usingblock或者GCD中的API时。 在局部函数里，定义block时，打印出来还是NSConcreteGlobalBlock类型的 只要用了外部变量，不管是assign还是week还是strong类型的，打印出来都是NSConcreteMallocBlock类型的。 所以我猜测这会不会是苹果新版的改进，为了block在访问无效的变量，直接把block拷贝到堆上，从而也拷贝一份变量。或许是我忽略了中间的某个步骤 其实到了这里，不用再描述，也知道为什么会发生死循环，又怎么解决了。当在block中用self的时候，block拷贝到堆上，首先，在栈上的这个block有一个持有者，是name这个变量。当name这个变量作用域之外，栈上这个block就release了。，那么当block拷贝到堆上的时候，block有一个持有者是self，那么block在拷贝时，它的变量一个self指针，也会拷贝，而self又指向这个block，block持有self，self持有block，两者都不会释放。要打破这个循环，需要将self置为__week,就算拷贝一个week指针，那也不影响self的引用计数。 原文]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C中的Block]]></title>
    <url>%2F2017%2F06%2F28%2FiOS%2F17062802.Objective-C%E4%B8%AD%E7%9A%84Block%2Findex%2F</url>
    <content type="text"><![CDATA[相关概念在这篇笔记开始之前，我们需要对以下概念有所了解。操作系统中的栈和堆 注：这里所说的堆和栈与数据结构中的堆和栈不是一回事。 我们先来看看一个由C/C++/ObjC编译的程序占用内存分布的结构： 栈区（stack）：由系统自动分配，一般存放函数参数值、局部变量的值等。由编译器自动创建与释放。其操作方式类似于数据结构中的栈，即后进先出、先进后出的原则。 例如：在函数中申明一个局部变量int b;系统自动在栈中为b开辟空间。 堆区（heap）：一般由程序员申请并指明大小，最终也由程序员释放。如果程序员不释放，程序结束时可能会由OS回收。对于堆区的管理是采用链表式管理的，操作系统有一个记录空闲内存地址的链表，当接收到程序分配内存的申请时，操作系统就会遍历该链表，遍历到一个记录的内存地址大于申请内存的链表节点，并将该节点从该链表中删除，然后将该节点记录的内存地址分配给程序。 例如：在C中malloc函数 12char p1; p1 = (char)malloc(10); 但是p1本身是在栈中的。 链表：是一种常见的基础数据结构，一般分为单向链表、双向链表、循环链表。以下为单向链表的结构图： 单向链表是链表中最简单的一种，它包含两个区域，一个信息域和一个指针域。信息域保存或显示关于节点的信息，指针域储存下一个节点的地址。 上述的空闲内存地址链表的信息域保存的就是空闲内存的地址。 全局区/静态区：顾名思义，全局变量和静态变量存储在这个区域。只不过初始化的全局变量和静态变量存储在一块，未初始化的全局变量和静态变量存储在一块。程序结束后由系统释放。 文字常量区：这个区域主要存储字符串常量。程序结束后由系统释放。 程序代码区：这个区域主要存放函数体的二进制代码。 下面举一个前辈写的例子： 1234567891011121314//main.cppint a = 0; // 全局初始化区char *p1; // 全局未初始化区main &#123; int b; // 栈 char s[] = "abc"; // 栈 char *p2; // 栈 char *p3 = "123456"; // 123456\0在常量区，p3在栈上 static int c =0； // 全局静态初始化区 p1 = (char *)malloc(10); p2 = (char *)malloc(20); // 分配得来的10和20字节的区域就在堆区 strcpy(p1, "123456"); // 123456\0在常量区，这个函数的作用是将"123456" 这串字符串复制一份放在p1申请的10个字节的堆区域中。 // p3指向的"123456"与这里的"123456"可能会被编译器优化成一个地址。&#125; strcpy函数 原型声明：extern char *strcpy(char* dest, const char *src); 功能：把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间。 结构体（Struct）在C语言中，结构体(struct)指的是一种数据结构。结构体可以被声明为变量、指针或数组等，用以实现较复杂的数据结构。结构体同时也是一些元素的集合，这些元素称为结构体的成员(member)，且这些成员可以为不同的类型，成员一般用名字访问。 我们来看看结构体的定义： 1struct tag &#123; member-list &#125; variable-list; struct：结构体关键字。 tag：结构体标签。 member-list：结构体成员列表。 variable-list：为结构体声明的变量列表。 在一般情况下，tag、member-list、variable-list这三部分至少要出现两个。以下为示例： 123456789101112131415161718// 该结构体拥有3个成员，整型的a，字符型的b，双精度型的c// 并且为该结构体声明了一个变量s1// 该结构体没有标明其标签struct &#123; int a; char b; double c;&#125; s1;// 该结构体拥有同样的三个成员// 并且该结构体标明了标签EXAMPLE// 该结构体没有声明变量struct EXAMPLE &#123; int a; char b; double c;&#125;;//用EXAMPLE标签的结构体，另外声明了变量t1、t2、t3struct EXAMPLE t1, t2[20], *t3; 以上就是简单结构体的代码示例。结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针。结构体的变量也可以是指针。 下面我们来看看结构体成员的访问。结构体成员依据结构体变量类型的不同，一般有2种访问方式，一种为直接访问，一种为间接访问。直接访问应用于普通的结构体变量，间接访问应用于指向结构体变量的指针。直接访问使用结构体变量名.成员名，间接访问使用(*结构体指针名).成员名或者使用结构体指针名-&gt;成员名。相同的成员名称依靠不同的变量前缀区分。 1234567891011struct EXAMPLE&#123; int a; char b;&#125;;//声明结构体变量s1和指向结构体变量的指针s2struct EXAMPLE s1, *s2;//给变量s1和s2的成员赋值,注意s1.a和s2-&gt;a并不是同一成员s1.a = 5;s1.b = 6;s2-&gt;a = 3;s2-&gt;b = 4; 最后我们来看看结构体成员存储。在内存中，编译器按照成员列表顺序分别为每个结构体成员分配内存。如果想确认结构体占多少存储空间，则使用关键字sizeof，如果想得知结构体的某个特定成员在结构体的位置，则使用offsetof宏(定义于stddef.h)。 12345678struct EXAMPLE&#123; int a; char b;&#125;;//获得EXAMPLE类型结构体所占内存大小int size_example = sizeof( struct EXAMPLE );//获得成员b相对于EXAMPLE储存地址的偏移量int offset_b = offsetof( struct EXAMPLE, b ); 闭包（Closure）闭包就是一个函数，或者一个指向函数的指针，加上这个函数执行的非局部变量。 说的通俗一点，就是闭包允许一个函数访问声明该函数运行上下文中的变量，甚至可以访问不同运行上文中的变量。 我们用脚本语言来看一下： 1234567891011function funA(callback)&#123; alert(callback());&#125;function funB()&#123; var str = "Hello World"; // 函数funB的局部变量，函数funA的非局部变量 funA（ function（）&#123; return str; &#125; ）；&#125; 通过上面的代码我们可以看出，按常规思维来说，变量str是函数funB的局部变量，作用域只在函数funB中，函数funA是无法访问到str的。但是上述代码示例中函数funA中的callback可以访问到str，这是为什么呢，因为闭包性。 blcok基础知识block实际上就是Objective-C语言对闭包的实现。 block的原型及定义我们来看看block的原型： 1NSString * ( ^ myBlock )( int ); 上面的代码声明了一个block(^)原型，名字叫做myBlock，包含一个int型的参数，返回值为NSString类型的指针。 下面来看看block的定义： 1234myBlock = ^( int paramA )&#123; return [ NSString stringWithFormat: @"Passed number: %i", paramA ];&#125;; 上面的代码中，将一个函数体赋值给了myBlock变量，其接收一个名为paramA的参数，返回一个NSString对象。 注意：一定不要忘记block后面的分号。 定义好block后，就可以像使用标准函数一样使用它了： 1myBlock(7); 由于block数据类型的语法会降低整个代码的阅读性，所以常使用typedef来定义block类型。例如，下面的代码创建了GetPersonEducationInfo和GetPersonFamilyInfo两个新类型，这样我们就可以在下面的方法中使用更加有语义的数据类型。 12345678910// Person.h#import "Person.h" // Define a new type for the blocktypedef NSString * (^GetPersonEducationInfo)(NSString *);typedef NSString * (^GetPersonFamilyInfo)(NSString *);@interface Person : NSObject- (NSString *)getPersonInfoWithEducation:(GetPersonEducationInfo)educationInfo andFamily:(GetPersonFamilyInfo)familyInfo;@end 我们用一张大师文章里的图来总结一下block的结构： 将block作为参数传递12345678// .h-(void) testBlock:( NSString * ( ^ )( int ) )myBlock;// .m-(void) testBlock:( NSString * ( ^ )( int ) )myBlock&#123; NSLog(@"Block returned: %@", myBlock(7) );&#125; 由于Objective-C是强制类型语言，所以作为函数参数的block也必须要指定返回值的类型，以及相关参数类型。 2.3 闭包性 上文说过，block实际是Objc对闭包的实现。 我们来看看下面代码： 1234567891011121314151617181920void logBlock( int ( ^ theBlock )( void ) )&#123; NSLog( @"Closure var X: %i", theBlock() );&#125;int main( void )&#123; NSAutoreleasePool * pool; int ( ^ myBlock )( void ); int x; pool = [ [ NSAutoreleasePool alloc ] init ]; x = 42; myBlock = ^( void ) &#123; return x; &#125;; logBlock( myBlock ); [ pool release ]; return EXIT_SUCCESS;&#125; 上面的代码在main函数中声明了一个整型，并赋值42，另外还声明了一个block，该block会将42返回。然后将block传递给logBlock函数，该函数会显示出返回的值42。即使是在函数logBlock中执行block，而block又声明在main函数中，但是block仍然可以访问到x变量，并将这个值返回。 注意：block同样可以访问全局变量，即使是static。 block中变量的复制与修改对于block外的变量引用，block默认是将其复制到其数据结构中来实现访问的，如下图： 通过block进行闭包的变量是const的。也就是说不能在block中直接修改这些变量。来看看当block试着增加x的值时，会发生什么： 12345myBlock = ^( void )&#123; x++; return x;&#125;; 编译器会报错，表明在block中变量x是只读的。 有时候确实需要在block中处理变量，怎么办？别着急，我们可以用__block关键字来声明变量，这样就可以在block中修改变量了。 基于之前的代码，给x变量添加__block关键字，如下： 1__block int x; 对于用__block修饰的外部变量引用，block是复制其引用地址来实现访问的，如下图： 编译器中的blockblock的数据结构定义我们通过大师文章中的一张图来说明： 上图这个结构是在栈中的结构，我们来看看对应的结构体定义： 123456789101112131415struct Block_descriptor &#123; unsigned long int reserved; unsigned long int size; void (*copy)(void *dst, void *src); void (*dispose)(void *);&#125;;struct Block_layout &#123; void *isa; int flags; int reserved; void (*invoke)(void *, ...); struct Block_descriptor *descriptor; /* Imported variables. */&#125;; 从上面代码看出，Block_layout就是对block结构体的定义： isa指针：指向表明该block类型的类。 flags：按bit位表示一些block的附加信息，比如判断block类型、判断block引用计数、判断block是否需要执行辅助函数等。 reserved：保留变量，我的理解是表示block内部的变量数。 invoke：函数指针，指向具体的block实现的函数调用地址。 descriptor：block的附加描述信息，比如保留变量数、block的大小、进行copy或dispose的辅助函数指针。 variables：因为block有闭包性，所以可以访问block外部的局部变量。这些variables就是复制到结构体中的外部局部变量或变量的地址。 block的类型block有几种不同的类型，每种类型都有对应的类，上述中isa指针就是指向这个类。这里列出常见的三种类型： _NSConcreteGlobalBlock：全局的静态block，不会访问任何外部变量，不会涉及到任何拷贝，比如一个空的block。例如： 12345#include int main()&#123; ^&#123; printf("Hello, World!\n"); &#125; (); return 0;&#125; _NSConcreteStackBlock：保存在栈中的block，当函数返回时被销毁。例如： 123456#include int main()&#123; char a = 'A'; ^&#123; printf("%c\n",a); &#125; (); return 0;&#125; _NSConcreteMallocBlock：保存在堆中的block，当引用计数为0时被销毁。该类型的block都是由_NSConcreteStackBlock类型的block从栈中复制到堆中形成的。例如下面代码中，在exampleB_addBlockToArray方法中的block还是_NSConcreteStackBlock类型的，在exampleB方法中就被复制到了堆中，成为_NSConcreteMallocBlock类型的block： 12345678910111213void exampleB_addBlockToArray(NSMutableArray *array) &#123; char b = 'B'; [array addObject:^&#123; printf("%c\n", b); &#125;];&#125;void exampleB() &#123; NSMutableArray *array = [NSMutableArray array]; exampleB_addBlockToArray(array); void (^block)() = [array objectAtIndex:0]; block();&#125; 总结一下： _NSConcreteGlobalBlock类型的block要么是空block，要么是不访问任何外部变量的block。它既不在栈中，也不在堆中，我理解为它可能在内存的全局区。 _NSConcreteStackBlock类型的block有闭包行为，也就是有访问外部变量，并且该block只且只有有一次执行，因为栈中的空间是可重复使用的，所以当栈中的block执行一次之后就被清除出栈了，所以无法多次使用。 _NSConcreteMallocBlock类型的block有闭包行为，并且该block需要被多次执行。当需要多次执行时，就会把该block从栈中复制到堆中，供以多次执行。 编译器如何编译我们通过一个简单的示例来说明： 123456789101112typedef void(^BlockA)(void);__attribute__((noinline))void runBlockA(BlockA block) &#123; block();&#125;void doBlockA() &#123; BlockA block = ^&#123; // Empty block &#125;; runBlockA(block);&#125; 上面的代码定义了一个名为BlockA的block类型，该block在函数doBlockA中实现，并将其作为函数runBlockA的参数，最后在函数doBlockA中调用函数runBloackA。 注意：如果block的创建和调用都在一个函数里面，那么优化器(optimiser)可能会对代码做优化处理，从而导致我们看不到编译器中的一些操作，所以用attribute((noinline))给函数runBlockA添加noinline，这样优化器就不会在doBlockA函数中对runBlockA的调用做内联优化处理。 我们来看看编译器做的工作内容： 1234567891011121314151617181920212223__attribute__((noinline))void runBlockA(struct Block_layout *block) &#123; block-&gt;invoke();&#125;void block_invoke(struct Block_layout *block) &#123; // Empty block function&#125;void doBlockA() &#123; struct Block_descriptor descriptor; descriptor-&gt;reserved = 0; descriptor-&gt;size = 20; descriptor-&gt;copy = NULL; descriptor-&gt;dispose = NULL; struct Block_layout block; block-&gt;isa = _NSConcreteGlobalBlock; block-&gt;flags = 1342177280; block-&gt;reserved = 0; block-&gt;invoke = block_invoke; block-&gt;descriptor = descriptor; runBlockA(&amp;block);&#125; 上面的代码结合block的数据结构定义，我们能很容易得理解编译器内部对block的工作内容。 copy()和dispose()上文中提到，如果我们想要在以后继续使用某个block，就必须要对该block进行拷贝操作，即从栈空间复制到堆空间。所以拷贝操作就需要调用Block_copy()函数，block的descriptor中有一个copy()辅助函数，该函数在Block_copy()中执行，用于当block需要拷贝对象的时候，拷贝辅助函数会retain住已经拷贝的对象。 既然有有copy那么就应该有release，与Block_copy()对应的函数是Block_release()，它的作用不言而喻，就是释放我们不需要再使用的block，block的descriptor中有一个dispose()辅助函数，该函数在Block_release()中执行，负责做和copy()辅助函数相反的操作，例如释放掉所有在block中拷贝的变量等。 总结以上内容是我学习各大师的文章后对自己学习情况的一个记录，其中有部分文字和代码示例是来自大师的文章，还有一些自己的理解，如有错误还请大家勘误。 原文]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中block类型大全]]></title>
    <url>%2F2017%2F06%2F28%2FiOS%2F17062801.iOS%E4%B8%ADblock%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%85%A8%2Findex%2F</url>
    <content type="text"><![CDATA[typedef的block 作为属性的block 作为变量的block 作为方法变量入参的block 作为方法参数的block 无名block 内联函数的block 递归调用的block 作为方法返回值的block 作为函数名的block(太过奇葩,完全不知道怎么用-_-!) 原文]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Right Way to Architect iOS App with Swift]]></title>
    <url>%2F2017%2F06%2F26%2FiOS%2F17062602.The%20Right%20Way%20to%20Architect%20iOS%20App%20with%20Swift%2Findex%2F</url>
    <content type="text"><![CDATA[关于 iOS 架构的文章感觉已经泛滥了，前一阵正好 Android 官方推了一套 App Architecture ，于是就在想，对于 iOS 来说，怎样的架构才是最适合的。带着这个问题，我开始了探索。Why Architecture Matters?这是第一个也是最重要的问题，为什么会出现各种 Architecture Pattern？真的那么重要么？我们来想一下，无论是做一个 App 还是搭一套后台系统，如果是一次性的，今天用完明天就可以扔掉，那么怎么快怎么来，代码重复、代码逻辑、代码格式统统不重要。 这种场景比较适合黑客马拉松，而真实情况往往是我们的代码需要上线，要对用户负责，而一套好的架构会让这些事情变得更加容易。 好的架构简洁且整洁 说到架构，往往会想到建筑，软件架构跟建筑不同的点是软件架构会随着时间的推移进行演进，而实体建筑则没这个特性。抛开时间维度，这二者还是有一定的相似性的。 好的架构容易催生好的代码，就像住在干净整洁的房子里，会下意识地让其中的家具、电器、摆饰等也井井有条。 好的架构让代码更加容易维护不容易维护的代码往往有这么几个特点： 抽象程度低 职责不明确 喜欢走捷径 好的架构能对 2 和 3 有一定的作用，对于第 1 点还是要看程序员的能力和经验。 抽象程度低这样的代码往往是命令式编程产生的，也就是像 CPU 那样的思考方式，把产品经理的需求直观地翻译成代码，而不对其中的共性、本质进行抽离和抽象，时间一长就容易看不懂其中的逻辑，需求一变就要改核心代码。 比如下面这段代码，不知道具体要完成什么任务。 职责不明确这也是产生「一大坨代码」的原因之一，就像 MVC 模式里，没有说明用户的操作应该在哪里处理，业务逻辑放在什么地方，这样就容易走捷径，怎么方便怎么来，而越是方便到后来就越容易出问题。 喜欢走捷径这是我们的天性，毕竟能够更快更方便地达到目标，为什么不做呢？ 比如我们都知道「通知」用起来很方便，所有涉及到单向数据传递的地方都可以使用，比如 Cell 通过通知向 VC 传递点击事件信息、Model 通过通知向 VC 传递数据信息、VC 之间通过通知进行解耦等等。 又比如可以很方便地在 VC 存储状态信息，慢慢地 VC 里这些状态变量就多了起来，到后来要维护这些变量就变得非常困难，出了问题也不好排查。 Clojure 的作者 Rich Hickey 有一个非常著名的 Simple Made Easy 分享 Simple is often erroneously mistaken for easy. “Easy” means “to be at hand”, “to be approachable”. “Simple” is the opposite of “complex” which means “being intertwined”, “being tied together”. Simple != easy. 好的架构能够覆盖大多数场景产品经理：老板说要做一个插座，具体怎么实现我不管，下周一就要。拿到这个需求之后，你觉得很简单，完美符合需求，就像这样： 可是好景不长，老板新买了一个电脑，只支持两相的插座，而且现在就要，作为工程师，你不能被这么简单朴实的需求难倒，于是稍微动了下脑筋，就出了一个解决方案： 虽然丑陋，但是可以工作。但我们的目标不只是可以工作（紧急情况除外），更要优雅地工作。 举一个现实的例子，比如页面间支持通过 Router 进行跳转，但有一天发现有页面间通信的需求，然后就会出来一些 trick 的解决方案，比如发通知或者给 Router 加一个 - (id)objectForURL: 的方法，本质上跟上图的解决方案没什么区别。 好的架构能够提升开发效率，方便定位问题好的架构能够支持多人并行开发、一定程度的代码复用、单元测试，出了问题能比较方便地找到原因。这几点是架构要解决的主要问题。 当前的状态目前主流的主要有 MVC 和 MVVM，VIPER 用的会少一些，它们之间的优劣对比这里就不展开了，可以查看这篇文章来了解：iOS 架构模式 - 简述 MVC, MVP, MVVM 和 VIPER (译) - Coding 博客 简单总结下： MVC 模式过于简单，定的标准过于粗放， 容易滋生捷径。 MVVM 会好很多，但场景的覆盖还不够全，比如缺少页面间跳转／通信、数据获取等。 VIPER 更加细致，但有点臃肿。 How to Define “Right”每种架构都有自己的特点，如果要定义「Right」的话，至少要符合一些标准，以下是我整理的觉得比较重要的几条： 尽量简单 结构清晰 职责明确 符合 GUI 编程的特点 尽量简单简单的事物容易理解，也比较容易接受，用爱因斯坦的话来说「尽量简单，但不要过于简单」。VIPER 其实已经挺完善的了，但就是有点复杂，可以看这篇文章感受下。 结构清晰清晰的结构让外人也能很快地知道每个目录是做什么的，里面的文件起着怎样的作用，自己维护起来也方便。 职责明确也就是 Separation of Concern ，每个单元只需要关心自己的事情，跟外部尽量解耦，这样无论是对代码复用和测试都会很有帮助。 符合 GUI 编程的特点GUI 编程和其他的非界面编程还是有差异的，对 GUI 编程的特点进行合适地抽象，并在此基础上形成的架构才更有「对」的感觉。 我比较认同 view = render(state) + handle(event) 这个定义，view 本身只做两件事，给 state 包一层漂亮的外衣，同时对用户的操作做出响应。 Inspiring差不多心里有谱了，现在来看看相关领域的架构大概是怎样的，找点启发。 Android ArchitectureAndroid 最近出了一套官方推荐的架构，挺细致的，主要的流程如下图所示 大意就是 ViewModel 通过调用 Repository 从 Model 或 Remote 中获取数据，然后放到内置的 LiveData 里，而 LiveData 在 Activity 初始化时即被绑定，因此当 LiveData 变化时，可以马上反馈到界面。 当用户操作界面时，Activity 会捕获到这些事件，然后调用 ViewModel 的特定方法，这些方法最终会导致 LiveData 发生改变，再次反馈到界面。 整体也是 MVVM 的模式，但也有自己的特点： 通过 LiveData 来做单向绑定。 使用 Repository 来统一数据的交互。 内置 Room 作为持久层。 内置 ViewModel 供使用。 内置 LifeCycle 来简化跟生命周期相关的对象的操作，避免内存泄漏。（比如 ViewModel） 使用 Dagger2 这个依赖注入工具来避免依赖。 Elm Architecture Elm is a functional language that compiles to JavaScript. It competes with projects like React as a tool for creating websites and web apps. Elm has a very strong emphasis on simplicity, ease-of-use, and quality tooling. Elm 是一个主打函数式编程，同时通过强大的编译器来尽量确保没有 runtime error 的编程语言，著名的 Redux 就是受它启发。来感受下它的代码： 12345678910111213141516171819202122import Html exposing (Html, button, div, text)import Html.Events exposing (onClick)main = Html.beginnerProgram &#123; model = 0, view = view, update = update &#125;type Msg = Increment | Decrementupdate msg model = case msg of Increment -&gt; model + 1 Decrement -&gt; model - 1view model = div [] [ button [ onClick Decrement ] [ text "-" ] , div [] [ text (toString model) ] , button [ onClick Increment ] [ text "+" ] ] 主要分为 4 块，model , view , update , message view 展示 model 数据，同时将用户的操作作为 message 抛出。 model 包含了页面所需的所有信息。 当 message 被抛出时，会自动进入到 update 方法，update 返回的新 model 自动进入到 view 里被展示。 跟其他的前端框架不同，Elm 不喜欢 parent-child communication, 也不提倡 components，作为函数式编程语言，它在乎的就是创建 function，通过 helper function 来达到类似的效果。 Vue Architecture Vue 也是采用的 MVVM 模式，把数据绑定在内部处理了，对外部来说只要在 data 里声明特定的 key，在 view 里就可以直接使用，并且实时响应。对于 view 的事件，也会映射到 ViewModel 的特定方法。 Vue 的 Router 是把 path 映射到 component 上，看着也比较清晰。 12345const routes = [ &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125;, &#123; path: '/user/:id', component: User &#125;] The Right Way (IMO)目录结构 目录结构需要能够让不同职责的文件找到自己的归属，同时尽量清晰。这个是我目前觉得还不错的分类 External ：一些第三方的 framework。 Extensions : 针对当前 App 做的一些针对性扩展。 Infrastructure : 比较重要的基础组件，在前期就要管控起来。 Models : 对应服务端的 Objects。 Views : 页面。 Shared : 会在 App 内部被公用的部分，方便统一管控。 Utilities : 一些帮助类。 Architecture 本质上跟 MVVM 差不多，只是多补充了些细节。之前也有考虑过采用 ReSwift + RxSwift 的方式，也就是 Redux，后来写下来发现还是有点复杂：比如下拉刷新的 3 个 state （ loading / loaded / failed），action 要定义（毕竟获取数据的逻辑写在 Action 中），state 中也要定义（视图最终关心的是 state 的变化）；没有很方便的 diff 支持等。于是就回归到了 MVVM 模式。 ViewModelViewModel 主要有 3 个职责： 通过 Repository 获取/修改数据。 提供 Observable Properties 供 View 使用。 提供 Functions 供 View 调用，通常会导致 Observable Properties 的改变。 这块也算是常规手法，需要注意的一点是 Repository 的初始化，如果要方便测试的话，最好提供注入点（比如初始化时注入或提供 set 方法注入）。 RepositoryRepository 的职责就是跟数据打交道，获取远程／本地数据，并将其转换成 Model 返回给 ViewModel。 页面间跳转和通信使用 Router 即可，如果是内部的 VC 之间跳转，还可以携带 model 信息。 通用的小模块( Components )我发现前端开发里，Components 用得还蛮多的，客户端开发倒不那么常见。这些小模块其实就是一些可在多个页面复用的业务相关的视图（Widget），可能带有业务逻辑，方便复用，比如「赞」按钮。 服务调用比如在详情页要使用购物车的「加购」功能，通常做法是采用 Register Procotol 方式，维护一个 Protocol 和 Class 的注册表，并且在 App 启动时进行注册。我发现使用 Swift 的 POP 就不需要这么麻烦了，具体怎么做，我们后面讲。 Demo这个 Demo 演示了知乎日报的列表和详情页： 看起来蛮简单的，不过事实可能并非如此，我们来慢慢捋一下。 初始页刚进来时，会处于原始的 loading 状态，这个状态不同于下拉刷新，可能是一个萌萌的 loading 图。 首先这个页面属于 NewsFeed 页，因此在该目录下新建 3 个文件 123|- NewsFeedViewModel.swift|- NewsFeedViewController.swift|- NewsFeedRepository.swift 本着 view 只是展示 state 的原则，我们首先要处理的就是 state，那么怎么处理？ 这个 Event 是从 View 那边触发的，触发之后，对于 View 来说只能求助于 ViewModel，于是 VM 就提供了一个 initialLoading 方法。 那这个 initialLoading 里该做些什么呢？其实也就是根据 repository 的不同结果，设置不同的 state，然后 view 来响应这些 state。同时考虑到之后的「下拉刷新」和「加载更多」，顺便分离出一个通用的 loadData: 方法 ViewModel123456789class NewsFeedViewModel &#123; func initialLoading() &#123; loadData(.initial) &#125; func loadData(_ loadingType: LoadingType, offset: String = "") &#123; // todo &#125;&#125; 那么 Observable Properties 应该是怎样的呢？在 OC 时代，只要简单的暴露 readonly 的 property，外部无论是 KVO 还是 RAC 都能很方便地进行绑定，到了 swift 时代，如果要做 KVO 就要继承 NSObject，还要加一个 @dynamic 前缀，不优雅。比较理想的状态是使用 RxSwift 的 Observable 作为属性，外部只要 subscribe 就行了。不过在内部如何给这个 Observable 塞数据又有点小问题。最终决定使用 Variable 作为暴露的属性，它的好处是内部不需要再新建一个变量，直接设置这个 Variable 的 value 即可，弊端就是对于使用方需要先通过 asObservable() 转一下再进行 subscribe，并且只要愿意，也可以设置 value 值，存在误操作的风险。在这里我们先简单起见用 Variable 来做。 接下来的问题就是这个 Variable 里应该放什么？肯定要放一些当前的 loading 状态，比如 loaded，failed，loading 这些，那么要不要带上 data？如果不一起带上 data，那么状态的改变和数据的改变就不是一个原子操作，有可能会带来一些异常（比如 view 发现 loading 状态变为 loaded，自动去取最新的 data，但此时 data 可能还没有改变）。因此，我把它们都放到了一起，首先来看一下 ResultModel Model这是一个通用的数据结构 123456789101112131415161718192021222324252627282930313233// ResultModel.swiftenum LoadingType &#123; case initial, refresh, more&#125;enum LoadingStatus: Equatable &#123; case none case loading case loaded case failure(Error) static func ==(lhs: LoadingStatus, rhs: LoadingStatus) -&gt; Bool &#123; switch (lhs, rhs) &#123; case (.none, .none): return true case (.loading, .loading): return true case (.loaded, .loaded): return true default: return false &#125; &#125;&#125;struct ResultModel&lt;T&gt; &#123; var loadingStatus: LoadingStatus = .none var loadingType: LoadingType = .initial var previousItems = [T]() var currentItems = [T]()&#125; 12345678910111213141516171819202122232425// NewsModel.swiftclass NewsFeedViewModel &#123; // 1 static var news:Variable&lt;ResultModel&lt;NewsItem&gt;&gt; = Variable(ResultModel()) func initialLoading() &#123; loadData(.initial) &#125; func loadData(_ loadingType: LoadingType, offset: String = "") &#123; // 2 如果当前处于 loading 状态，就不继续处理了 if (NewsFeedViewModel.news.value.loadingStatus == .loading) &#123; return &#125; // 3 设置新的 loading 类型和状态 var value = NewsFeedViewModel.news.value value.loadingStatus = .loading value.loadingType = loadingType NewsFeedViewModel.news.value = value // 4 接下来就是发网络请求，根据不同的请求结果设置 state &#125;&#125; 这里使用 static 主要是出于方便。 这里纠结了一段时间，之前是新建了 3 个 loading status（initial, refresh, loadmore），然后每个 status 再细分为 3 种状态(loading, loaded, error)，后来发现这样的话，「当前是哪个 loading status，该 status 目前处于什么状态」判断起来会比较麻烦。于是就按照现在这样进行了拆分。 在这里对状态进行更改之后，UI 那边可以自动收到更新。 这里会调用 Repository 来获取数据。 RepositoryRepository 这块由于是异步交互，因此直接就上 RxSwift 了，返回一个 Observable ，VM 作为消费方来订阅。 123456789101112131415161718192021import Foundationimport RxSwiftclass NewsFeedRepository &#123; static func news(_ offset: String = "") -&gt; Observable&lt;[String:Any]?&gt; &#123; return Observable.create(&#123; observer in let path = offset.characters.count &gt; 0 ? "/api/4/news/before/\(offset)" : "/api/4/news/latest" let resource = Resource(path: path, method: .GET, requestBody: nil, headers: ["Content-Type": "application/json"], parse: decodeJSON) // 这个用的是 chris 开源的简单的 API 请求封装 http://chris.eidhof.nl/posts/tiny-networking-in-swift.html apiRequest(baseURL: URL(string: "https://news-at.zhihu.com")!, resource: resource, failure: &#123; (reason, result) in observer.on(.error(reason)) &#125;, success: &#123; result in observer.on(.next(result)) observer.on(.completed) &#125;) return Disposables.create() &#125;) &#125;&#125; 也可以在这里直接返回解析后的 Model，这样 VM 那边就不用处理了。 ViewModel 调用 Repository12345678910111213141516171819202122232425262728class NewsFeedViewModel &#123; // 4 NewsFeedRepository.news(offset).asObservable().subscribe(onNext: &#123;[unowned self] (result) in // 把 json 转换为 model let parsedResult = self._parseResult(result: result) var value = NewsFeedViewModel.news.value value.previousItems = NewsFeedViewModel.news.value.currentItems // 设置对应的 value if value.loadingType == .more &#123; value.currentItems = value.previousItems + (parsedResult?.news ?? []) &#125; else &#123; value.currentItems = parsedResult?.news ?? [] &#125; value.loadingStatus = .loaded NewsFeedViewModel.news.value = value self.offset = parsedResult?.date ?? "" value.loadingStatus = .none // 统一设置 value，对外部 subscriber 来说就是原子操作 NewsFeedViewModel.news.value = value &#125;, onError: &#123; (error) in NewsFeedViewModel.news.value.loadingStatus = .failure(error) &#125;, onCompleted: &#123; &#125;) &#123; &#125;.addDisposableTo(disposeBag)&#125; 这里你会注意到有一个 previousItems 和 currentItems ，这个主要是提供灵活性，避免暴力的 reloadData() ，比如获取到了更多的数据之后，可以只 reload 新的数据。 View123456789101112131415161718192021222324// NewsFeedViewController.swiftclass NewsFeedViewController: UITableViewController &#123; override func viewDidLoad() &#123; handleDataChange() viewModel.initialLoading() &#125; func handleDataChange() &#123; NewsFeedViewModel.news.asObservable() .observeOn(MainScheduler.instance) .subscribe(onNext: &#123;[unowned self] item in if item.loadingStatus != .loading &#123; self.initialLoadingIndicator.stopAnimating() &#125; if item.loadingStatus == .loaded &#123; // 这里调用 Diff 这个 framework 提供的 extension self.tableView.animateRowChanges(oldData: item.previousItems, newData: item.currentItems) &#125; if item.loadingType == .initial &amp;&amp; item.loadingStatus == .loading &#123; self.initialLoadingIndicator.startAnimating() &#125; &#125;).addDisposableTo(disposeBag) &#125;&#125; 「正在加载」和「已经加载」的场景已经处理完了，「加载失败」的处理也类似，比如失败之后显示一个 reload button，点击 reload button 之后，再调用一下 viewModel.initialLoading() TableView接下来就来看看如何处理 TableView 的数据展示，其实就是消费 VM 的 property 123456789101112extension NewsFeedViewController &#123; override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return NewsFeedViewModel.news.value.currentItems.count &#125; override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: "Cell") as! NewsCell let newsItem: NewsItem = NewsFeedViewModel.news.value.currentItems[indexPath.row] cell.configure(newsItem) return cell &#125;&#125; 到这里最基本的首页数据展示就基本完成了。 加载更多之前一直在纠结这块到底该怎么做才比较合适，如果直接把 newItems append 到原有的 items 列表，形成新的列表，UI 那边拿到之后就只能 reloadData() 了，最好能让 UI 那边知道新的和旧的之间发生了哪些变化，于是就找到了 Diff 这个 framework，它能够定位出两个 collection 之间的差异，但前提是 collection item 要实现 Equatable 协议。于是就有了 previousItems 和 currentItems 的设计。 喜欢功能喜欢功能本质上是修改 NewsItem 的 hasFaved 属性，然后让 UI 可以感知到这个变化。这里问题就来了：如何对列表中的一个 struct 进行调整？我们知道 struct 是值拷贝的，只要发生赋值行为，拿到的就不再是原先的那个 struct 了（比如把 items 通过参数传递，要修改的话就要进行拷贝，除非设置为 inout）。 这个问题本质上是如何操作 Immutable Objects，然后就想到了 Immutable.js，它也提供了一些修改 List 的方法，只不过都是返回一个新的： 1234const &#123; List &#125; = require('immutable');const list = List([ 0, 1, 2, List([ 3, 4 ])])list.setIn([3, 0], 999);// List [ 0, 1, 2, List [ 999, 4 ] ] 因此，这里简单的处理方式就是通过传进来的 newsItem 找到它在 list 中的 index（newsItem 已经实现了 Equatable 协议），然后把修改过 hasFaved 属性的新的 newsItem 放到 index 位置来达到替换的效果。 12345678910111213class NewsFeedViewModel &#123; func toggleFav(_ newsItem: NewsItem) &#123; if let newsIndex = NewsFeedViewModel.news.value.currentItems.index(of: newsItem) &#123; var _newsItem = NewsFeedViewModel.news.value.currentItems[newsIndex] _newsItem.hasFaved = !_newsItem.hasFaved var value = NewsFeedViewModel.news.value value.currentItems[newsIndex] = _newsItem NewsFeedViewModel.news.value = value &#125; &#125;&#125; Components由于新闻列表和喜欢的新闻列表表现上一致，那么就可以进行一些复用，比如可以把 Cell 作为 Component。 那对于一个 Component 来说，需要具备哪些特性呢？这个并没有什么约定，本质上就是一个或几个函数，外部调用后会返回一个 view，或者提供一些 block 回调，仅此而已。 Truth and Computed Properties这里的 Truth 是指最源头的数据，比如一个数组，Computed Properties 是指对源头数据进行消费可以得到的结果，比如数组的长度，或数组中的正数等。 在这个例子中，Truth 就是 newsItems 列表，而喜欢的 newsItems 就是 Computed Properties 。因此只要 newsItems 发生变化，就重新计算喜欢的 NewsItems。 12345NewsFeedViewModel.news.asObservable().subscribe(onNext: &#123; item in NewsFeedViewModel.favedNews.value = NewsFeedViewModel.news.value.currentItems.filter &#123; (item) -&gt; Bool in return item.hasFaved &#125;&#125;).addDisposableTo(disposeBag) 喜欢功能的 View主要就是两件事： 点击 Fav 按钮时，调用 VM 的 toggleFav 方法。 当 Fav 列表更新时，刷新 TableView。 1234567891011121314151617181920212223242526272829303132extension FavedViewController &#123; func handleDataChange() &#123; NewsFeedViewModel.favedNews.asObservable().subscribe(onNext:&#123;[unowned self] item in self.tableView.reloadData() &#125;).addDisposableTo(disposeBag) &#125;&#125;extension FavedViewController &#123; override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return NewsFeedViewModel.favedNews.value.count &#125; override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: "Cell") as! NewsCell var newsItem: NewsItem = NewsFeedViewModel.favedNews.value[indexPath.row] cell.configure(newsItem) &#123; [unowned self] (button) in if button.tag == 0 &#123; button.tag = 1 button.setTitle("♥︎", for: .normal) &#125; else &#123; button.tag = 0 button.setTitle("♡", for: .normal) &#125; self.viewModel.toggleFav(newsItem) self.tableView.reloadData() &#125; return cell &#125;&#125; 页面跳转页面间的跳转用到了 Router ，也就是 open 一个 url 就能到达特定的页面，这么做的好处是可以和外部跳转进来的情况统一处理（因为从外部跳到某个 app 只能通过 openURL）。 但在内部直接输入 URL 总觉得不优雅，而且容易出错，将来如果要修改 URL 也不方便。因此做了一个简单的 Router 来达到这个效果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import Foundationimport UIKit// 1enum RouterTable: String &#123; case home = "home" case detail = "detail/:id" func asController() -&gt; UIViewController.Type &#123; switch self &#123; case .home: return NewsFeedViewController.self case .detail: return NewsDetailViewController.self &#125; &#125;&#125;// 2class Router &#123; static func to(_ route: RouterTable, parameters: Dictionary&lt;String, Any&gt;?) -&gt; Void &#123; let viewController = route.asController().init() // 2.1 if let parameters = parameters &#123; for (key, value) in parameters &#123; viewController.putExtra(key, value) &#125; &#125; //TODO: 添加 shouldBePushed 调用，比如有些页面需要先登录 DispatchQueue.main.async &#123; UINavigationController.current().pushViewController(viewController, animated: true) &#125; &#125;&#125;// 3extension Router &#123; func parseURL(_ url: String) -&gt; (RouterTable, Dictionary&lt;String, String&gt;?) &#123; //TODO: add implementation return (.home, nil) &#125;&#125; 主要分为 3 部分： 这个跟 vue-router 里定义 url 和 components 的关系一样，主要是为了方便统一管理。 这里主要是把 enum 转换为对应的 Controller，因为限制了类型，也就不会出现找不到 VC 的情况。 这个是用来应对外部跳转进来的 URL，把它解析成 RouterTable，统一逻辑。针对 2 重点说一下，这个是最简实现，真实场景会比这复杂得多，比如有些页面是 present 出来的，有些页面 push 前需要先判断是否登录等等。 注意到 2.1 的部分，这里有一个 putExtra 方法，这是新添加的一个扩展，参考了 Android 的 Intent putExtra 。实现如下： 12345678910111213141516171819protocol ViewCotrollerIntent &#123; func putExtra(_ key: String, _ value: Any) func getExtra(_ key: String) -&gt; Any?&#125;extension UIViewController: ViewCotrollerIntent &#123; private struct IntentStorage &#123; static var extra: [String:Any] = [:] &#125; func putExtra(_ key: String, _ value: Any) &#123; IntentStorage.extra[key] = value &#125; func getExtra(_ key: String) -&gt; Any? &#123; return IntentStorage.extra[key] &#125;&#125; 由于 extension 不支持 associated properties，因此用 struct 做了个中转。这样，VC 之间的跳转如果要带上额外的参数，只要放到 extra 里即可。 详情页详情页比较简单，只是展示一个 webview，这里比较棘手的问题是 model 数据的同步。由于详情页也可以修改 NewsItem 的 hasFaved 属性，这个改变需要能够实时同步到列表页，不然就会出现状态不同步的情况。 这块的设计也想了一段时间，Pinterest 采用的是通知的方式，并且额外开发了一个用来支持这种方式的库，不想整的这么麻烦。本质需求是：当传过去的 model 发生变化时通知我。而 RxSwift 里的 Variable 不是正好可以达到这个效果么？于是就有了基于 Variable 的解决方案。 12345678910111213141516extension NewsFeedViewController &#123; override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; let newsItem: NewsItem = NewsFeedViewModel.news.value.currentItems[indexPath.row] let newsItemVariable = Variable&lt;NewsItem&gt;(newsItem) // 详情页可能会对这个 newsItemVariable 进行调整 newsItemVariable.asObservable().subscribe(onNext: &#123; [unowned self] item in // 找到这个 item 所在的 index，并进行替换 self.viewModel.update(item: item) self.tableView.reloadData() &#125;).addDisposableTo(disposeBag) // 带上这个 Variable 到新的 VC Router.to(.detail, parameters: ["model": newsItemVariable]) &#125;&#125; 详情页 View 的处理12345678910111213141516171819202122232425262728293031323334353637383940414243class NewsDetailViewController: UIViewController &#123; override func viewDidLoad() &#123; // favButton navigationItem.rightBarButtonItem = favButton favButton.rx.tap .subscribe(onNext: &#123; [unowned self] item in self.viewModel.toggleFav() &#125;) .addDisposableTo(disposeBag) // 1 if let id = self.getExtra("id") as? Int &#123; // viewModel.load(id) &#125; // 2 if let model = self.getExtra("model") as? Variable&lt;NewsItem&gt; &#123; favButton.title = model.value.hasFaved ? "♥︎" : "♡" viewModel.load(Int(model.value.id)) NewsDetailViewModel.newsItem = model &#125; handleDataChange() &#125; // 3 func handleDataChange() &#123; NewsDetailViewModel.newsDetail.asObservable() .subscribe(onNext:&#123; [unowned self] item in if let item = item &#123; let request = URLRequest(url: URL(string: item.shareURL)!) self.webView.loadRequest(request) &#125; &#125;) .addDisposableTo(disposeBag) NewsDetailViewModel.newsItem?.asObservable() .subscribe(onNext: &#123; [unowned self] item in self.favButton.title = item.hasFaved ? "♥︎" : "♡" &#125;) .addDisposableTo(disposeBag) &#125;&#125; 这里为通过外部 URL 进来的留一个入口。 通过 getExtra 拿到 Variable 后，接下来就交给 VM 了。 handleDataChange 做的事情就是响应 VM 的 properties 的变化，做一些 UI 上的调整。 Service之前说过使用 Swift 提供 Service 会比较方便，都不需要在 App 启动时进行注册，利用自带的 Protocol Extension 就能达到效果。这个例子中没有用到，就举个其他的例子吧，以购物车为例： 1234567891011// 放在 Services 目录下的 Protocols.swiftprotocol Cart &#123; public func add(_ item: Item) -&gt; Bool&#125;// 具体的实现可以放到对应的页面extension Cart &#123; public func add(_ item: Item) -&gt; Bool &#123; // business logic &#125;&#125; 对于想要使用这个功能的开发来说，只要看 Services/Protocols.swift 就行了。跟 Objective-C 不同，extension 里如果有两个相同的方法，编译器会直接报错，这样就避免了运行期可能出现多个实现的问题。 Local ReasoningLocal Reasoning 的意思是对于数据的改动都发生在某一个特定的单元。这也是使用 Value Type 的好处，因为如果使用 Reference Type，只要把其中的一个 Reference 给了出去，就不知道什么时间什么场景下数据会在外部被改变，就像给了你一张银行卡，今天看还剩 1 万，可能明天再去看就只剩 1 千了。 使用 VM 后，所有对数据的改动都发生在 VM 里面，同时对数据的消费也尽量在一个地方，方便维护。 小结以上是我自己对「Right Architecture」的一些理解和实践，实际过程中肯定还有很多细节要调整，如果你有什么想法欢迎交流～ 原文]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 架构模式 - 简述 MVC, MVP, MVVM 和 VIPER (译)]]></title>
    <url>%2F2017%2F06%2F26%2FiOS%2F17062601.iOS%20%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F%20-%20%E7%AE%80%E8%BF%B0%20MVC%2C%20MVP%2C%20MVVM%20%E5%92%8C%20VIPER%20(%E8%AF%91)%2Findex%2F</url>
    <content type="text"><![CDATA[Make everything as simple as possible, but not simpler — Albert Einstein把每件事，做简单到极致，但又不过于简单 - 阿尔伯特·爱因斯坦 在使用 iOS 的 MVC 时候感觉怪怪的？想要尝试下 MVVM？之前听说过 VIPER，但是又纠结是不是值得去学？继续阅读，你就会知道上面问题的答案 - 如果读完了还是不知道的话，欢迎留言评论。 iOS 上面的架构模式你可能之前就了解过一些，接下来我们会帮你把它们进行一下梳理。我们先简要回顾一下目前比较主流的架构模式，分析比较一些他们的原理，并用一些小栗子来进行练习。如果你对其中的某一种比较感兴趣的话，我们也在文章里面给出了对应的链接。 对于设计模式的学习是一件容易上瘾的事情，所以先提醒你一下：在你读完这篇文章之后，可能会比读之前有更多的疑问，比如： MVC：谁来负责网络请求：是 Model 还是 Controller？ MVVM：我该怎么去把一个 Model 传递给一个新创建的 View 的 ViewModel？ VIPER：谁来负责创建 VIPER 模块：是 Router 还是 Presenter？ 为何要在意架构的选择呢？因为如果你不在意的话，难保一天，你就需要去调试一个巨大无比又有着各种问题的类，然后你会发现在这个类里面，你完全就找不到也修复不了任何 bug。一般来说，把这么大的一个类作为整体放在脑子里记着是一件非常困难的事情，你总是难免会忘掉一些比较重要的细节。如果你发现在你的应用里面已经开始出现这种状况了，那你很可能遇到过下面这类问题： 这个类是一个 UIViewController 的子类。 你的数据直接保存在了 UIViewController 里面。 你的 UIViews 好像什么都没做。 你的 Model 只是一个纯粹的数据结构 你的单元测试什么都没有覆盖到 其实即便你遵循了 Apple 的设计规范，实现了 Apple 的 MVC 框架，也还是一样会遇到上面这些问题；所以也没什么好失落的。Apple 的 MVC 框架 有它自身的缺陷，不过这个我们后面再说。 让我们先来定义一下好的框架应该具有的特征： 用严格定义的角色，平衡的将职责 划分 给不同的实体。 可测性 通常取决于上面说的第一点（不用太担心，如果架构何时的话，做到这点并不难）。 易用 并且维护成本低。 为什么要划分？当我们试图去理解事物的工作原理的时候，划分可以减轻我们的脑部压力。如果你觉得开发的越多，大脑就越能适应去处理复杂的工作，确实是这样。但是大脑的这种能力不是线性提高的，而且很快就会达到一个瓶颈。所以要处理复杂的事情，最好的办法还是在遵循 单一责任原则 的条件下，将它的职责划分到多个实体中去。 为什么要可测性？对于那些对单元测试心存感激的人来说，应该不会有这方面的疑问：单元测试帮助他们测试出了新功能里面的错误，或者是帮他们找出了重构的一个复杂类里面的 bug。这意味着这些单元测试帮助这些开发者们在程序运行之前就发现了问题，这些问题如果被忽视的话很可能会提交到用户的设备上去；而修复这些问题，又至少需要一周左右的时间（AppStore 审核）。 为什么要易用这块没什么好说的，直说一点：最好的代码是那些从未被写出来的代码。代码写的越少，问题就越少；所以开发者想少写点代码并不一定就是因为他懒。还有，当你想用一个比较 聪明 的方法的时候，全完不要忽略了它的维护成本。 MV(X) 的基本要素现在我们面对架构设计模式的时候有了很多选择： MVC MVP MVVM VIPER 首先前三种模式都是把所有的实体归类到了下面三种分类中的一种： Models（模型） — 数据层，或者负责处理数据的 数据接口层。比如 Person 和 PersonDataProvider 类 Views（视图） - 展示层(GUI)。对于 iOS 来说所有以 UI 开头的类基本都属于这层。 Controller/Presenter/ViewModel（控制器/展示器/视图模型） - 它是 Model 和 View 之间的胶水或者说是中间人。一般来说，当用户对 View 有操作时它负责去修改相应 Model；当 Model 的值发生变化时它负责去更新对应 View。 将实体进行分类之后我们可以： 更好的理解 重用（主要是 View 和 Model） 对它们独立的进行测试 让我从 MV(X) 系列开始讲起，最后讲 VIPER。 MVC - 它原来的样子 在开始讨论 Apple 的 MVC 之前，我们先来看下 传统的 MVC。 在这种架构下，View 是无状态的，在 Model 变化的时候它只是简单的被 Controller 重绘；就像网页一样，点击了一个新的链接，整个网页就重新加载。尽管这种架构可以在 iOS 应用里面实现，但是由于 MVC 的三种实体被紧密耦合着，每一种实体都和其他两种有着联系，所以即便是实现了也没有什么意义。这种紧耦合还戏剧性的减少了它们被重用的可能，这恐怕不是你想要在自己的应用里面看到的。综上，传统 MVC 的例子我觉得也没有必要去写了。 传统的 MVC 已经不适合当下的 iOS 开发了。 Apple 的 MVC理想 View 和 Model 之间是相互独立的，它们只通过 Controller 来相互联系。有点恼人的是 Controller 是重用性最差的，因为我们一般不会把冗杂的业务逻辑放在 Model 里面，那就只能放在 Controller 里了。 理论上看这么做貌似挺简单的，但是你有没有觉得有点不对劲？你甚至听过有人把 MVC 叫做重控制器模式。另外 关于 ViewController 瘦身 已经成为 iOS 开发者们热议的话题了。为什么 Apple 要沿用只是做了一点点改进的传统 MVC 架构呢？ 现实 Cocoa MVC 鼓励你去写重控制器是因为 View 的整个生命周期都需要它去管理，Controller 和 View 很难做到相互独立。虽然你可以把控制器里的一些业务逻辑和数据转换的工作交给 Model，但是你再想把负担往 View 里面分摊的时候就没办法了；因为 View 的主要职责就只是讲用户的操作行为交给 Controller 去处理而已。于是 ViewController 最终就变成了所有东西的代理和数据源，甚至还负责网络请求的发起和取消，还有…剩下的你来讲。 像下面这种代码你应该不陌生吧： 12var userCell = tableView.dequeueReusableCellWithIdentifier("identifier") as UserCelluserCell.configureWithUser(user) Cell 作为一个 View 直接用 Model 来完成了自身的配置，MVC 的原则被打破了，这种情况一直存在，而且还没人觉得有什么问题。如果你是严格遵循 MVC 的话，你应该是在 ViewController 里面去配置 Cell，而不是直接将 Model 丢给 Cell，当然这样会让你的 ViewController 更重。 Cocoa MVC 被戏称为重控制器模式还是有原因的。 问题直到开始 单元测试（希望你的项目里面已经有了）之后才开始显现出来。Controller 测试起来很困难，因为它和 View 耦合的太厉害，要测试它的话就需要频繁的去 mock View 和 View 的生命周期；而且按照这种架构去写控制器代码的话，业务逻辑的代码也会因为视图布局代码的原因而变得很散乱。 我们来看下面这段 playground 中的例子： 12345678910111213141516171819202122232425262728import UIKitstruct Person &#123; // Model let firstName: String let lastName: String&#125;class GreetingViewController : UIViewController &#123; // View + Controller var person: Person! let showGreetingButton = UIButton() let greetingLabel = UILabel() override func viewDidLoad() &#123; super.viewDidLoad() self.showGreetingButton.addTarget(self, action: "didTapButton:", forControlEvents: .TouchUpInside) &#125; func didTapButton(button: UIButton) &#123; let greeting = "Hello" + " " + self.person.firstName + " " + self.person.lastName self.greetingLabel.text = greeting &#125; // layout code goes here&#125;// Assembling of MVClet model = Person(firstName: "David", lastName: "Blaine")let view = GreetingViewController()view.person = model; MVC 的组装，可以放在当前正在显示的 ViewController 里面 这段代码看起来不太好测试对吧？我们可以把 greeting 的生成方法放到一个新类 GreetingModel 里面去单独测试。但是我们如果不调用与 View 相关的方法的话 （viewDidLoad, didTapButton），就测试不到 GreetingViewController 里面任何的显示逻辑（虽然在上面这个例子里面，逻辑已经很少了）；而调用的话就可能需要把所有的 View 都加载出来，这对单元测试来说太不利了。 实际上，在模拟器（比如 iPhone 4S）上运行并测试 View 的显示并不能保证在其他设备上（比如 iPad）也能良好运行。所以我建议把「Host Application」从你的单元测试配置项里移除掉，然后在不启动模拟器的情况下去跑你的单元测试。 View 和 Controller 之间的交互，并不能真正的被单元测试覆盖。 综上所述，Cocoa MVC 貌似并不是一个很好的选择。但是我们还是评估一下他在各方面的表现（在文章开头有讲）： 划分 - View 和 Model 确实是实现了分离，但是 View 和 Controller 耦合的太厉害 可测性 - 因为划分的不够清楚，所以能测的基本就只有 Model 而已 易用 - 相较于其他模式，它的代码量最少。而且基本上每个人都很熟悉它，即便是没太多经验的开发者也能维护。 在这种情况下你可以选择 Cocoa MVC：你并不想在架构上花费太多的时间，而且你觉得对于你的小项目来说，花费更高的维护成本只是浪费而已。 如果你最看重的是开发速度，那么 Cocoa MVC 就是你最好的选择。 MVP - 保证了职责划分的（promises delivered） Cocoa MVC 看起来确实很像 Apple 的 MVC 对吧？确实蛮像，它的名字是 MVP（被动变化的 View）。稍等…这个意思是说 Apple 的 MVC 实际上是 MVP 吗？不是的，回想一下，在 MVC 里面 View 和 Controller 是耦合紧密的，但是对于 MVP 里面的 Presenter 来讲，它完全不关注 ViewController 的生命周期，而且 View 也能被简单 mock 出来，所以在 Presenter 里面基本没什么布局相关的代码，它的职责只是通过数据和状态更新 View。 如果我跟你讲 UIViewController 在这里的角色其实是 View 你感觉如何。 在 MVP 架构里面，UIViewController 的那些子类其实是属于 View 的，而不是 Presenter。这种区别提供了极好的可测性，但是这是用开发速度的代价换来的，因为你必须要手动的去创建数据和绑定事件，像下面这段代码中做的一样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import UIKitstruct Person &#123; // Model let firstName: String let lastName: String&#125;protocol GreetingView: class &#123; func setGreeting(greeting: String)&#125;protocol GreetingViewPresenter &#123; init(view: GreetingView, person: Person) func showGreeting()&#125;class GreetingPresenter : GreetingViewPresenter &#123; unowned let view: GreetingView let person: Person required init(view: GreetingView, person: Person) &#123; self.view = view self.person = person &#125; func showGreeting() &#123; let greeting = "Hello" + " " + self.person.firstName + " " + self.person.lastName self.view.setGreeting(greeting) &#125;&#125;class GreetingViewController : UIViewController, GreetingView &#123; var presenter: GreetingViewPresenter! let showGreetingButton = UIButton() let greetingLabel = UILabel() override func viewDidLoad() &#123; super.viewDidLoad() self.showGreetingButton.addTarget(self, action: "didTapButton:", forControlEvents: .TouchUpInside) &#125; func didTapButton(button: UIButton) &#123; self.presenter.showGreeting() &#125; func setGreeting(greeting: String) &#123; self.greetingLabel.text = greeting &#125; // layout code goes here&#125;// Assembling of MVPlet model = Person(firstName: "David", lastName: "Blaine")let view = GreetingViewController()let presenter = GreetingPresenter(view: view, person: model)view.presenter = presenter 关于组装方面的重要说明MVP 架构拥有三个真正独立的分层，所以在组装的时候会有一些问题，而 MVP 也成了第一个披露了这种问题的架构。因为我们不想让 View 知道 Model 的信息，所以在当前的 ViewController（角色其实是 View）里面去进行组装肯定是不正确的，我们应该在另外的地方完成组装。比如，我们可以创建一个应用层（app-wide）的 Router 服务，让它来负责组装和 View-to-View 的转场。这个问题不仅在 MVP 中存在，在接下来要介绍的模式里面也都有这个问题。 让我们来看一下 MVP 在各方面的表现： 划分 - 我们把大部分的职责都分配到了 Presenter 和 Model 里面，而 View 基本上不需要做什么（在上面的例子里面，Model 也什么都没做）。 可测性 - 简直棒，我们可以通过 View 来测试大部分的业务逻辑。 易用 - 就我们上面那个简单的例子来讲，代码量差不多是 MVC 架构的两倍，但是 MVP 的思路还是蛮清晰的。 MVP 架构在 iOS 中意味着极好的可测性和巨大的代码量。 MVP - 添加了数据绑定的另一个版本 还存在着另一种的 MVP - Supervising Controller MVP。这个版本的 MVP 包括了 View 和 Model 的直接绑定，与此同时 Presenter（Supervising Controller）仍然继续处理 View 上的用户操作，控制 View 的显示变化。 但是我们之前讲过，模糊的职责划分是不好的事情，比如 View 和 Model 的紧耦合。这个道理在 Cocoa 桌面应用开发上面也是一样的。 就像传统 MVC 架构一样，我找不到有什么理由需要为这个有瑕疵的架构写一个例子。 MVVM - 是 MV(X) 系列架构里面最新兴的，也是最出色的 MVVM 架构是 MV(X) 里面最新的一个，让我们希望它在出现的时候已经考虑到了 MV(X) 模式之前所遇到的问题吧。 理论上来说，Model - View - ViewModel 看起来非常棒。View 和 Model 我们已经都熟悉了，中间人的角色我们也熟悉了，但是在这里中间人的角色变成了 ViewModel。 它跟 MVP 很像： MVVM 架构把 ViewController 看做 View。 View 和 Model 之间没有紧耦合 另外，它还像 Supervising 版的 MVP 那样做了数据绑定，不过这次不是绑定 View 和 Model，而是绑定 View 和 ViewModel。 那么，iOS 里面的 ViewModel 到底是个什么东西呢？本质上来讲，他是独立于 UIKit 的， View 和 View 的状态的一个呈现（representation）。ViewModel 能主动调用对 Model 做更改，也能在 Model 更新的时候对自身进行调整，然后通过 View 和 ViewModel 之间的绑定，对 View 也进行对应的更新。 绑定我在 MVP 的部分简单的提过这个内容，在这里让我们再延伸讨论一下。绑定这个概念源于 OS X 平台的开发，但是在 iOS 平台上面，我们并没有对应的开发工具。当然，我们也有 KVO 和 通知，但是用这些方式去做绑定不太方便。 那么，如果我们不想自己去写他们的话，下面提供了两个选择： 选一个基于 KVO 的绑定库，比如 RZDataBinding 或者 SwiftBond。 使用全量级的 函数式响应编程 框架,比如 ReactiveCocoa、RxSwift 或者 PromiseKit。 实际上，现在提到「MVVM」你应该就会想到 ReactiveCocoa，反过来也是一样。虽然我们可以通过简单的绑定来实现 MVVM 模式，但是 ReactiveCocoa（或者同类型的框架）会让你更大限度的去理解 MVVM。 响应式编程框架也有一点不好的地方，能力越大责任越大嘛。用响应式编程用得不好的话，很容易会把事情搞得一团糟。或者这么说，如果有什么地方出错了，你需要花费更多的时间去调试。看着下面这张调用堆栈图感受一下： 在接下来的这个小例子中，用响应式框架（FRF）或者 KVO 都显得有点大刀小用，所以我们用另一种方式：直接的调用 ViewModel 的 showGreeting 方法去更新自己（的 greeting 属性），（在 greeting 属性的 didSet 回调里面）用 greetingDidChange 闭包函数去更新 View 的显示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import UIKitstruct Person &#123; // Model let firstName: String let lastName: String&#125;protocol GreetingViewModelProtocol: class &#123; var greeting: String? &#123; get &#125; var greetingDidChange: ((GreetingViewModelProtocol) -&gt; ())? &#123; get set &#125; // function to call when greeting did change init(person: Person) func showGreeting()&#125;class GreetingViewModel : GreetingViewModelProtocol &#123; let person: Person var greeting: String? &#123; didSet &#123; self.greetingDidChange?(self) &#125; &#125; var greetingDidChange: ((GreetingViewModelProtocol) -&gt; ())? required init(person: Person) &#123; self.person = person &#125; func showGreeting() &#123; self.greeting = "Hello" + " " + self.person.firstName + " " + self.person.lastName &#125;&#125;class GreetingViewController : UIViewController &#123; var viewModel: GreetingViewModelProtocol! &#123; didSet &#123; self.viewModel.greetingDidChange = &#123; [unowned self] viewModel in self.greetingLabel.text = viewModel.greeting &#125; &#125; &#125; let showGreetingButton = UIButton() let greetingLabel = UILabel() override func viewDidLoad() &#123; super.viewDidLoad() self.showGreetingButton.addTarget(self.viewModel, action: "showGreeting", forControlEvents: .TouchUpInside) &#125; // layout code goes here&#125;// Assembling of MVVMlet model = Person(firstName: "David", lastName: "Blaine")let viewModel = GreetingViewModel(person: model)let view = GreetingViewController()view.viewModel = viewModel 然后，我们再回过头来对它各方面的表现做一个评价： 划分 - 这在我们的小栗子里面表现的不是很清楚，但是 MVVM 框架里面的 View 比 MVP 里面负责的事情要更多一些。因为前者是通过 ViewModel 的数据绑定来更新自身状态的，而后者只是把所有的事件统统交给 Presenter 去处理就完了，自己本身并不负责更新。 可测性 - 因为 ViewModel 对 View 是一无所知的，这样我们对它的测试就变得很简单。View 应该也是能够被测试的，但是可能因为它对 UIKit 的依赖，你会直接略过它。 易用 - 在我们的例子里面，它的代码量基本跟 MVP 持平，但是在实际的应用当中 MVVM 会更简洁一些。因为在 MVP 下你必须要把 View 的所有事件都交给 Presenter 去处理，而且需要手动的去更新 View 的状态；而在 MVVM 下，你只需要用绑定就可以解决。 MVVM 真的很有魅力，因为它不仅结合了上述几种框架的优点，还不需要你为视图的更新去写额外的代码（因为在 View 上已经做了数据绑定），另外它在可测性上的表现也依然很棒。 VIPER - 把搭建乐高积木的经验应用到 iOS 应用的设计上 VIPER 是我们最后一个要介绍的框架，这个框架比较有趣的是它不属于任何一种 MV(X) 框架。 到目前为止，你可能觉得我们把职责划分成三层，这个颗粒度已经很不错了吧。现在 VIPER 从另一个角度对职责进行了划分，这次划分了 五层。 Interactor（交互器） - 包括数据（Entities）或者网络相关的业务逻辑。比如创建新的 entities 或者从服务器上获取数据；要实现这些功能，你可能会用到一些服务和管理（Services and Managers）：这些可能会被误以为成是外部依赖东西，但是它们就是 VIPER 的 Interactor 模块。 Presenter（展示器） - 包括 UI（but UIKit independent）相关的业务逻辑，可以调用 Interactor 中的方法。 Entities（实体） - 纯粹的数据对象。不包括数据访问层，因为这是 Interactor 的职责。 Router（路由） - 负责 VIPER 模块之间的转场 实际上 VIPER 模块可以只是一个页面（screen），也可以是你应用里整个的用户使用流程（the whole user story）- 比如说「验证」这个功能，它可以只是一个页面，也可以是连续相关的一组页面。你的每个「乐高积木」想要有多大，都是你自己来决定的。 如果我们把 VIPER 和 MV(X) 系列做一个对比的话，我们会发现它们在职责划分上面有下面的一些区别： Model（数据交互）的逻辑被转移到了 Interactor 里面，Entities 只是一个什么都不用做的数据结构体。 Controller/Presenter/ViewModel 的职责里面，只有 UI 的展示功能被转移到了 Presenter 里面。Presenter 不具备直接更改数据的能力。 VIPER 是第一个把导航的职责单独划分出来的架构模式，负责导航的就是 Router 层。 如何正确的使用导航（doing routing）对于 iOS 应用开发来说是一个挑战，MV(X) 系列的架构完全就没有意识到（所以也不用处理）这个问题。 下面的这个列子并没有涉及到导航和 VIPER 模块间的转场，同样上面 MV(X) 系列架构里面也都没有涉及。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import UIKitstruct Person &#123; // Entity (usually more complex e.g. NSManagedObject) let firstName: String let lastName: String&#125;struct GreetingData &#123; // Transport data structure (not Entity) let greeting: String let subject: String&#125;protocol GreetingProvider &#123; func provideGreetingData()&#125;protocol GreetingOutput: class &#123; func receiveGreetingData(greetingData: GreetingData)&#125;class GreetingInteractor : GreetingProvider &#123; weak var output: GreetingOutput! func provideGreetingData() &#123; let person = Person(firstName: "David", lastName: "Blaine") // usually comes from data access layer let subject = person.firstName + " " + person.lastName let greeting = GreetingData(greeting: "Hello", subject: subject) self.output.receiveGreetingData(greeting) &#125;&#125;protocol GreetingViewEventHandler &#123; func didTapShowGreetingButton()&#125;protocol GreetingView: class &#123; func setGreeting(greeting: String)&#125;class GreetingPresenter : GreetingOutput, GreetingViewEventHandler &#123; weak var view: GreetingView! var greetingProvider: GreetingProvider! func didTapShowGreetingButton() &#123; self.greetingProvider.provideGreetingData() &#125; func receiveGreetingData(greetingData: GreetingData) &#123; let greeting = greetingData.greeting + " " + greetingData.subject self.view.setGreeting(greeting) &#125;&#125;class GreetingViewController : UIViewController, GreetingView &#123; var eventHandler: GreetingViewEventHandler! let showGreetingButton = UIButton() let greetingLabel = UILabel() override func viewDidLoad() &#123; super.viewDidLoad() self.showGreetingButton.addTarget(self, action: "didTapButton:", forControlEvents: .TouchUpInside) &#125; func didTapButton(button: UIButton) &#123; self.eventHandler.didTapShowGreetingButton() &#125; func setGreeting(greeting: String) &#123; self.greetingLabel.text = greeting &#125; // layout code goes here&#125;// Assembling of VIPER module, without Routerlet view = GreetingViewController()let presenter = GreetingPresenter()let interactor = GreetingInteractor()view.eventHandler = presenterpresenter.view = viewpresenter.greetingProvider = interactorinteractor.output = presenter 我们再来评价下它在各方面的表现： 划分 - 毫无疑问的，VIPER 在职责划分方面是做的最好的。 可测性 - 理所当然的，职责划分的越好，测试起来就越容易 易用 - 最后，你可能已经猜到了，上面两点好处都是用维护性的代价换来的。一个小小的任务，可能就需要你为各种类写大量的接口。 那么，我们到底应该给「乐高」一个怎样的评价呢？如果你在使用 VIPER 框架的时候有一种在用乐高积木搭建帝国大厦的感觉，那么你可能 正在犯错误；可能对于你负责的应用来说，还没有到使用 VIPER 的时候，你应该把一些事情考虑的再简单一些。总是有一些人忽视这个问题，继续扛着大炮去打小鸟。我觉得可能是因为他们相信，虽然目前来看维护成本高的不合常理，但是至少在将来他们的应用可以从 VIPER 架构上得到回报吧。如果你也跟他们的观点一样的话，那我建议你尝试一下 Generamba - 一个可以生成 VIPER 框架的工具。虽然对于我个人来讲，这感觉就像给大炮装上了一个自动瞄准系统，然后去做一件只用弹弓就能解决的事情。 结论我们简单了解了几种架构模式，对于那些让你困惑的问题，我希望你已经找到了答案。但是毫无疑问，你应该已经意识到了，在选择架构模式这件问题上面，不存在什么 银色子弹，你需要做的就是具体情况具体分析，权衡利弊而已。 因此在同一个应用里面，即便有几种混合的架构模式也是很正常的一件事情。比如：开始的时候，你用的是 MVC 架构，后来你意识到有一个特殊的页面用 MVC 做的的话维护起来会相当的麻烦；这个时候你可以只针对这一个页面用 MVVM 模式去开发，对于之前那些用 MVC 就能正常工作的页面，你完全没有必要去重构它们，因为两种架构是完全可以和睦共存的。 更新：这里有个简短的 PPT 原文链接 原译文]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除UISearchBar背景，设置空也可以点击搜索]]></title>
    <url>%2F2017%2F06%2F23%2FiOS%2F17062301.%E5%88%A0%E9%99%A4UISearchBar%E8%83%8C%E6%99%AF%EF%BC%8C%E8%AE%BE%E7%BD%AE%E7%A9%BA%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%82%B9%E5%87%BB%E6%90%9C%E7%B4%A2%2Findex%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122func removeSearchBarBgView(frome view: UIView) &#123; for sv in view.subviews &#123; // 去除背景 if let className = NSClassFromString("UISearchBarBackground") &#123; if sv.isKind(of: className) &#123; sv.removeFromSuperview() continue &#125; &#125; // 设置空字符也可以点击搜索 if let t = sv as? UITextField &#123; t.enablesReturnKeyAutomatically = false &#125; removeSearchBarBgView(frome: sv) &#125;&#125;searchBar = UISearchBar()searchBar.placeholder = "搜索"searchBar.backgroundColor = UIColor.clearsearchBar.delegate = selfsearchBar.tintColor = UIColor.paOrangeremoveSearchBarBgView(frome: searchBar)]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建自动运行脚本用来备份文件]]></title>
    <url>%2F2017%2F05%2F12%2F%E8%84%9A%E6%9C%AC%2F17051201.%E5%88%9B%E5%BB%BA%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC%E7%94%A8%E6%9D%A5%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%2Findex%2F</url>
    <content type="text"><![CDATA[基础 输出到文件 1echo "$1" &gt; $logFile 输出到文件：尾部插入 1echo "$1" &gt;&gt; $logFile 输出到文件：某行插入 12345678910111213141516171819202122# 格式 ni代表第n行前插入，na代表第n行后插入sed -i '' 'ni\something' $logFile# 双引号才可以调用变量，格式如下sed -i '' "1i\\\\$&#123;1&#125;\\" $logFile# 多行建议这样使用file="filePath"multiLineCode="\\\line 1 \\line 2 \\line 3 \\\\"sed -i '' "1i\\$&#123;multiLineCode&#125;" $file 删除文件/文件夹 12rm -f someFilerm -rf someDir 复制文件/文件夹 12cp -f aFile bFilecp -rf aDir bDir 遍历数组 1234for dir in $SubFolderArraydo echo $dirdone 倒序遍历数组 12345for (( i=$&#123;ArrayLength&#125;-1; i&gt;=0; i-- ));do dir=$&#123;SubFolderArray[$i]&#125; echo $dirdone 判断字符串是否以xxx开头 123if [[ $dir == .svn_* ]]; then ...fi 判断字符串是否包含子串 123if [[ $dir == *svn_* ]]; then ...fi 判断数字大于xx等 123if (( $&#123;TotalBack&#125; &gt; 10 )); then ...fi 脚本列表 备份脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 备份脚本outputLog() &#123; logFile="/Users/shaoweinan154/wanjia2B/svnBackBash/SVNBackLog/svnBack.log" if [ ! -f "$logFile" ]; then touch "$logFile" echo "$1" &gt;&gt; $logFile else sed -i '' "1i\\ \\$&#123;1&#125;\\ " $logFile fi open -a "Sublime Text" $logFile&#125;beginBackFile() &#123; currentTime="`date +%Y-%m-%d`" # 删除可能含有的备份 rm -rf "/Users/shaoweinan154/wanjia2B/svnBackBash/SVNBackFile/.svn_$&#123;currentTime&#125;" # 备份 cp -rf "/Users/shaoweinan154/wanjia2B/.svn" "/Users/shaoweinan154/wanjia2B/svnBackBash/SVNBackFile/.svn_$&#123;currentTime&#125;" if [[ ! $? -eq 0 ]]; then outputLog " 备份出错 $&#123;currentTime&#125; " else outputLog " 备份成功 $&#123;currentTime&#125; " fi&#125;deleteOldBackFile() &#123; Folder="/Users/shaoweinan154/wanjia2B/svnBackBash/SVNBackFile/" SubFolder=$(ls -a $&#123;Folder&#125;) SubFolderArray=($&#123;SubFolder&#125;) ArrayLength=$&#123;#SubFolderArray[@]&#125; TotalBack=0 for (( i=$&#123;ArrayLength&#125;-1; i&gt;=0; i-- )); do dir=$&#123;SubFolderArray[$i]&#125; if [[ $dir == .svn_* ]]; then let TotalBack++ if (( $&#123;TotalBack&#125; &gt; 10 )); then rm -rf "/Users/shaoweinan154/wanjia2B/svnBackBash/SVNBackFile/$&#123;dir&#125;" if [[ ! $? -eq 0 ]]; then outputLog " 删除出错 $&#123;dir&#125; " else outputLog " 删除成功 $&#123;dir&#125; " fi fi fi done&#125;beginBackFiledeleteOldBackFile 恢复脚本 123456789101112# 恢复脚本rm -rf "/Users/shaoweinan154/wanjia2B/.svn"cp -rf "$1" "/Users/shaoweinan154/wanjia2B/.svn" if [[ ! $? -eq 0 ]]; then echo " 恢复出错 $1 " exit 1else echo " 恢复成功 $1 " exit 0fi 使用Mac进行自动执行备份脚本 编写launchctl加载的plist文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!-- 卸载 launchctl unload cn.zhong.task.plist 启动 launchctl load cn.zhong.task.plist--&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;&lt;plist version="1.0"&gt;&lt;dict&gt; &lt;!-- 名称，要全局唯一 --&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;wanjia2B.runBackSvnFile&lt;/string&gt; &lt;!-- 要运行的程序， 如果省略这个选项，会把ProgramArguments的第一个元素作为要运行的程序 --&gt; &lt;key&gt;Program&lt;/key&gt; &lt;string&gt;/Users/shaoweinan154/wanjia2B/svnBackBash/backSVNFile.sh&lt;/string&gt; &lt;!-- 命令， 第一个为命令，其它为参数--&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;sh&lt;/string&gt; &lt;string&gt;/Users/shaoweinan154/wanjia2B/svnBackBash/backSVNFile.sh&lt;/string&gt; &lt;/array&gt; &lt;!-- 运行时间--&gt; &lt;key&gt;StartCalendarInterval&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Hour&lt;/key&gt; &lt;integer&gt;12&lt;/integer&gt; &lt;key&gt;Minute&lt;/key&gt; &lt;integer&gt;0&lt;/integer&gt; &lt;/dict&gt; &lt;!-- 运行间隔，与StartCalenderInterval使用其一，单位为秒 --&gt; &lt;!-- &lt;key&gt;StartInterval&lt;/key&gt; --&gt; &lt;!-- &lt;integer&gt;2&lt;/integer&gt; --&gt; &lt;key&gt;Disabled&lt;/key&gt; &lt;false/&gt; &lt;key&gt;KeepAlive&lt;/key&gt; &lt;false/&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;false/&gt; &lt;key&gt;StandardErrorPath&lt;/key&gt; &lt;string&gt;/Users/shaoweinan154/wanjia2B/svnBackBash/SVNBackLog/task.log&lt;/string&gt; &lt;key&gt;StandardOutPath&lt;/key&gt; &lt;string&gt;/Users/shaoweinan154/wanjia2B/svnBackBash/SVNBackLog/task.log&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; 使用launchctl加载plist 1234567cd /Users/shaoweinan154/wanjia2B/svnBackBash/# 加载launchctl load ***.plist# 取消launchctl unload ***.plist# 查看launchctl list]]></content>
      <categories>
        <category>脚本</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Bash</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode自动修改文件以及自动打包集合]]></title>
    <url>%2F2017%2F04%2F22%2F%E8%84%9A%E6%9C%AC%2F17042201.Xcode%E8%87%AA%E5%8A%A8%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E9%9B%86%E5%90%88%2Findex%2F</url>
    <content type="text"><![CDATA[Shell介绍 当前文件的目录 1BASE_PATH=$(cd `dirname $0`; pwd) 获取父目录 123456789fadir()&#123; local this_dir=`pwd` local child_dir="$1" dirname "$child_dir" cd $this_dir&#125;father_dir=`fadir "/usr/ss/dd/aa"`echo $father_dir shell打印带颜色文本 123456789101112131415161718echo -e "\033[字背景颜色;文字颜色m字符串\033[0m"echo -e "\033[30m 黑色字 \033[0m"echo -e "\033[31m 红色字 \033[0m"echo -e "\033[32m 绿色字 \033[0m"echo -e "\033[33m 黄色字 \033[0m"echo -e "\033[34m 蓝色字 \033[0m"echo -e "\033[35m 紫色字 \033[0m"echo -e "\033[36m 天蓝字 \033[0m"echo -e "\033[37m 白色字 \033[0m"echo -e "\033[40;37m 黑底白字 \033[0m"echo -e "\033[41;37m 红底白字 \033[0m"echo -e "\033[42;37m 绿底白字 \033[0m"echo -e "\033[43;37m 黄底白字 \033[0m"echo -e "\033[44;37m 蓝底白字 \033[0m"echo -e "\033[45;37m 紫底白字 \033[0m"echo -e "\033[46;37m 天蓝底白字 \033[0m"echo -e "\033[47;30m 白底黑字 \033[0m" 字符串中使用变量 12# 变量前面加$即可"===== $INFO_PLIST_FILE =====" shell if 语句 1234567if [[ ... ]]; then # 不可以留空elif [[ ... ]]; then # 不可以留空else # 不可以留空fi shell case语句 12345678910111213141516case $cleanType in"y" | "Y" | "yes" | "YES" ) echoB "============================== Begin Clean ==============================" xcodebuild clean echoS "=========================== Success Of Clean ============================" ;;"n" | "N" | "no" | "NO" ) echoS "============================= Skip To Clean =============================" ;;* ) echoE " Error Input " recoverInfo removeBackupFile exit 1 ;;esac shell判断上一条命令是否成功 1234if [[ ! $? -eq 0 ]]; then echoE " Failed Of Run xcodebuild: Clean " exit 1fi 创建文件夹 1234567891011121314if [ ! -x "$BACKUP_PATH" ]; then mkdir "$BACKUP_PATH" # check if [ ! -x "$BACKUP_PATH" ]; then echoE " Failed Of Create Folder ==&gt; BackupPath: $BACKUP_PATH " exit 1 else echo "\t\c" echoS " Success Of Create Folder ==&gt; BackupPath: $BACKUP_PATH " fielse echo "\t\c" echoS " The Folder Already Exists ==&gt; BackupPath: $BACKUP_PATH "fi copy file 123cp -fr $INFO_PLIST_FILE $BACKUP_PATH"/Info.plist.back"cp -fr $PROJECT_FILE $BACKUP_PATH"/project.pbxproj.back"cp -fr $EXPORT_ARCHIVE_OPTIONS_PILIST_FILE $BACKUP_PATH"/exportArchiveOptions.plist.back" delete dir/file 12rm -rf dirrm -rf file Ruby介绍 变量 全局变量前面加$, 类型变量前面加@@, 对象属性前面加@, 普通变量不用处理 函数 12345678910111213141516# 定义def functionName1 ...end# 调用functionName1# 定义def functionName2 (parameter1 = default1, parameter2 = default2) ...end# 调用functionName2functionName2 parame1, parame2 当前文件路径 1currentPath = Pathname::new(File::dirname(__FILE__)).realpath 文件的父路径 1basePath = currentPath.parent 字符串中使用变量 12# 双引号括起来，#&#123;变量名&#125;即可"#&#123;basePath&#125;/#&#123;infoPlistDirName&#125;/Info.plist" ruby if 语句 1234567if a &lt; 0 ...elsif a &gt; 0 and b &lt; 0 ...else ...end ruby case 语句 12345678case valuewhen 1, 2 ...when 3 ... else ...end 判断文件夹是否存在，删除、创建文件夹 1234567891011# 判断if File.directory?"#&#123;backupPath&#125;" # 强制删除 FileUtils::rm backupPath FileUtils::rm_r backupPath # 非强制删除 Dir::rmdir backupPathend# 创建Dir::mkdir backupPathFileUtils::mkdir backupPath copy file 12FileUtils::cp infoPlistFile, "#&#123;backupPath&#125;/Info.plist.bak"FileUtils::cp_r infoPlistFile, "#&#123;backupPath&#125;/Info.plist.bak" delete dir/file 12345FileUtils::rm fileFileUtils::rm_r fileFileUtils::rm dirPathFileUtils::rm_r dirPath Xcode Build 工具 plist文件修改 /usr/libexec/PlistBuddy 1/usr/libexec/PlistBuddy -c "Set :CFBundleDisplayName $DISPLAY_NAME" $INFO_PLIST_FILE xcodebuild clean 1234xcodebuild clean\ -workspace "./$WORKSPACE_NAME"\ -scheme "$SCHEME_NAME"\ -configuration "$configuration" build archive 1234567891011121314151617xcodebuild\ build\ -workspace "$WORKSPACE_NAME"\ -scheme "$SCHEME_NAME"\ -configuration "$configuration"\ -archivePath "$archivePath"\ CODE_SIGN_IDENTITY="$codeSignIdentity"\ PROVISIONING_PROFILE="$profileName"xcodebuild\ archive\ -workspace "$WORKSPACE_NAME"\ -scheme "$SCHEME_NAME"\ -configuration "$configuration"\ -archivePath "$archivePath"\ CODE_SIGN_IDENTITY="$codeSignIdentity"\ PROVISIONING_PROFILE="$profileName" exportArchive 12345xcodebuild\ -exportArchive\ -exportOptionsPlist "$EXPORT_ARCHIVE_OPTIONS_PILIST_FILE"\ -archivePath "$archivePath"\ -exportPath "$exportPath" exportOptionsPlist Available keys for -exportOptionsPlist: table td:nth-child(1) { white-space: nowrap; } table td:nth-child(2) { white-space: nowrap; } table tr:hover { background: #efefef; } Key Type Description compileBitcode Bool For non-App Store exports, should Xcode re-compile the app from bitcode? Defaults to YES. embedOnDemandResourcesAssetPacksInBundle Bool For non-App Store exports, if the app uses On Demand Resources and this is YES, asset packs are embedded in the app bundle so that the app can be tested without a server to host asset packs. Defaults to YES unless onDemandResourcesAssetPacksBaseURL is specified. iCloudContainerEnvironment \ For non-App Store exports, if the app is using CloudKit, this configures the “com.apple.developer.icloud-container-environment” entitlement. Available options: Development and Production. Defaults to Development. manifest Dictionary For non-App Store exports, users can download your app over the web by opening your distribution manifest file in a web browser. To generate a distribution manifest, the value of this key should be a dictionary with three sub-keys: appURL, displayImageURL, fullSizeImageURL. The additional sub-key assetPackManifestURL is required when using on demand resources. method String Describes how Xcode should export the archive. Available options: app-store, ad-hoc, package, enterprise, development, and developer-id. The list of options varies based on the type of archive. Defaults to development. onDemandResourcesAssetPacksBaseURL String For non-App Store exports, if the app uses On Demand Resources and embedOnDemandResourcesAssetPacksInBundle isn’t YES, this should be a base URL specifying where asset packs are going to be hosted. This configures the app to download asset packs from the specified URL. teamID String The Developer Portal team to use for this export. Defaults to the team used to build the archive. thinning String For non-App Store exports, should Xcode thin the package for one or more device variants? Available options: (Xcode produces a non-thinned universal app), (Xcode produces a universal app and all available thinned variants), or a model identifier for a specific device (e.g. “iPhone7,1”). Defaults to . uploadBitcode Bool For App Store exports, should the package include bitcode? Defaults to YES. uploadSymbols Bool For App Store exports, should the package include symbols? Defaults to YES. markdown表格解析不好，放张图吧： Fastlane介绍 用于项目打包等，Fastlane的一套功能非常强大，远远不止只是打包一种功能，建议到官方文档或者github学习。 官方文档 Github Link xcode-select Install Command: xcode-select --install fastlane Install Command: sudo gem install fastlane -NV xcodeproj介绍用于修改项目的配置，可以用它来修改Xcode的project文件，CocoaPods就是使用的xcodeproj进行创建Pods.xcodeproj项目的。 Github Link Install Command: [sudo] gem install xcodeproj 使用方法 不太建议直接使用，建议学会之后自己写一套适合自己当前项目需求的脚本，这样更符合各个项目的需求。 第一种：run.sh + change_projectpbxproj.rb 将run.sh和change_projectpbxproj.rb放入项目的跟目录下 第二种：Fastfile + change_projectpbxproj.rb 将Fastfile和change_projectpbxproj.rb放入项目的fastlane目录下 注意修改代码 修改部分代码为自己的项目配置，scheme、证书等 代码change_projectpbxproj.rb 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141# change_projectpbxproj.rb# chmod u+x change_projectpbxproj.rbrequire 'xcodeproj'# ======================================================================================================================================= 获取rootTarget# 获取rootTargetdef getRootTarget (project) target = &#123;&#125; project.targets.each do |tar| if tar.name == "wanjia2B" target = tar break end end return targetend# ======================================================================================================================================= 获取对应target的sectionObject# 从project中获取rootTarget对应的sectionObjectdef getRootTargetSectionObject (project, target) sectionObject = &#123;&#125; project.objects.each do |obj| if obj.uuid == target.uuid sectionObject = obj break end end return sectionObjectend# ======================================================================================================================================= 配置project/target/sectionObject# 修改target的配置和sectionObject的配置# target中主要是profile(PROVISIONING_PROFILE_SPECIFIER和PROVISIONING_PROFILE)和bundleID(PRODUCT_BUNDLE_IDENTIFIER)的设置# sectionObject中主要是设置CODE_SIGN_ENTITLEMENTS=xxx.entitlements属性删除或添加（apple push相关）和证书CODE_SIGN_IDENTITY / CODE_SIGN_IDENTITY[sdk=iphoneos*]# 如果需要修改开发团队标记：# =&gt; project中需要修改DevelopmentTeam : project.root_object.attributes["TargetAttributes"][target.uuid]["DevelopmentTeam"] = "xxxxxx"# =&gt; sectionObject中需要修改DEVELOPMENT_TEAM : config.build_settings["DEVELOPMENT_TEAM"] = "xxxxxx"def settingProjectAndTargetAndSectionObject (project, target, sectionObject) ####################################设置target#################################### # 设置target的PROVISIONING_PROFILE_SPECIFIER（证书）和PRODUCT_BUNDLE_IDENTIFIER（bundleID） target.build_configurations.each do |config| if config.name == "Debug" config.build_settings["PROVISIONING_PROFILE_SPECIFIER"] = $debugProfileName elsif config.name == "Release" config.build_settings["PROVISIONING_PROFILE_SPECIFIER"] = $releaseProfileName end config.build_settings["PROVISIONING_PROFILE"]="" config.build_settings["PRODUCT_BUNDLE_IDENTIFIER"] = $bundleID end ####################################设置project#################################### # 设置apple Push是否关闭,如果使用wanjiaWildcard的profile则关闭 if $debugProfileName == "wanjiaWildcard" || $releaseProfileName == "wanjiaWildcard" project.root_object.attributes["TargetAttributes"][target.uuid]["SystemCapabilities"]["com.apple.Push"]["enabled"] = 0 else project.root_object.attributes["TargetAttributes"][target.uuid]["SystemCapabilities"]["com.apple.Push"]["enabled"] = 1 end # 修改DEVELOPMENT_TEAM # project.root_object.attributes["TargetAttributes"][target.uuid]["DevelopmentTeam"] = "xxxxxx" #################################设置sectionObject################################# # 设置sectionObj中的修改CODE_SIGN_ENTITLEMENTS=xxx.entitlements属性删除 # 或添加（apple push相关）和证书的设置 CODE_SIGN_IDENTITY 删除CODE_SIGN_ENTITLEMENTS sectionObject.build_configurations.each do |config| if config.name == "Debug" # 修改debug证书等操作 # 修改CODE_SIGN_IDENTITY config.build_settings["CODE_SIGN_IDENTITY"] = $debugCodeSignIdentity config.build_settings["CODE_SIGN_IDENTITY[sdk=iphoneos*]"] = $debugCodeSignIdentity elsif config.name == "Release" # 修改release证书等操作 # 修改CODE_SIGN_IDENTITY config.build_settings["CODE_SIGN_IDENTITY"] = $releaseCodeSingIdentity config.build_settings["CODE_SIGN_IDENTITY[sdk=iphoneos*]"] = $releaseCodeSingIdentity end # 修改DEVELOPMENT_TEAM # config.build_settings["DEVELOPMENT_TEAM"] = "xxxxxx" # 删除CODE_SIGN_ENTITLEMENTS if $debugProfileName == "wanjiaWildcard" || $releaseProfileName == "wanjiaWildcard" config.build_settings.delete("CODE_SIGN_ENTITLEMENTS") else config.build_settings["CODE_SIGN_ENTITLEMENTS"] = "wanjia2B.entitlements" end end ######################################设置完成######################################end# ======================================================================================================================================= 设置信息（弃用）# # 设置环境变量，现在提前在environment.sh中进行判断了# def setEenvironmentValues# case $projectEenvironment# when 1# $bundleID = "com.pingan.wanjiaBDev"# $debugProfileName = "wanjiaWildcard"# $releaseProfileName = "wanjiaWildcard" # when 2# $bundleID = "com.pingan.wanjiaBTest"# $debugProfileName = "wanjiaWildcard"# $releaseProfileName = "wanjiaWildcard" # else# $bundleID = "com.pingan.wanjiaB"# $debugProfileName = "wanjiaBDev"# $releaseProfileName = "wanjiaBAdhoc"# end# print "\t\tbundleID is: #&#123;$bundleID&#125;\n"# print "\t\tdebugProfileName is: #&#123;$debugProfileName&#125;\n"# print "\t\treleaseProfileName is: #&#123;$releaseProfileName&#125;\n"# end# ======================================================================================================================================= Begin# $projectEenvironment = ARGV[0].to_i$pbxprojFilePath = ARGV[0]$bundleID = ARGV[1]$debugCodeSignIdentity = ARGV[2]$debugProfileName = ARGV[3]$releaseCodeSingIdentity = ARGV[4] $releaseProfileName = ARGV[5]# setEenvironmentValuesproject = Xcodeproj::Project.open($pbxprojFilePath)target = getRootTarget projectsectionObject = getRootTargetSectionObject project, targetsettingProjectAndTargetAndSectionObject project, target, sectionObjectproject.save# 运行成功 退出0exit 0# ======================================================================================================================================= End Fastfile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378# Customise this file, documentation can be found here:# https://github.com/fastlane/fastlane/tree/master/fastlane/docs# All available actions: https://docs.fastlane.tools/actions# can also be listed using the `fastlane actions` command# Change the syntax highlighting to Ruby# All lines starting with a # are ignored when running `fastlane`# If you want to automatically update fastlane if a new version is available:# update_fastlane# This is the minimum version number required.# Update this, if you use features of a newer versionfastlane_version "2.28.3"default_platform :iosplatform :ios do schemeName = "wanjia2B" infoPlistDirName = "wanjia" xcodeprojFile = "#&#123;schemeName&#125;.xcodeproj" workspaceName = "#&#123;schemeName&#125;.xcworkspace" basePath = Pathname::new(File::dirname(__FILE__)).realpath.parent infoPlistFile = "#&#123;basePath&#125;/#&#123;infoPlistDirName&#125;/Info.plist" pbxprojFilePath = "#&#123;basePath&#125;/#&#123;xcodeprojFile&#125;" pbxprojFile = "#&#123;pbxprojFilePath&#125;/project.pbxproj" # 其他配置文件 configFile = "#&#123;basePath&#125;/wanjia/Headers/PAAppConfig.swift" backupPath = "#&#123;basePath&#125;/.backup_info" isBackup = false # default env： AppStore env = "appstore" displayName = "万家医疗" bundleID = "com.pingan.wanjiaB" debugProfileName="wanjiaBDev" releaseProfileName="wanjiaBDistribution" debugCodeSignIdentity="iPhone Developer: bingyu zhou (ES59BFTTFG)" releaseCodeSignIdentity="iPhone Distribution: PingAn Wanjia Healthcare Investment Management Co., Ltd (6GA5676ZM3)" exportMethod="app-store" desc "初始化信息" private_lane :setupInfomations do |options| putsB "Begin Get Environment Values" env = String(options[:env] || "appstore") case env when "appstore", "0" env = "appstore" # 不操作 when "adhoc", "1" #Ad-hoc env = "adhoc" displayName="万家医疗-AdHoc" bundleID="com.pingan.wanjiaB" debugProfileName="wanjiaBDev" releaseProfileName="wanjiaBAdhoc" debugCodeSignIdentity="iPhone Developer: bingyu zhou (ES59BFTTFG)" releaseCodeSignIdentity="iPhone Distribution: PingAn Wanjia Healthcare Investment Management Co., Ltd (6GA5676ZM3)" exportMethod="ad-hoc" when "dev", "2" #dev env = "dev" displayName="万家医疗-开发" bundleID="com.pingan.wanjiaBDev" debugProfileName="wanjiaWildcard" releaseProfileName="wanjiaWildcard" debugCodeSignIdentity="iPhone Developer: bingyu zhou (ES59BFTTFG)" releaseCodeSignIdentity="iPhone Developer: bingyu zhou (ES59BFTTFG)" exportMethod="development" when "test", "3" #test env = "test" displayName="万家医疗-测试" bundleID="com.pingan.wanjiaBTest" debugProfileName="wanjiaWildcard" releaseProfileName="wanjiaWildcard" debugCodeSignIdentity="iPhone Developer: bingyu zhou (ES59BFTTFG)" releaseCodeSignIdentity="iPhone Developer: bingyu zhou (ES59BFTTFG)" exportMethod="development" else putsE "Error Environment Type" exit 1 end putsI "\t DisplayName: #&#123;displayName&#125; " putsI "\t BundleID: #&#123;bundleID&#125; " putsI "\t DebugProfileName: #&#123;debugProfileName&#125; " putsI "\t ReleaseProfileName: #&#123;releaseProfileName&#125; " putsI "\t Project Base Path: #&#123;basePath&#125;" putsI "\t Project File: #&#123;pbxprojFilePath&#125; " putsI "\t pbxproj File Path: #&#123;pbxprojFilePath&#125; " putsI "\t Workspace File: #&#123;basePath&#125;/#&#123;workspaceName&#125; " putsI "\t Info.plist File: #&#123;infoPlistFile&#125; " putsI "\t project.pbxproj File: #&#123;pbxprojFile&#125; " putsS "Success Of Get Environment Values" end desc "备份信息" private_lane :backupCurrentInfo do putsB "Begin Backup Current Infomation: plist xcodeproj" if File.directory?"#&#123;backupPath&#125;" FileUtils::rm_r backupPath end FileUtils::mkdir backupPath FileUtils::cp_r infoPlistFile, "#&#123;backupPath&#125;/Info.plist.bak" FileUtils::cp_r pbxprojFile, "#&#123;backupPath&#125;/project.pbxproj.bak" FileUtils::cp_r configFile, "#&#123;backupPath&#125;/PAAppConfig.swift.bak" putsS "Success Of Backup Current Infomation" isBackup = true end desc "删除备份信息" private_lane :removeBackupInfo do putsB "Begin Remove Infomation Folder &amp; File ==&gt; BackupPath: #&#123;backupPath&#125;" if File.directory?"#&#123;backupPath&#125;" FileUtils::rm_r backupPath end putsS "Success Of Remove Infomation Folder &amp; File ==&gt; BackupPath: #&#123;backupPath&#125;" isBackup = false end desc "修改当前信息" private_lane :changeInfomations do |options| putsB "Begin Change 'Info.plist' &amp; .pbxproj File ==&gt; Info.plist: #&#123;infoPlistFile&#125; , pbxprojFile: #&#123;pbxprojFile&#125;" # available options: xcodeproj, plist_path, scheme, app_identifier, display_name, block update_info_plist( plist_path: "./wanjia/Info.plist", app_identifier: bundleID, display_name: displayName, ) run_rubyFile_script = "ruby 'change_projectpbxproj.rb' '#&#123;pbxprojFilePath&#125;' '#&#123;bundleID&#125;' '#&#123;debugCodeSignIdentity&#125;' '#&#123;debugProfileName&#125;' '#&#123;releaseCodeSignIdentity&#125;' '#&#123;releaseProfileName&#125;'" sh run_rubyFile_script env = String(options[:env] || "appstore") conf = String(options[:conf] || "debug") isToAppStore = false if (env == "appstore" || env == "0") &amp;&amp; conf == "release" isToAppStore = true end change_configFile_script = "sed -i '' 's/^.*static let isToAppStore.*$/ static let isToAppStore = #&#123;isToAppStore&#125;/g' #&#123;configFile&#125;" sh change_configFile_script # 因为除了改这些之外还要修改其他东西 所以直接用change_projectpbxproj.rb修改算了 # update_app_identifier( # xcodeproj: xcodeprojFile, # plist_path: "./#&#123;infoPlistDirName&#125;/Info.plist", # app_identifier: bundleID, # ) # update_project_provisioning( # xcodeproj: xcodeprojFile, # target_filter: schemeName, # build_configuration: "Release", # profile: releaseProfileName, # certificate: releaseCodeSignIdentity, # ) # update_project_provisioning( # xcodeproj: xcodeprojFile, # target_filter: schemeName, # build_configuration: "Debug", # profile: debugProfileName, # certificate: debugCodeSignIdentity, # ) putsS "Success Of Change 'Info.plist' &amp; .pbxproj File ==&gt; Info.plist: #&#123;infoPlistFile&#125; , pbxprojFile: #&#123;pbxprojFile&#125;" end desc "恢复备份信息并删除备份" private_lane :recoverInfoations do putsB "Begin Recover Infomation: plist xcodeproj" FileUtils::cp_r "#&#123;backupPath&#125;/Info.plist.bak", infoPlistFile FileUtils::cp_r "#&#123;backupPath&#125;/project.pbxproj.bak", pbxprojFile FileUtils::cp_r "#&#123;backupPath&#125;/PAAppConfig.swift.bak", configFile putsS "Success Of Recover Infomation" removeBackupInfo isBackup = false end desc "输出使用方式" lane :options do puts "\033[32m======================================================================================================================================\033[m" puts "\033[47;30m Environment Configuration: \033[m" puts " It's Need Install: \033[32mXcode &amp; Ruby\033[m, and Install Ruby Library: \033[32mxcodeproj\033[m &amp; \033[32mfastlane\033[m. " puts " How To Install Ruby Library 'xcodeproj' ? " puts " Install Command: \033[35m[sudo] gem install xcodeproj\033[m " puts " Github Link: \033[35mhttps://github.com/CocoaPods/Xcodeproj\033[m " puts " How To Install Ruby Library 'fastlane' ? " puts " Before Install 'fastlane', Make Sure You Have The Latest Version Of The Xcode Command Line Tools Installed: " puts " Xcode Command Line Install Command: \033[35mxcode-select --install\033[m " puts " Then 'fastlane' Install Command: \033[35msudo gem install fastlane -NV\033[m " puts " 'fastlane' Github Link: \033[35mhttps://github.com/fastlane/fastlane\033[m " puts "\033[32m--------------------------------------------------------------------------------------------------------------------------------------\033[m" puts "\033[47;30m Parameter Instructions: \033[m" puts " \033[32m options \033[m" puts " Show how to use this script. " puts " eg: fastlane options " puts " \033[32m setinfo env:'env' conf:'configuration' \033[m" puts " 'env'can use 'appstore/adhoc/dev/test' or '0/1/2/3', default is 'appstore'; If input error, env is 'appstore'." puts " 'configuration' can use 'debug' or 'release', default is 'debug; If input error, configuration is 'debug'. " puts " Change info to 'env' environment &amp; \033[31mSAVE backup\033[m. In the end, will open Xcode. " puts " eg: fastlane setinfo env:test ; fastlane setinfo " puts " \033[32m recoverinfo \033[m" puts " Just recover infomation from the infomation backup, and then, remove backup folder. In the end, will open Xcode. " puts " eg: fastlane recoverinfo " puts " \033[32m resetinfo env:'env' conf:'configuration' \033[m" puts " 'env' default is 'appstore'. Reset infomation to 'env' environment. In the end, will open Xcode. " puts " 'configuration' can use 'debug' or 'release', default is 'debug; If input error, configuration is 'debug'. " puts " \033[31mDON'T SAVE backup and REMOVE ALL backup folder/file\033[m. " puts " eg: fastlane resetinfo env:dev " puts " \033[32m build \033[m" puts " Just build. " puts " eg: fastlane build " puts " \033[32m archive env:'env' conf:'configuration'\033[m" puts " 'env' default is 'appstore'; " puts " 'configuration' can use 'debug' or 'release', default is 'release'; If input error, configuration is 'release'. " puts " eg: fastlane archive env:appstore conf:release ; fastlane archive env:adhoc; fastlane archive" puts "\033[32m======================================================================================================================================\033[m" end before_all do end desc "设置信息，并保存备份；参数 =&gt; env:'env'" lane :setinfo do |options| setupInfomations options backupCurrentInfo changeInfomations options end desc "恢复备份信息并删除备份" lane :recoverinfo do recoverInfoations end desc "仅设置信息，并删除现有备份；参数 =&gt; env:'env'" lane :resetinfo do |options| setupInfomations options changeInfomations options removeBackupInfo end desc "编译项目" lane :build do cocoapods xcodebuild( silent: true, clean: true, build: true, workspace: workspaceName, scheme: schemeName, configuration: "Release", destination: "generic/platform=iOS", build_settings: &#123; "CODE_SIGN_IDENTITY" =&gt; "", "CODE_SIGNING_REQUIRED" =&gt; "NO" &#125;, ) end desc "打包； 参数 =&gt; env:'env' conf:debug/release" lane :archive do |options| env = String(options[:env] || "appstore") conf = String(options[:conf] || "release") if conf == "debug" configuration = "Debug" profileName = debugProfileName codeSignIdentity = debugCodeSignIdentity else configuration = "Release" profileName = releaseProfileName codeSignIdentity = releaseCodeSignIdentity end setinfo env:env, conf:conf time = Time::new currentTime = time.strftime("%Y-%m-%d/%H_%M_%S") buildPath = "#&#123;basePath&#125;/build/#&#123;schemeName&#125;-#&#123;env&#125;/#&#123;currentTime&#125;" exportPath = "~/Desktop/#&#123;schemeName&#125;-#&#123;env&#125;/#&#123;currentTime&#125;" customName = "#&#123;schemeName&#125;-#&#123;env&#125;-#&#123;configuration&#125;" # xcarchiveName ="#&#123;customName&#125;.xcarchive" ipaName = "#&#123;customName&#125;.ipa" cocoapods # sigh( # app_identifier: bundleID, # provisioning_name: profileName, # cert_owner_name: codeSignIdentity, # skip_install: true, # skip_fetch_profiles: true, # skip_certificate_verification: true, # ) # unlock_keychain( # path: "/path/to/KeychainName.keychain", # password: "mysecret" # ) gym( silent: true, clean: true, workspace: workspaceName, scheme: schemeName, configuration: configuration, export_method: exportMethod, build_path: buildPath, output_directory: exportPath, output_name: ipaName, ) recoverinfo putsS "IPA DIR &amp; NAME IS : ipaDir ==&gt; #&#123;exportPath&#125;, ipaName ==&gt; #&#123;ipaName&#125;, archiveDir ==&gt; #&#123;buildPath&#125;" end after_all do |lane| end error do |lane, exception, options| putsE "#&#123;lane&#125; Is Failed: Runing Error, is backup? =&gt; #&#123;isBackup&#125;" if "#&#123;lane&#125;" == "build" || "#&#123;lane&#125;" == "archive" # 发邮件 end if isBackup == true recoverInfoations end end # 输出infomation等信息 def putsI (option) puts "\033[40;37m#&#123;option&#125;\033[m" end # 输出开始信息 def putsB (option) puts "\033[33m#&#123;option&#125;\033[m" puts "" end # 输出成功信息 def putsS (option) puts "\033[32m#&#123;option&#125;\033[m" puts "" end # 输出error信息 def putsE (option) puts "\033[41;37m #&#123;option&#125; \033[m" puts "" endend# More information about multiple platforms in fastlane: https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Platforms.md# All available actions: https://docs.fastlane.tools/actions# fastlane reports which actions are used# No personal data is recorded. Learn more at https://github.com/fastlane/enhancer run.sh 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528#bin/sh/# run.sh# chmod u+x run.sh# 格式如下:# echo -e "\033[字背景颜色;文字颜色m字符串\033[0m"# echo -e "\033[30m 黑色字 \033[0m"# echo -e "\033[31m 红色字 \033[0m"# echo -e "\033[32m 绿色字 \033[0m"# echo -e "\033[33m 黄色字 \033[0m"# echo -e "\033[34m 蓝色字 \033[0m"# echo -e "\033[35m 紫色字 \033[0m"# echo -e "\033[36m 天蓝字 \033[0m"# echo -e "\033[37m 白色字 \033[0m"# echo -e "\033[40;37m 黑底白字 \033[0m"# echo -e "\033[41;37m 红底白字 \033[0m"# echo -e "\033[42;37m 绿底白字 \033[0m"# echo -e "\033[43;37m 黄底白字 \033[0m"# echo -e "\033[44;37m 蓝底白字 \033[0m"# echo -e "\033[45;37m 紫底白字 \033[0m"# echo -e "\033[46;37m 天蓝底白字 \033[0m"# echo -e "\033[47;30m 白底黑字 \033[0m"# 打印规则# echo "\033[33m Begin info \033[m"# echo "\033[41;37m Failed info \033[m \n"# echo "\033[32m Success info \033[m \n"# Available keys for -exportOptionsPlist:# compileBitcode : Bool# For non-App Store exports, should Xcode re-compile the app from bitcode? Defaults to YES.# embedOnDemandResourcesAssetPacksInBundle : Bool# For non-App Store exports, if the app uses On Demand Resources and this is YES, asset packs are embedded in the app bundle so that the app can be tested without a server to host asset packs. Defaults to YES unless onDemandResourcesAssetPacksBaseURL is specified.# iCloudContainerEnvironment# For non-App Store exports, if the app is using CloudKit, this configures the "com.apple.developer.icloud-container-environment" entitlement. Available options: Development and Production. Defaults to Development.# manifest : Dictionary# For non-App Store exports, users can download your app over the web by opening your distribution manifest file in a web browser. To generate a distribution manifest, the value of this key should be a dictionary with three sub-keys: appURL, displayImageURL, fullSizeImageURL. The additional sub-key assetPackManifestURL is required when using on demand resources.# method : String# Describes how Xcode should export the archive. Available options: app-store, ad-hoc, package, enterprise, development, and developer-id. The list of options varies based on the type of archive. Defaults to development.# onDemandResourcesAssetPacksBaseURL : String# For non-App Store exports, if the app uses On Demand Resources and embedOnDemandResourcesAssetPacksInBundle isn't YES, this should be a base URL specifying where asset packs are going to be hosted. This configures the app to download asset packs from the specified URL.# teamID : String# The Developer Portal team to use for this export. Defaults to the team used to build the archive.# thinning : String# For non-App Store exports, should Xcode thin the package for one or more device variants? Available options: &lt;none&gt; (Xcode produces a non-thinned universal app), &lt;thin-for-all-variants&gt; (Xcode produces a universal app and all available thinned variants), or a model identifier for a specific device (e.g. "iPhone7,1"). Defaults to &lt;none&gt;.# uploadBitcode : Bool# For App Store exports, should the package include bitcode? Defaults to YES.# uploadSymbols : Bool# For App Store exports, should the package include symbols? Defaults to YES.# ======================================================================================================================================= 全局变量 SCHEME_NAME="wanjia2B"INFO_PLIST_DIR="wanjia"PROJECT_FILE_NAME="$SCHEME_NAME.xcodeproj"WORKSPACE_NAME="$SCHEME_NAME.xcworkspace"BASE_PATH=$(cd `dirname $0`; pwd)INFO_PLIST_FILE="$BASE_PATH/$INFO_PLIST_DIR/Info.plist"PROJECT_FILE_PATH="$BASE_PATH/$PROJECT_FILE_NAME"PROJECT_FILE="$PROJECT_FILE_PATH/project.pbxproj"BACKUP_PATH="$BASE_PATH/.backup_info"EXPORT_ARCHIVE_OPTIONS_PILIST_FILE="$BASE_PATH/exportArchiveOptions.plist"# 输出开始信息echoB() &#123; echo "\033[33m$1\033[m"&#125;# 输出成功信息echoS() &#123; echo "\033[32m$1\033[m \n"&#125;# 输出error信息echoE() &#123; echo "\033[41;37m$1\033[m \n "&#125;# 输出infomation等信息echoI() &#123; echo "\033[40;37m$1\033[m"&#125;# ======================================================================================================================================= 设置信息setupInfomations() &#123; echoB " Begin Get Environment Values " if [[ $ENV_TYPE == "" ]]; then ENV_TYPE=0 fi ENV_TYPE=`expr $ENV_TYPE + 0` # method = app-store, ad-hoc, package, enterprise, development, and developer-id case $ENV_TYPE in 0 ) # AppStore DISPLAY_NAME="万家医疗" BUNDLE_ID="com.pingan.wanjiaB" DEBUG_PROFILE_NAME="wanjiaBDev" RELEASE_PROFILE_NAME="wanjiaBDistribution" DEBUG_CODE_SIGN_IDENTITY="iPhone Developer: bingyu zhou (ES59BFTTFG)" RELEASE_CODE_SIGN_IDENTITY="iPhone Distribution: PingAn Wanjia Healthcare Investment Management Co., Ltd (6GA5676ZM3)" EXPORT_MRTHOD="app-store" ;; 1 ) # AdHoc DISPLAY_NAME="万家医疗" BUNDLE_ID="com.pingan.wanjiaB" DEBUG_PROFILE_NAME="wanjiaBDev" RELEASE_PROFILE_NAME="wanjiaBAdhoc" DEBUG_CODE_SIGN_IDENTITY="iPhone Developer: bingyu zhou (ES59BFTTFG)" RELEASE_CODE_SIGN_IDENTITY="iPhone Distribution: PingAn Wanjia Healthcare Investment Management Co., Ltd (6GA5676ZM3)" EXPORT_MRTHOD="ad-hoc" ;; 2 ) # Dev DISPLAY_NAME="万家医疗-开发" BUNDLE_ID="com.pingan.wanjiaBDev" DEBUG_PROFILE_NAME="wanjiaWildcard" RELEASE_PROFILE_NAME="wanjiaWildcard" DEBUG_CODE_SIGN_IDENTITY="iPhone Developer: bingyu zhou (ES59BFTTFG)" RELEASE_CODE_SIGN_IDENTITY="iPhone Developer: bingyu zhou (ES59BFTTFG)" EXPORT_MRTHOD="development" ;; 3 ) # Test DISPLAY_NAME="万家医疗-测试" BUNDLE_ID="com.pingan.wanjiaBTest" DEBUG_PROFILE_NAME="wanjiaWildcard" RELEASE_PROFILE_NAME="wanjiaWildcard" DEBUG_CODE_SIGN_IDENTITY="iPhone Developer: bingyu zhou (ES59BFTTFG)" RELEASE_CODE_SIGN_IDENTITY="iPhone Developer: bingyu zhou (ES59BFTTFG)" EXPORT_MRTHOD="development" ;; * ) echoE " Error Environment Type " exit 1 ;; esac echoI "\t DisplayName: $DISPLAY_NAME " echoI "\t BundleID: $BUNDLE_ID " echoI "\t DebugProfileName: $DEBUG_PROFILE_NAME " echoI "\t ReleaseProfileName: $RELEASE_PROFILE_NAME " echoI "\t Project Path: $BASE_PATH " echoI "\t Project File Path: $PROJECT_FILE_PATH " echoI "\t Workspace File Path: $BASE_PATH/$WORKSPACE_NAME " echoI "\t Info.plist File: $INFO_PLIST_FILE " echoI "\t project.pbxproj File: $PROJECT_FILE " echoS " Success Of Get Environment Values "&#125;# ======================================================================================================================================= 备份函数backupCurrentInfo() &#123; echoB " Begin Backup Current Infomation: plist xcodeproj " if [ ! -x "$BACKUP_PATH" ]; then mkdir "$BACKUP_PATH" # check if [ ! -x "$BACKUP_PATH" ]; then echoE " Failed Of Create Folder ==&gt; BackupPath: $BACKUP_PATH " exit 1 else echo "\t\c" echoS " Success Of Create Folder ==&gt; BackupPath: $BACKUP_PATH " fi else echo "\t\c" echoS " The Folder Already Exists ==&gt; BackupPath: $BACKUP_PATH " fi # unaslias cp cp -fr $INFO_PLIST_FILE $BACKUP_PATH"/Info.plist.back" cp -fr $PROJECT_FILE $BACKUP_PATH"/project.pbxproj.back" cp -fr $EXPORT_ARCHIVE_OPTIONS_PILIST_FILE $BACKUP_PATH"/exportArchiveOptions.plist.back" echoS " Success Of Backup Current Infomation "&#125;# ======================================================================================================================================= 修改Info.plistchangeInfoPlist() &#123; echoB " Begin Change 'Info.plist' File ==&gt; Info.plist: $INFO_PLIST_FILE " # 设置CFBundleDisplayName /usr/libexec/PlistBuddy -c "Set :CFBundleDisplayName $DISPLAY_NAME" $INFO_PLIST_FILE # # 获取buildNumber并+1 # buildNumber=$(/usr/libexec/PlistBuddy -c "Print CFBundleVersion" "$INFO_PLIST_FILE") # echo "New buildNumber is: $buildNumber" # buildNumber=`expr "$buildNumber + 1"|bc` # # 设置CFBundleVersion # /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $buildNumber" $INFO_PLIST_FILE echoS " Success Of Change 'Info.plist' File ==&gt; Info.plist: $INFO_PLIST_FILE "&#125;# ======================================================================================================================================= 运行ruby脚本修改project文件 runRubyScriptToChangeProjectFile() &#123; rubyFile="change_projectpbxproj.rb" echoB " Begin Run Ruby Script To Change 'ProjectFile' ==&gt; Ruby: $rubyFile; ProjectFile: $PROJECT_FILE " ruby "$rubyFile" "$PROJECT_FILE_PATH" "$BUNDLE_ID" "$DEBUG_CODE_SIGN_IDENTITY" "$DEBUG_PROFILE_NAME" "$RELEASE_CODE_SIGN_IDENTITY" "$RELEASE_PROFILE_NAME" if [[ $? != 0 ]]; then echoE " Failed Of Run Ruby Script ==&gt; Ruby: $rubyFile; ProjectFile: $PROJECT_FILE " # error退出之前恢复并清空备份信息 recoverInfo removeBackupFile exit 1 fi echoS " Success Of Run Ruby Script ==&gt; Ruby: $rubyFile; ProjectFile: $PROJECT_FILE "&#125;# ======================================================================================================================================= 更改信息函数: 会更改info.plist和projec文件不会修改exportArchiveOptions.plistchangeInfomation() &#123; setupInfomations changeInfoPlist runRubyScriptToChangeProjectFile&#125;# changeInfomation() &#123;# # change environment value# setupInfomations# shellFile="change_infoplist_projectpbxproj.sh"# echoB " Begin Run Shell To Change Environment Values ==&gt; $shellFile "# sh "$shellFile" "$BASE_PATH" "$INFO_PLIST_FILE" "$PROJECT_FILE_PATH" "$DISPLAY_NAME" "$BUNDLE_ID" "$DEBUG_PROFILE_NAME" "$RELEASE_PROFILE_NAME"# if [[ $? != 0 ]]; then# echoE " Failed Of Run Shell ==&gt; $shellFile "# # error退出之前恢复并清空备份信息# recoverInfo# removeBackupFile# exit 1# fi# echoS " Success Of Run Shell ==&gt; $shellFile "# # change environment value success# &#125;# ======================================================================================================================================= 恢复函数 recoverInfo() &#123; echoB " Begin Recover Infomation: plist xcodeproj " cp -fr $BACKUP_PATH"/Info.plist.back" $INFO_PLIST_FILE cp -fr $BACKUP_PATH"/project.pbxproj.back" $PROJECT_FILE cp -fr $BACKUP_PATH"/exportArchiveOptions.plist.back" $EXPORT_ARCHIVE_OPTIONS_PILIST_FILE echoS " Success Of Recover Infomation "&#125;# ======================================================================================================================================= 删除备份函数 removeBackupFile() &#123; echoB " Begin Remove Infomation Folder &amp; File ==&gt; BackupPath: $BACKUP_PATH " ### !!!Dangerous Command， Please Do Not Optionally Modify!!! ### if [[ $BACKUP_PATH == "" ]]; then echoE " It Will Run Dangerous Command 'rm -rf' " exit 1 fi rm -rf $BACKUP_PATH echoS " Success Of Remove Infomation Folder &amp; File ==&gt; BackupPath: $BACKUP_PATH "&#125;# # ======================================================================================================================================= clean函数 # cleanProjectWithType() &#123;# cleanType="$1"# case $cleanType in# "y" | "Y" | "yes" | "YES" )# echoB "============================== Begin Clean =============================="# xcodebuild clean# echoS "=========================== Success Of Clean ============================"# ;;# "n" | "N" | "no" | "NO" )# echoS "============================= Skip To Clean ============================="# ;;# * )# echoE " Error Input "# recoverInfo# removeBackupFile# exit 1# ;;# esac# &#125;# # # ======================================================================================================================================= build函数 # buildProject() &#123;# # clean?# cleanType="$1"# case $cleanType in# "y" | "Y" | "yes" | "YES" | "n" | "N" | "no" | "NO" )# ;;# * )# read -p " would you need clean(y/n): " cleanType# ;;# esac# cleanProjectWithType $cleanType # # 编译 # echoB "============================== Begin Compail Source File =============================="# xcodebuild\# -workspace $WORKSPACE_NAME\# -scheme $SCHEME_NAME# echoS "=========================== Success Of Compail Source File ============================"# &#125;# ======================================================================================================================================= 修改export配置: 只有archive时候才需要修改 changeExportArchiveOptionsPlist() &#123; echoB " Begin Change 'exportArchiveOptions.plist' File ==&gt; exportArchiveOptions.plist: $EXPORT_ARCHIVE_OPTIONS_PILIST_FILE " /usr/libexec/PlistBuddy -c "Set :method $EXPORT_MRTHOD" "$EXPORT_ARCHIVE_OPTIONS_PILIST_FILE" echoS " Success Of Change 'exportArchiveOptions.plist' File ==&gt; exportArchiveOptions.plist: $EXPORT_ARCHIVE_OPTIONS_PILIST_FILE "&#125;# ======================================================================================================================================= archive函数 archiveProject() &#123; setupInfomations if [[ "$1" == "-d" ]]; then configuration="Debug" codeSignIdentity="$DEBUG_CODE_SIGN_IDENTITY" profileName="$DEBUG_PROFILE_NAME" else configuration="Release" codeSignIdentity="$RELEASE_CODE_SIGN_IDENTITY" profileName="$RELEASE_PROFILE_NAME" fi changeExportArchiveOptionsPlist currentTime="`date +%Y-%m-%d/%H_%M_%S`" archivePath="build/$SCHEME_NAME-$EXPORT_MRTHOD/$currentTime.xcarchive" exportPath="~/Desktop/$SCHEME_NAME-$EXPORT_MRTHOD/$currentTime" # # clean # echoB "=================================== Begin Clean ==================================" # # xcodebuild clean -project TestAutoPacking.xcodeproj -scheme TestAutoPacking -configuration Release # # xcodebuild clean -workspace TestAutoPacking.xcworkspace -scheme TestAutoPacking -configuration Release # # 上面的命令中: # # -project TestAutoPacking.xcodeproj:编译项目名称 # # -workspace TestAutoPacking.xcworkspace:编译工作空间名称 # # -scheme TestAutoPacking:scheme名称(一般会与你的项目名称相同) # # -configuration Release:(Debug/Release) # xcodebuild clean\ # -workspace "./$WORKSPACE_NAME"\ # -scheme "$SCHEME_NAME"\ # -configuration "$configuration" # if [[ ! $? -eq 0 ]]; then # echoE " Failed Of Run xcodebuild: Clean " # exit 1 # fi # echoS "================================ Success Of Clean ================================" # build and archive echoB "============================= Begin Build &amp; Archive ==============================" # xcodebuild archive -project TestAutoPacking.xcodeproj -scheme TestAutoPacking -archivePath /dandy/xmeAutoArchive/TestAutoPacking.xcarchive # xcodebuild archive -workspace TestAutoPacking.xcworkspace -scheme TestAutoPacking -archivePath /dandy/xmeAutoArchive/TestAutoPacking.xcarchive # =========--------------- # xcodebuild\ # archive\ # -workspace "$WORKSPACE_NAME"\ # -scheme "$SCHEME_NAME"\ # -configuration "$configuration"\ # -archivePath "$archivePath"\ # CODE_SIGN_IDENTITY="$codeSignIdentity"\ # PROVISIONING_PROFILE="$profileName"\ # # PRODUCT_BUNDLE_IDENTIFIER="$BUNDLE_ID" # if [[ ! $? -eq 0 ]]; then # echoE " Failed Of Run xcodebuild: Build &amp; Archive " # exit 1 # fi # echoS "=========================== Success Of Build &amp; Archive ===========================" # # exportArchive # echoB "============================== Begin Export Archive ==============================" # # 上面的命令中: # # -archivePath /dandy/xmeAutoArchive/TestAutoPacking.xcarchive:刚刚导出的.xcarchive文件的目录 # # -exportPath /dandy/xmeAutoArchive/TestAutoPacking:将要导出的ipa文件的目录以及文件名 # # -exportFormat ipa:导出为ipa文件 # # -exportProvisioningProfile "developmentProfile":你配置的profile文件的名称: # xcodebuild\ # -exportArchive\ # -exportOptionsPlist "$EXPORT_ARCHIVE_OPTIONS_PILIST_FILE"\ # -archivePath "$archivePath"\ # -exportPath "$exportPath" # ---------------- pod install fastlane sigh\ --username "null"\ --app_identifier "$&#123;BUNDLE_ID&#125;"\ --provisioning_name "$&#123;profileName&#125;"\ --cert_owner_name "$&#123;codeSignIdentity&#125;"\ --skip_fetch_profiles "true"\ --skip_certificate_verification "true"\ fastlane gym\ --clean "true"\ --silent "true"\ --workspace "$&#123;WORKSPACE_NAME&#125;"\ --scheme "$&#123;SCHEME_NAME&#125;"\ --configuration "$&#123;configuration&#125;"\ --export_method "$&#123;EXPORT_MRTHOD&#125;"\ --output_directory "$&#123;exportPath&#125;"\ --output_name "wanjia2B-$&#123;EXPORT_MRTHOD&#125;-$&#123;configuration&#125;.ipa" --provisioning_profile_path "$&#123;profileName&#125;" --codesigning_identity "$&#123;codeSignIdentity&#125;" # --archive_path "$&#123;archivePath&#125;"\ # fastlane sigh resign ./path/app.ipa --signing_identity "iPhone Distribution: Felix Krause" -p "my.mobileprovision" if [[ ! $? -eq 0 ]]; then echoE " Failed Of Run xcodebuild: Export Archive " exit 1 fi echoS "============================ Success Of Export Archive ============================" echo "\033[42;37m Export ipa File Path ==&gt; wanjia2B.ipa: $exportPath \033[0m" open -a Finder "$&#123;exportPath&#125;"&#125;# ======================================================================================================================================= help函数 echoHelp() &#123; echo "" echo "\033[47;30m Environment Configuration: \033[m" echo " First: Move The Files To You Project Root Directory;" echo " And Then: It's Need Install: \033[32mXcode &amp; Ruby\033[m, and Install Ruby Library: \033[32mxcodeproj\033[m. " echo " How To Install Ruby Library 'xcodeproj' ? " echo " Install Command: \033[35m[sudo] gem install xcodeproj\033[m " echo " Github Link: \033[35mhttps://github.com/CocoaPods/Xcodeproj\033[m " echo "" echo "\033[47;30m Parameter Instructions: \033[m" echo " \033[32m -h | --help \033[m" echo " Show how to use this shell script. " echo " \033[32m 'num'\033[m" echo " It will run: setInfo 'num' ; 0 is AppStore; 1 is AdHoc; 2 is Dev; 3 is Test. " echo " eg: info.sh 1 " echo " \033[32m setInfo 'num'\033[m" echo " 'num' default is 0. Change info to 'num' environment &amp; \033[31mSAVE backup\033[m. In the end, will open Xcode. " echo " eg: info.sh changeInfo 1 " echo " \033[32m recoverInfo\033[m" echo " Just recover infomation from the infomation backup, and then, remove backup folder. In the end, will open Xcode. " echo " eg: info.sh recoverInfo " echo " \033[32m reset 'num'\033[m" echo " 'num' default is 0. Just reset infomation to 'num' environment &amp; \033[31mDON'T SAVE backup and REMOVE ALL backup folder/file\033[m. In the end, will open Xcode. " echo " eg: info.sh reset 0 " echo " \033[32m archive 'num' 'configuration'\033[m" echo " 'num' default is 0; 'configuration' can use '-d' or '-r', default is '-r', if input error, configuration is '-r'. " echo " eg: info.sh archive 0 -d " echo ""&#125;# ======================================================================================================================================= 解析运行参数函数 parserParameter() &#123; parameter="$1" case $parameter in "" | "-h" | "--help" ) echoHelp ;; # 仅仅修改信息 "setInfo" ) ENV_TYPE=$2 backupCurrentInfo changeInfomation open -a Xcode $WORKSPACE_NAME ;; # # 仅仅进行编译 # "build" ) # buildProject # ;; # 仅仅恢复信息 "recoverInfo" ) echo " recover is copy the backup files to cover current files， if you change some infomation before this command, you will lose the change, suggest you run 'reset' command. " read -p " would you need recover from backup; maybe lose some infomation (only input 'Y/y' will recoverInfo): " recoverSureType if [[ "$recoverSureType" == "y" || "$recoverSureType" == "Y" ]]; then recoverInfo removeBackupFile open -a Xcode $WORKSPACE_NAME fi ;; # reset所有信息并不保存且删除所有备份 "reset" ) read -p " would you need reset to normal(only input 'Y/y' will reset): " resetSureType if [[ "$resetSureType" == "y" || "$resetSureType" == "Y" ]]; then ENV_TYPE=$2 changeInfomation changeExportArchiveOptionsPlist removeBackupFile open -a Xcode $WORKSPACE_NAME fi ;; # 打包 "archive" ) ENV_TYPE=$2 archiveProject $3 ;; * ) # 判断是否是数字 # if grep '^[[:digit:]]*$' &lt;&lt;&lt; "$1"; then expr $1 + 1 &amp;&gt; /dev/null if [[ $1 == -1 || $? -eq 0 ]]; then # 是数字 parserParameter "setInfo" $1 else # 不是数字 echoE " Error Parameter Type " exit 1 fi ;; esac exit 0&#125;# ======================================================================================================================================= BeginparserParameter $1 $2 $3# ======================================================================================================================================= End]]></content>
      <categories>
        <category>脚本</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Bash</tag>
        <tag>Ruby</tag>
        <tag>脚本</tag>
        <tag>xcodeproj</tag>
        <tag>Fastlane</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode项目添加 TODO & FIXME 注释警告]]></title>
    <url>%2F2017%2F04%2F20%2FiOS%2F17042001.Xcode%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%20TODO%20%26%20FIXME%20%E6%B3%A8%E9%87%8A%E8%AD%A6%E5%91%8A%2Findex%2F</url>
    <content type="text"><![CDATA[添加Run Script依次点击选择：TARGETS(select one target) | Build Phases | + | New Run Script Phase ，如下图：编辑Run Script 使用下面两种方法其中之一都可以，建议使用第二中文件方式。 （因为Run Script中代码就算换行，xcode文件保存皆为一行代码，如果修改其中一行代码，就会修改所有，很难管理） 完成之后在.swift/.h/.m/.mm文件中输入 // TODO: 或者 // FIXME: 就会有警告提示 第一种方式：直接添加 添加以下代码： 12345TAGS="TODO:|FIXME:"echo "Searching \"$&#123;TAGS&#125;\" From \"$&#123;SRCROOT&#125;/$&#123;TARGET_NAME&#125;\" "find -E "$&#123;SRCROOT&#125;/$&#123;TARGET_NAME&#125;" -iregex ".*(\.h|\.m|\.mm|\.swift)$" -print0 | \xargs -0 egrep --with-filename --line-number --only-matching "($TAGS).*\$" | \perl -p -e "s/($TAGS)/ warning: \$1/" &quot;${SRCROOT}/${TARGET_NAME}&quot;为查询的目录 &quot;.*(\.h|\.m|\.mm|\.swift)$&quot;为文件后缀名列表 如下图： 第二种方式：脚本文件 项目根目录添加showWarningScript.sh 代码与上面相同 12345TAGS="TODO:|FIXME:"echo "Searching \"$&#123;TAGS&#125;\" From \"$&#123;SRCROOT&#125;/$&#123;TARGET_NAME&#125;\" "find -E "$&#123;SRCROOT&#125;/$&#123;TARGET_NAME&#125;" -iregex ".*(\.h|\.m|\.mm|\.swift)$" -print0 | \xargs -0 egrep --with-filename --line-number --only-matching "($TAGS).*\$" | \perl -p -e "s/($TAGS)/ warning: \$1/" Run Script中添加 1$PROJECT_DIR/showWarningScript.sh 如下图：]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
